var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { c as commonjsGlobal$1, a as getAugmentedNamespace$1, g as getDefaultExportFromCjs } from "./lodash.f70a6700.js";
import { M as Moveable } from "./moveable.233986a5.js";
import { h as html2canvas } from "./html2canvas.c4a43e03.js";
var require_index_e12ed25b = __commonJS({
  "assets/index.e12ed25b.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script2) {
        const fetchOpts = {};
        if (script2.integrity)
          fetchOpts.integrity = script2.integrity;
        if (script2.referrerpolicy)
          fetchOpts.referrerPolicy = script2.referrerpolicy;
        if (script2.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script2.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function makeMap(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i2 = 0; i2 < list.length; i2++) {
        map[list[i2]] = true;
      }
      return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
    }
    const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function normalizeStyle(value) {
      if (isArray$7(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$3(value)) {
        return value;
      } else if (isObject$b(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$3(value)) {
        res = value;
      } else if (isArray$7(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$b(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style: style2 } = props;
      if (klass && !isString$3(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style2) {
        props.style = normalizeStyle(style2);
      }
      return props;
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a.length; i2++) {
        equal = looseEqual(a[i2], b[i2]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate$1(a);
      let bValidType = isDate$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$6(a);
      bValidType = isSymbol$6(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$7(a);
      bValidType = isArray$7(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$b(a);
      bValidType = isObject$b(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const toDisplayString = (val) => {
      return isString$3(val) ? val : val == null ? "" : isArray$7(val) || isObject$b(val) && (val.toString === objectToString$5 || !isFunction$6(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap$3(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet$3(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject$b(val) && !isArray$7(val) && !isPlainObject$4(val)) {
        return String(val);
      }
      return val;
    };
    const EMPTY_OBJ$1 = {};
    const EMPTY_ARR = [];
    const NOOP$1 = () => {
    };
    const NO = () => false;
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$3 = Object.assign;
    const remove$1 = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$d = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
    const isArray$7 = Array.isArray;
    const isMap$3 = (val) => toTypeString$1(val) === "[object Map]";
    const isSet$3 = (val) => toTypeString$1(val) === "[object Set]";
    const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
    const isFunction$6 = (val) => typeof val === "function";
    const isString$3 = (val) => typeof val === "string";
    const isSymbol$6 = (val) => typeof val === "symbol";
    const isObject$b = (val) => val !== null && typeof val === "object";
    const isPromise$1 = (val) => {
      return isObject$b(val) && isFunction$6(val.then) && isFunction$6(val.catch);
    };
    const objectToString$5 = Object.prototype.toString;
    const toTypeString$1 = (value) => objectToString$5.call(value);
    const toRawType = (value) => {
      return toTypeString$1(value).slice(8, -1);
    };
    const isPlainObject$4 = (val) => toTypeString$1(val) === "[object Object]";
    const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
    const cacheStringFunction = (fn) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
    const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
    const hasChanged$1 = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    const def$1 = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const toNumber$2 = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    let activeEffectScope$1;
    class EffectScope {
      constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope$1) {
          this.parent = activeEffectScope$1;
          this.index = (activeEffectScope$1.scopes || (activeEffectScope$1.scopes = [])).push(this) - 1;
        }
      }
      run(fn) {
        if (this.active) {
          const currentEffectScope = activeEffectScope$1;
          try {
            activeEffectScope$1 = this;
            return fn();
          } finally {
            activeEffectScope$1 = currentEffectScope;
          }
        }
      }
      on() {
        activeEffectScope$1 = this;
      }
      off() {
        activeEffectScope$1 = this.parent;
      }
      stop(fromParent) {
        if (this.active) {
          let i2, l;
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.active = false;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope$1(effect2, scope = activeEffectScope$1) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope$1;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope$1) {
        activeEffectScope$1.cleanups.push(fn);
      }
    }
    const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    const wasTracked$1 = (dep) => (dep.w & trackOpBit$1) > 0;
    const newTracked$1 = (dep) => (dep.n & trackOpBit$1) > 0;
    const initDepMarkers$1 = ({ deps }) => {
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].w |= trackOpBit$1;
        }
      }
    };
    const finalizeDepMarkers$1 = (effect2) => {
      const { deps } = effect2;
      if (deps.length) {
        let ptr = 0;
        for (let i2 = 0; i2 < deps.length; i2++) {
          const dep = deps[i2];
          if (wasTracked$1(dep) && !newTracked$1(dep)) {
            dep.delete(effect2);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit$1;
          dep.n &= ~trackOpBit$1;
        }
        deps.length = ptr;
      }
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    let effectTrackDepth$1 = 0;
    let trackOpBit$1 = 1;
    const maxMarkerBits$1 = 30;
    let activeEffect$1;
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    class ReactiveEffect$1 {
      constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope$1(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent2 = activeEffect$1;
        let lastShouldTrack = shouldTrack;
        while (parent2) {
          if (parent2 === this) {
            return;
          }
          parent2 = parent2.parent;
        }
        try {
          this.parent = activeEffect$1;
          activeEffect$1 = this;
          shouldTrack = true;
          trackOpBit$1 = 1 << ++effectTrackDepth$1;
          if (effectTrackDepth$1 <= maxMarkerBits$1) {
            initDepMarkers$1(this);
          } else {
            cleanupEffect$1(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth$1 <= maxMarkerBits$1) {
            finalizeDepMarkers$1(this);
          }
          trackOpBit$1 = 1 << --effectTrackDepth$1;
          activeEffect$1 = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
          if (this.deferStop) {
            this.stop();
          }
        }
      }
      stop() {
        if (activeEffect$1 === this) {
          this.deferStop = true;
        } else if (this.active) {
          cleanupEffect$1(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect$1(effect2) {
      const { deps } = effect2;
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].delete(effect2);
        }
        deps.length = 0;
      }
    }
    function effect(fn, options) {
      if (fn.effect) {
        fn = fn.effect.fn;
      }
      const _effect = new ReactiveEffect$1(fn);
      if (options) {
        extend$3(_effect, options);
        if (options.scope)
          recordEffectScope$1(_effect, options.scope);
      }
      if (!options || !options.lazy) {
        _effect.run();
      }
      const runner = _effect.run.bind(_effect);
      runner.effect = _effect;
      return runner;
    }
    function stop(runner) {
      runner.effect.stop();
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type2, key) {
      if (shouldTrack && activeEffect$1) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth$1 <= maxMarkerBits$1) {
        if (!newTracked$1(dep)) {
          dep.n |= trackOpBit$1;
          shouldTrack2 = !wasTracked$1(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect$1);
      }
      if (shouldTrack2) {
        dep.add(activeEffect$1);
        activeEffect$1.deps.push(dep);
      }
    }
    function trigger(target, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type2 === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$7(target)) {
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 >= newValue) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type2) {
          case "add":
            if (!isArray$7(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$3(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$7(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$3(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$3(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      const effects = isArray$7(dep) ? dep : [...dep];
      for (const effect2 of effects) {
        if (effect2.computed) {
          triggerEffect(effect2);
        }
      }
      for (const effect2 of effects) {
        if (!effect2.computed) {
          triggerEffect(effect2);
        }
      }
    }
    function triggerEffect(effect2, debuggerEventExtraInfo) {
      if (effect2 !== activeEffect$1 || effect2.allowRecurse) {
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$6));
    const get$2 = /* @__PURE__ */ createGetter();
    const shallowGet = /* @__PURE__ */ createGetter(false, true);
    const readonlyGet = /* @__PURE__ */ createGetter(true);
    const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l = this.length; i2 < l; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function createGetter(isReadonly2 = false, shallow = false) {
      return function get2(target, key, receiver) {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = isArray$7(target);
        if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$6(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef$1(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$b(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      };
    }
    const set$1 = /* @__PURE__ */ createSetter();
    const shallowSet = /* @__PURE__ */ createSetter(true);
    function createSetter(shallow = false) {
      return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly$1(oldValue) && isRef$1(oldValue) && !isRef$1(value)) {
          return false;
        }
        if (!shallow && !isReadonly$1(value)) {
          if (!isShallow$1(value)) {
            value = toRaw(value);
            oldValue = toRaw(oldValue);
          }
          if (!isArray$7(target) && isRef$1(oldValue) && !isRef$1(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = isArray$7(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged$1(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      };
    }
    function deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function has$2(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$6(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    function ownKeys$1(target) {
      track(target, "iterate", isArray$7(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    }
    const mutableHandlers = {
      get: get$2,
      set: set$1,
      deleteProperty,
      has: has$2,
      ownKeys: ownKeys$1
    };
    const readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        return true;
      },
      deleteProperty(target, key) {
        return true;
      }
    };
    const shallowReactiveHandlers = /* @__PURE__ */ extend$3({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
    });
    const shallowReadonlyHandlers = /* @__PURE__ */ extend$3({}, readonlyHandlers, {
      get: shallowReadonlyGet
    });
    const toShallow = (value) => value;
    const getProto$1 = (v) => Reflect.getPrototypeOf(v);
    function get$1$1(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto$1(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has$1$1(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size$1(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto$1(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$1$1(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto$1(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged$1(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto$1(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$3(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        return type2 === "delete" ? false : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$1$1(this, key);
        },
        get size() {
          return size$1(this);
        },
        has: has$1$1,
        add,
        set: set$1$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$1$1(this, key, false, true);
        },
        get size() {
          return size$1(this);
        },
        has: has$1$1,
        add,
        set: set$1$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$1$1(this, key, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has$1$1.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$1$1(this, key, true, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has$1$1.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly$1(target)) {
        return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
    }
    function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
    }
    function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
    }
    function shallowReadonly(target) {
      return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$b(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive$1(value) {
      if (isReadonly$1(value)) {
        return isReactive$1(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly$1(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow$1(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive$1(value) || isReadonly$1(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw$1(value) {
      def$1(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$b(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$b(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect$1) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      if (ref2.dep) {
        {
          triggerEffects(ref2.dep);
        }
      }
    }
    function isRef$1(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef$1(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if (hasChanged$1(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = this.__v_isShallow ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    }
    function triggerRef(ref2) {
      triggerRefValue(ref2);
    }
    function unref$1(ref2) {
      return isRef$1(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers$1 = {
      get: (target, key, receiver) => unref$1(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef$1(oldValue) && !isRef$1(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs$1(objectWithRefs) {
      return isReactive$1(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers$1);
    }
    class CustomRefImpl {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object) {
      const ret = isArray$7(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = toRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
    }
    function toRef(object, key, defaultValue) {
      const val = object[key];
      return isRef$1(val) ? val : new ObjectRefImpl(object, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect$1(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$6(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP$1;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    const stack = [];
    function warn(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling$1(appWarnHandler, instance, 11, [
          msg + args.join(""),
          instance && instance.proxy,
          trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
          trace
        ]);
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i2) => {
        logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$3(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef$1(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$6(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling$1(fn, instance, type2, args) {
      let res;
      try {
        res = args ? fn(...args) : fn();
      } catch (err) {
        handleError$1(err, instance, type2);
      }
      return res;
    }
    function callWithAsyncErrorHandling$1(fn, instance, type2, args) {
      if (isFunction$6(fn)) {
        const res = callWithErrorHandling$1(fn, instance, type2, args);
        if (res && isPromise$1(res)) {
          res.catch((err) => {
            handleError$1(err, instance, type2);
          });
        }
        return res;
      }
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling$1(fn[i2], instance, type2, args));
      }
      return values;
    }
    function handleError$1(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type2;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling$1(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
          return;
        }
      }
      logError$1(err, type2, contextVNode, throwInDev);
    }
    function logError$1(err, type2, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing$1 = false;
    let isFlushPending$1 = false;
    const queue$1 = [];
    let flushIndex$1 = 0;
    const pendingPreFlushCbs$1 = [];
    let activePreFlushCbs$1 = null;
    let preFlushIndex$1 = 0;
    const pendingPostFlushCbs$1 = [];
    let activePostFlushCbs$1 = null;
    let postFlushIndex$1 = 0;
    const resolvedPromise$1 = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise$1 = null;
    let currentPreFlushParentJob$1 = null;
    function nextTick$1(fn) {
      const p2 = currentFlushPromise$1 || resolvedPromise$1;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex$1(id) {
      let start = flushIndex$1 + 1;
      let end = queue$1.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJobId = getId$2(queue$1[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
      }
      return start;
    }
    function queueJob$1(job) {
      if ((!queue$1.length || !queue$1.includes(job, isFlushing$1 && job.allowRecurse ? flushIndex$1 + 1 : flushIndex$1)) && job !== currentPreFlushParentJob$1) {
        if (job.id == null) {
          queue$1.push(job);
        } else {
          queue$1.splice(findInsertionIndex$1(job.id), 0, job);
        }
        queueFlush$1();
      }
    }
    function queueFlush$1() {
      if (!isFlushing$1 && !isFlushPending$1) {
        isFlushPending$1 = true;
        currentFlushPromise$1 = resolvedPromise$1.then(flushJobs$1);
      }
    }
    function invalidateJob(job) {
      const i2 = queue$1.indexOf(job);
      if (i2 > flushIndex$1) {
        queue$1.splice(i2, 1);
      }
    }
    function queueCb$1(cb, activeQueue, pendingQueue, index2) {
      if (!isArray$7(cb)) {
        if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
          pendingQueue.push(cb);
        }
      } else {
        pendingQueue.push(...cb);
      }
      queueFlush$1();
    }
    function queuePreFlushCb$1(cb) {
      queueCb$1(cb, activePreFlushCbs$1, pendingPreFlushCbs$1, preFlushIndex$1);
    }
    function queuePostFlushCb$1(cb) {
      queueCb$1(cb, activePostFlushCbs$1, pendingPostFlushCbs$1, postFlushIndex$1);
    }
    function flushPreFlushCbs$1(seen2, parentJob = null) {
      if (pendingPreFlushCbs$1.length) {
        currentPreFlushParentJob$1 = parentJob;
        activePreFlushCbs$1 = [...new Set(pendingPreFlushCbs$1)];
        pendingPreFlushCbs$1.length = 0;
        for (preFlushIndex$1 = 0; preFlushIndex$1 < activePreFlushCbs$1.length; preFlushIndex$1++) {
          activePreFlushCbs$1[preFlushIndex$1]();
        }
        activePreFlushCbs$1 = null;
        preFlushIndex$1 = 0;
        currentPreFlushParentJob$1 = null;
        flushPreFlushCbs$1(seen2, parentJob);
      }
    }
    function flushPostFlushCbs$1(seen2) {
      flushPreFlushCbs$1();
      if (pendingPostFlushCbs$1.length) {
        const deduped = [...new Set(pendingPostFlushCbs$1)];
        pendingPostFlushCbs$1.length = 0;
        if (activePostFlushCbs$1) {
          activePostFlushCbs$1.push(...deduped);
          return;
        }
        activePostFlushCbs$1 = deduped;
        activePostFlushCbs$1.sort((a, b) => getId$2(a) - getId$2(b));
        for (postFlushIndex$1 = 0; postFlushIndex$1 < activePostFlushCbs$1.length; postFlushIndex$1++) {
          activePostFlushCbs$1[postFlushIndex$1]();
        }
        activePostFlushCbs$1 = null;
        postFlushIndex$1 = 0;
      }
    }
    const getId$2 = (job) => job.id == null ? Infinity : job.id;
    function flushJobs$1(seen2) {
      isFlushPending$1 = false;
      isFlushing$1 = true;
      flushPreFlushCbs$1(seen2);
      queue$1.sort((a, b) => getId$2(a) - getId$2(b));
      const check = NOOP$1;
      try {
        for (flushIndex$1 = 0; flushIndex$1 < queue$1.length; flushIndex$1++) {
          const job = queue$1[flushIndex$1];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling$1(job, null, 14);
          }
        }
      } finally {
        flushIndex$1 = 0;
        queue$1.length = 0;
        flushPostFlushCbs$1();
        isFlushing$1 = false;
        currentFlushPromise$1 = null;
        if (queue$1.length || pendingPreFlushCbs$1.length || pendingPostFlushCbs$1.length) {
          flushJobs$1(seen2);
        }
      }
    }
    let devtools;
    let buffer = [];
    function setDevtoolsHook(hook, target) {
      var _a, _b;
      devtools = hook;
      if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
      } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook) => {
          setDevtoolsHook(newHook, target);
        });
        setTimeout(() => {
          if (!devtools) {
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
            buffer = [];
          }
        }, 3e3);
      } else {
        buffer = [];
      }
    }
    function emit$1(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ$1;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ$1;
        if (trim2) {
          args = rawArgs.map((a) => a.trim());
        }
        if (number2) {
          args = rawArgs.map(toNumber$2);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling$1(handler, instance, 6, args);
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling$1(onceHandler, instance, 6, args);
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$6(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$3(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        cache2.set(comp, null);
        return null;
      }
      if (isArray$7(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$3(normalized, raw);
      }
      cache2.set(comp, normalized);
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id) {
      currentScopeId = id;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    const withScopeId = (_id) => withCtx;
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render: render11, renderCache, data: data2, setupState, ctx, inheritAttrs } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          result = normalizeVNode(render11.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
          fallthroughAttrs = attrs;
        } else {
          const render12 = Component;
          if (false)
            ;
          result = normalizeVNode(render12.length > 1 ? render12(props, false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit
          } : { attrs, slots, emit }) : render12(props, null));
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError$1(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    function filterSingleRoot(children) {
      let singleRoot;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent: parent2 }, el) {
      while (parent2 && parent2.subTree === vnode) {
        (vnode = parent2.vnode).el = el;
        parent2 = parent2.parent;
      }
    }
    const isSuspense = (type2) => type2.__isSuspense;
    const SuspenseImpl = {
      name: "Suspense",
      __isSuspense: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) {
          mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        } else {
          patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
      },
      hydrate: hydrateSuspense,
      create: createSuspenseBoundary,
      normalize: normalizeSuspenseChildren
    };
    const Suspense = SuspenseImpl;
    function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (isFunction$6(eventListener)) {
        eventListener();
      }
    }
    function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
      const { p: patch, o: { createElement } } = rendererInternals;
      const hiddenContainer = createElement("div");
      const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
      patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
      if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
      } else {
        suspense.resolve();
      }
    }
    function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = n2.suspense = n1.suspense;
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
          patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else if (isInFallback) {
            patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newFallback);
          }
        } else {
          suspense.pendingId++;
          if (isHydrating) {
            suspense.isHydrating = false;
            suspense.activeBranch = pendingBranch;
          } else {
            unmount(pendingBranch, parentComponent, suspense);
          }
          suspense.deps = 0;
          suspense.effects.length = 0;
          suspense.hiddenContainer = createElement("div");
          if (isInFallback) {
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
              setActiveBranch(suspense, newFallback);
            }
          } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            suspense.resolve(true);
          } else {
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
              suspense.resolve();
            }
          }
        }
      } else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newBranch);
        } else {
          triggerEvent(n2, "onPending");
          suspense.pendingBranch = newBranch;
          suspense.pendingId++;
          patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) {
              setTimeout(() => {
                if (suspense.pendingId === pendingId) {
                  suspense.fallback(newFallback);
                }
              }, timeout);
            } else if (timeout === 0) {
              suspense.fallback(newFallback);
            }
          }
        }
      }
    }
    function createSuspenseBoundary(vnode, parent2, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove2 } } = rendererInternals;
      const timeout = toNumber$2(vnode.props && vnode.props.timeout);
      const suspense = {
        vnode,
        parent: parent2,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
          const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
          if (suspense.isHydrating) {
            suspense.isHydrating = false;
          } else if (!resume) {
            const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = () => {
                if (pendingId === suspense.pendingId) {
                  move(pendingBranch, container2, anchor2, 0);
                }
              };
            }
            let { anchor: anchor2 } = suspense;
            if (activeBranch) {
              anchor2 = next(activeBranch);
              unmount(activeBranch, parentComponent2, suspense, true);
            }
            if (!delayEnter) {
              move(pendingBranch, container2, anchor2, 0);
            }
          }
          setActiveBranch(suspense, pendingBranch);
          suspense.pendingBranch = null;
          suspense.isInFallback = false;
          let parent3 = suspense.parent;
          let hasUnresolvedAncestor = false;
          while (parent3) {
            if (parent3.pendingBranch) {
              parent3.effects.push(...effects);
              hasUnresolvedAncestor = true;
              break;
            }
            parent3 = parent3.parent;
          }
          if (!hasUnresolvedAncestor) {
            queuePostFlushCb$1(effects);
          }
          suspense.effects = [];
          triggerEvent(vnode2, "onResolve");
        },
        fallback(fallbackVNode) {
          if (!suspense.pendingBranch) {
            return;
          }
          const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
          triggerEvent(vnode2, "onFallback");
          const anchor2 = next(activeBranch);
          const mountFallback = () => {
            if (!suspense.isInFallback) {
              return;
            }
            patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
            setActiveBranch(suspense, fallbackVNode);
          };
          const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = mountFallback;
          }
          suspense.isInFallback = true;
          unmount(activeBranch, parentComponent2, null, true);
          if (!delayEnter) {
            mountFallback();
          }
        },
        move(container2, anchor2, type2) {
          suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type2);
          suspense.container = container2;
        },
        next() {
          return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
          const isInPendingSuspense = !!suspense.pendingBranch;
          if (isInPendingSuspense) {
            suspense.deps++;
          }
          const hydratedEl = instance.vnode.el;
          instance.asyncDep.catch((err) => {
            handleError$1(err, instance, 0);
          }).then((asyncSetupResult) => {
            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
              return;
            }
            instance.asyncResolved = true;
            const { vnode: vnode2 } = instance;
            handleSetupResult(instance, asyncSetupResult, false);
            if (hydratedEl) {
              vnode2.el = hydratedEl;
            }
            const placeholder = !hydratedEl && instance.subTree.el;
            setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
            if (placeholder) {
              remove2(placeholder);
            }
            updateHOCHostEl(instance, vnode2.el);
            if (isInPendingSuspense && --suspense.deps === 0) {
              suspense.resolve();
            }
          });
        },
        unmount(parentSuspense, doRemove) {
          suspense.isUnmounted = true;
          if (suspense.activeBranch) {
            unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
          }
          if (suspense.pendingBranch) {
            unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
          }
        }
      };
      return suspense;
    }
    function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
      const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
      if (suspense.deps === 0) {
        suspense.resolve();
      }
      return result;
    }
    function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32;
      vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
      vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
    }
    function normalizeSuspenseSlot(s) {
      let block;
      if (isFunction$6(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
          s._d = false;
          openBlock();
        }
        s = s();
        if (trackBlock) {
          s._d = true;
          block = currentBlock;
          closeBlock();
        }
      }
      if (isArray$7(s)) {
        const singleChild = filterSingleRoot(s);
        s = singleChild;
      }
      s = normalizeVNode(s);
      if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter((c) => c !== s);
      }
      return s;
    }
    function queueEffectWithSuspense$1(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$7(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb$1(fn);
      }
    }
    function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      const el = vnode.el = branch.el;
      if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
      }
    }
    function provide(key, value) {
      if (!currentInstance$1)
        ;
      else {
        let provides = currentInstance$1.provides;
        const parentProvides = currentInstance$1.parent && currentInstance$1.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance$1.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance$1 || currentRenderingInstance;
      if (instance) {
        const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$6(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function watchEffect(effect2, options) {
      return doWatch$1(effect2, null, options);
    }
    function watchPostEffect(effect2, options) {
      return doWatch$1(effect2, null, { flush: "post" });
    }
    function watchSyncEffect(effect2, options) {
      return doWatch$1(effect2, null, { flush: "sync" });
    }
    const INITIAL_WATCHER_VALUE$1 = {};
    function watch(source, cb, options) {
      return doWatch$1(source, cb, options);
    }
    function doWatch$1(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ$1) {
      const instance = currentInstance$1;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef$1(source)) {
        getter = () => source.value;
        forceTrigger = isShallow$1(source);
      } else if (isReactive$1(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$7(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive$1(s) || isShallow$1(s));
        getter = () => source.map((s) => {
          if (isRef$1(s)) {
            return s.value;
          } else if (isReactive$1(s)) {
            return traverse$1(s);
          } else if (isFunction$6(s)) {
            return callWithErrorHandling$1(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$6(source)) {
        if (cb) {
          getter = () => callWithErrorHandling$1(source, instance, 2);
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling$1(source, instance, 3, [onCleanup]);
          };
        }
      } else {
        getter = NOOP$1;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse$1(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling$1(fn, instance, 4);
        };
      };
      if (isInSSRComponentSetup) {
        onCleanup = NOOP$1;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling$1(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        return NOOP$1;
      }
      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE$1;
      const job = () => {
        if (!effect2.active) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged$1(v, oldValue[i2])) : hasChanged$1(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling$1(cb, instance, 3, [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE$1 ? void 0 : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect$1(job, instance && instance.suspense);
      } else {
        scheduler = () => queuePreFlushCb$1(job);
      }
      const effect2 = new ReactiveEffect$1(getter, scheduler);
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect$1(effect2.run.bind(effect2), instance && instance.suspense);
      } else {
        effect2.run();
      }
      return () => {
        effect2.stop();
        if (instance && instance.scope) {
          remove$1(instance.scope.effects, effect2);
        }
      };
    }
    function instanceWatch$1(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$3(source) ? source.includes(".") ? createPathGetter$1(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$6(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const cur = currentInstance$1;
      setCurrentInstance$1(this);
      const res = doWatch$1(getter, cb.bind(publicThis), options);
      if (cur) {
        setCurrentInstance$1(cur);
      } else {
        unsetCurrentInstance$1();
      }
      return res;
    }
    function createPathGetter$1(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse$1(value, seen2) {
      if (!isObject$b(value) || value["__v_skip"]) {
        return value;
      }
      seen2 = seen2 || /* @__PURE__ */ new Set();
      if (seen2.has(value)) {
        return value;
      }
      seen2.add(value);
      if (isRef$1(value)) {
        traverse$1(value.value, seen2);
      } else if (isArray$7(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse$1(value[i2], seen2);
        }
      } else if (isSet$3(value) || isMap$3(value)) {
        value.forEach((v) => {
          traverse$1(v, seen2);
        });
      } else if (isPlainObject$4(value)) {
        for (const key in value) {
          traverse$1(value[key], seen2);
        }
      }
      return value;
    }
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c of children) {
              if (c.type !== Comment) {
                child = c;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                instance.update();
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el._leaveCb = () => {
                  earlyRemove();
                  el._leaveCb = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling$1(hook, instance, 9, args);
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$7(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el._leaveCb) {
            el._leaveCb(true);
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
            leavingVNode.el._leaveCb();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el._enterCb = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el._enterCb = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el._enterCb) {
            el._enterCb(true);
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el._leaveCb = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el._leaveCb = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = children[i2];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    function defineComponent(options) {
      return isFunction$6(options) ? { setup: options, name: options.name } : options;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    function defineAsyncComponent(source) {
      if (isFunction$6(source)) {
        source = { loader: source };
      }
      const {
        loader,
        loadingComponent,
        errorComponent,
        delay = 200,
        timeout,
        suspensible = true,
        onError: userOnError
      } = source;
      let pendingRequest = null;
      let resolvedComp;
      let retries = 0;
      const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
      };
      const load = () => {
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
          err = err instanceof Error ? err : new Error(String(err));
          if (userOnError) {
            return new Promise((resolve2, reject) => {
              const userRetry = () => resolve2(retry());
              const userFail = () => reject(err);
              userOnError(err, userRetry, userFail, retries + 1);
            });
          } else {
            throw err;
          }
        }).then((comp) => {
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest;
          }
          if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
            comp = comp.default;
          }
          resolvedComp = comp;
          return comp;
        }));
      };
      return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved() {
          return resolvedComp;
        },
        setup() {
          const instance = currentInstance$1;
          if (resolvedComp) {
            return () => createInnerComp(resolvedComp, instance);
          }
          const onError = (err) => {
            pendingRequest = null;
            handleError$1(err, instance, 13, !errorComponent);
          };
          if (suspensible && instance.suspense || isInSSRComponentSetup) {
            return load().then((comp) => {
              return () => createInnerComp(comp, instance);
            }).catch((err) => {
              onError(err);
              return () => errorComponent ? createVNode(errorComponent, {
                error: err
              }) : null;
            });
          }
          const loaded = ref(false);
          const error = ref();
          const delayed = ref(!!delay);
          if (delay) {
            setTimeout(() => {
              delayed.value = false;
            }, delay);
          }
          if (timeout != null) {
            setTimeout(() => {
              if (!loaded.value && !error.value) {
                const err = new Error(`Async component timed out after ${timeout}ms.`);
                onError(err);
                error.value = err;
              }
            }, timeout);
          }
          load().then(() => {
            loaded.value = true;
            if (instance.parent && isKeepAlive(instance.parent.vnode)) {
              queueJob$1(instance.parent.update);
            }
          }).catch((err) => {
            onError(err);
            error.value = err;
          });
          return () => {
            if (loaded.value && resolvedComp) {
              return createInnerComp(resolvedComp, instance);
            } else if (error.value && errorComponent) {
              return createVNode(errorComponent, {
                error: error.value
              });
            } else if (loadingComponent && !delayed.value) {
              return createVNode(loadingComponent);
            }
          };
        }
      });
    }
    function createInnerComp(comp, { vnode: { ref: ref2, props, children, shapeFlag }, parent: parent2 }) {
      const vnode = createVNode(comp, props, children);
      vnode.ref = ref2;
      return vnode;
    }
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    const KeepAliveImpl = {
      name: `KeepAlive`,
      __isKeepAlive: true,
      props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) {
          return () => {
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
          };
        }
        const cache2 = /* @__PURE__ */ new Map();
        const keys2 = /* @__PURE__ */ new Set();
        let current = null;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
          const instance2 = vnode.component;
          move(vnode, container, anchor, 0, parentSuspense);
          patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
          queuePostRenderEffect$1(() => {
            instance2.isDeactivated = false;
            if (instance2.a) {
              invokeArrayFns(instance2.a);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
          }, parentSuspense);
        };
        sharedContext.deactivate = (vnode) => {
          const instance2 = vnode.component;
          move(vnode, storageContainer, null, 1, parentSuspense);
          queuePostRenderEffect$1(() => {
            if (instance2.da) {
              invokeArrayFns(instance2.da);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
            instance2.isDeactivated = true;
          }, parentSuspense);
        };
        function unmount(vnode) {
          resetShapeFlag(vnode);
          _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
          cache2.forEach((vnode, key) => {
            const name = getComponentName(vnode.type);
            if (name && (!filter || !filter(name))) {
              pruneCacheEntry(key);
            }
          });
        }
        function pruneCacheEntry(key) {
          const cached = cache2.get(key);
          if (!current || cached.type !== current.type) {
            unmount(cached);
          } else if (current) {
            resetShapeFlag(current);
          }
          cache2.delete(key);
          keys2.delete(key);
        }
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
          include && pruneCache((name) => matches$1(include, name));
          exclude && pruneCache((name) => !matches$1(exclude, name));
        }, { flush: "post", deep: true });
        let pendingCacheKey = null;
        const cacheSubtree = () => {
          if (pendingCacheKey != null) {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
          cache2.forEach((cached) => {
            const { subTree, suspense } = instance;
            const vnode = getInnerChild(subTree);
            if (cached.type === vnode.type) {
              resetShapeFlag(vnode);
              const da = vnode.component.da;
              da && queuePostRenderEffect$1(da, suspense);
              return;
            }
            unmount(cached);
          });
        });
        return () => {
          pendingCacheKey = null;
          if (!slots.default) {
            return null;
          }
          const children = slots.default();
          const rawVNode = children[0];
          if (children.length > 1) {
            current = null;
            return children;
          } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
            current = null;
            return rawVNode;
          }
          let vnode = getInnerChild(rawVNode);
          const comp = vnode.type;
          const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
          const { include, exclude, max: max2 } = props;
          if (include && (!name || !matches$1(include, name)) || exclude && name && matches$1(exclude, name)) {
            current = vnode;
            return rawVNode;
          }
          const key = vnode.key == null ? comp : vnode.key;
          const cachedVNode = cache2.get(key);
          if (vnode.el) {
            vnode = cloneVNode(vnode);
            if (rawVNode.shapeFlag & 128) {
              rawVNode.ssContent = vnode;
            }
          }
          pendingCacheKey = key;
          if (cachedVNode) {
            vnode.el = cachedVNode.el;
            vnode.component = cachedVNode.component;
            if (vnode.transition) {
              setTransitionHooks(vnode, vnode.transition);
            }
            vnode.shapeFlag |= 512;
            keys2.delete(key);
            keys2.add(key);
          } else {
            keys2.add(key);
            if (max2 && keys2.size > parseInt(max2, 10)) {
              pruneCacheEntry(keys2.values().next().value);
            }
          }
          vnode.shapeFlag |= 256;
          current = vnode;
          return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
      }
    };
    const KeepAlive = KeepAliveImpl;
    function matches$1(pattern, name) {
      if (isArray$7(pattern)) {
        return pattern.some((p2) => matches$1(p2, name));
      } else if (isString$3(pattern)) {
        return pattern.split(",").includes(name);
      } else if (pattern.test) {
        return pattern.test(name);
      }
      return false;
    }
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type2, target = currentInstance$1) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
      const injected = injectHook(type2, hook, keepAliveRoot, true);
      onUnmounted(() => {
        remove$1(keepAliveRoot[type2], injected);
      }, target);
    }
    function resetShapeFlag(vnode) {
      let shapeFlag = vnode.shapeFlag;
      if (shapeFlag & 256) {
        shapeFlag -= 256;
      }
      if (shapeFlag & 512) {
        shapeFlag -= 512;
      }
      vnode.shapeFlag = shapeFlag;
    }
    function getInnerChild(vnode) {
      return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
    }
    function injectHook(type2, hook, target = currentInstance$1, prepend = false) {
      if (target) {
        const hooks = target[type2] || (target[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          setCurrentInstance$1(target);
          const res = callWithAsyncErrorHandling$1(hook, target, type2, args);
          unsetCurrentInstance$1();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance$1) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance$1) {
      injectHook("ec", hook, target);
    }
    function withDirectives(vnode, directives2) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy$1(internalInstance) || internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives2.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ$1] = directives2[i2];
        if (isFunction$6(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse$1(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling$1(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol();
    function resolveDynamicComponent(component) {
      if (isString$3(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance$1;
      if (instance) {
        const Component = instance.type;
        if (type2 === COMPONENTS) {
          const selfName = getComponentName(Component, false);
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = resolve(instance[type2] || Component[type2], name) || resolve(instance.appContext[type2], name);
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    function renderList(source, renderItem, cache2, index2) {
      let ret;
      const cached = cache2 && cache2[index2];
      if (isArray$7(source) || isString$3(source)) {
        ret = new Array(source.length);
        for (let i2 = 0, l = source.length; i2 < l; i2++) {
          ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$b(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache2) {
        cache2[index2] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$7(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj) {
      const ret = {};
      for (const key in obj) {
        ret[toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    const getPublicInstance$1 = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent$1(i2))
        return getExposeProxy$1(i2) || i2.proxy;
      return getPublicInstance$1(i2.parent);
    };
    const publicPropertiesMap$1 = /* @__PURE__ */ extend$3(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => i2.props,
      $attrs: (i2) => i2.attrs,
      $slots: (i2) => i2.slots,
      $refs: (i2) => i2.refs,
      $parent: (i2) => getPublicInstance$1(i2.parent),
      $root: (i2) => getPublicInstance$1(i2.root),
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions$1(i2),
      $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob$1(i2.update)),
      $nextTick: (i2) => i2.n || (i2.n = nextTick$1.bind(i2.proxy)),
      $watch: (i2) => instanceWatch$1.bind(i2)
    });
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data: data2, props, accessCache, type: type2, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data2[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (setupState !== EMPTY_OBJ$1 && hasOwn(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data2 !== EMPTY_OBJ$1 && hasOwn(data2, key)) {
            accessCache[key] = 2;
            return data2[key];
          } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ$1 && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap$1[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if ((cssModule = type2.__cssModules) && (cssModule = cssModule[key])) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ$1 && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data: data2, setupState, ctx } = instance;
        if (setupState !== EMPTY_OBJ$1 && hasOwn(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data2 !== EMPTY_OBJ$1 && hasOwn(data2, key)) {
          data2[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({ _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data2 !== EMPTY_OBJ$1 && hasOwn(data2, key) || setupState !== EMPTY_OBJ$1 && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap$1, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$3({}, PublicInstanceProxyHandlers, {
      get(target, key) {
        if (key === Symbol.unscopables) {
          return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
      },
      has(_, key) {
        const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
        return has2;
      }
    });
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions$1(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render11,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        expose,
        inheritAttrs,
        components,
        directives: directives2,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$6(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data2 = dataOptions.call(publicThis, publicThis);
        if (!isObject$b(data2))
          ;
        else {
          instance.data = reactive(data2);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$6(opt) ? opt.bind(publicThis, publicThis) : isFunction$6(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP$1;
          const set2 = !isFunction$6(opt) && isFunction$6(opt.set) ? opt.set.bind(publicThis) : NOOP$1;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$6(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$7(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$7(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render11 && instance.render === NOOP$1) {
        instance.render = render11;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives2)
        instance.directives = directives2;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP$1, unwrapRef = false) {
      if (isArray$7(injectOptions)) {
        injectOptions = normalizeInject$1(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$b(opt)) {
          if ("default" in opt) {
            injected = inject(opt.from || key, opt.default, true);
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef$1(injected)) {
          if (unwrapRef) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v) => injected.value = v
            });
          } else {
            ctx[key] = injected;
          }
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type2) {
      callWithAsyncErrorHandling$1(isArray$7(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type2);
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter$1(publicThis, key) : () => publicThis[key];
      if (isString$3(raw)) {
        const handler = ctx[raw];
        if (isFunction$6(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$6(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$b(raw)) {
        if (isArray$7(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$6(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$6(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions$1(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
      const cached = cache2.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach((m) => mergeOptions$2(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions$2(resolved, base, optionMergeStrategies);
      }
      cache2.set(base, resolved);
      return resolved;
    }
    function mergeOptions$2(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$2(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach((m) => mergeOptions$2(to, m, strats, true));
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats$1[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats$1 = {
      data: mergeDataFn$1,
      props: mergeObjectOptions$1,
      emits: mergeObjectOptions$1,
      methods: mergeObjectOptions$1,
      computed: mergeObjectOptions$1,
      beforeCreate: mergeAsArray$1,
      created: mergeAsArray$1,
      beforeMount: mergeAsArray$1,
      mounted: mergeAsArray$1,
      beforeUpdate: mergeAsArray$1,
      updated: mergeAsArray$1,
      beforeDestroy: mergeAsArray$1,
      beforeUnmount: mergeAsArray$1,
      destroyed: mergeAsArray$1,
      unmounted: mergeAsArray$1,
      activated: mergeAsArray$1,
      deactivated: mergeAsArray$1,
      errorCaptured: mergeAsArray$1,
      serverPrefetch: mergeAsArray$1,
      components: mergeObjectOptions$1,
      directives: mergeObjectOptions$1,
      watch: mergeWatchOptions$1,
      provide: mergeDataFn$1,
      inject: mergeInject$1
    };
    function mergeDataFn$1(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend$3(isFunction$6(to) ? to.call(this, this) : to, isFunction$6(from) ? from.call(this, this) : from);
      };
    }
    function mergeInject$1(to, from) {
      return mergeObjectOptions$1(normalizeInject$1(to), normalizeInject$1(from));
    }
    function normalizeInject$1(raw) {
      if (isArray$7(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray$1(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions$1(to, from) {
      return to ? extend$3(extend$3(/* @__PURE__ */ Object.create(null), to), from) : from;
    }
    function mergeWatchOptions$1(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend$3(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray$1(to[key], from[key]);
      }
      return merged;
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def$1(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const { props, attrs, vnode: { patchFlag } } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ$1;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && isFunction$6(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              setCurrentInstance$1(instance);
              value = propsDefaults[key] = defaultValue.call(null, props);
              unsetCurrentInstance$1();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[0]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[1] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$6(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$3(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        cache2.set(comp, EMPTY_ARR);
        return EMPTY_ARR;
      }
      if (isArray$7(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ$1;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$7(opt) || isFunction$6(opt) ? { type: opt } : opt;
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[0] = booleanIndex > -1;
              prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      cache2.set(comp, res);
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
      return match ? match[1] : ctor === null ? "null" : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type2, expectedTypes) {
      if (isArray$7(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type2));
      } else if (isFunction$6(expectedTypes)) {
        return isSameType(expectedTypes, type2) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$7(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot$1 = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$6(value)) {
          slots[key] = normalizeSlot$1(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          instance.slots = toRaw(children);
          def$1(children, "_", type2);
        } else {
          normalizeObjectSlots(children, instance.slots = {});
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def$1(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ$1;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            extend$3(slots, children);
            if (!optimized && type2 === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
            delete slots[key];
          }
        }
      }
    };
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render11, hydrate2) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$6(rootComponent)) {
          rootComponent = Object.assign({}, rootComponent);
        }
        if (rootProps != null && !isObject$b(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$1,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$6(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$6(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else
              ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, isSVG) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (isHydrate && hydrate2) {
                hydrate2(vnode, rootContainer);
              } else {
                render11(vnode, rootContainer, isSVG);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getExposeProxy$1(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render11(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          }
        };
        return app2;
      };
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$7(rawRef)) {
        rawRef.forEach((r, i2) => setRef(r, oldRawRef && (isArray$7(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy$1(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref2 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ$1 ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref2) {
        if (isString$3(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef$1(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$6(ref2)) {
        callWithErrorHandling$1(ref2, owner, 12, [value, refs]);
      } else {
        const _isString = isString$3(ref2);
        const _isRef = isRef$1(ref2);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? refs[ref2] : ref2.value;
              if (isUnmount) {
                isArray$7(existing) && remove$1(existing, refValue);
              } else {
                if (!isArray$7(existing)) {
                  if (_isString) {
                    refs[ref2] = [refValue];
                    if (hasOwn(setupState, ref2)) {
                      setupState[ref2] = refs[ref2];
                    }
                  } else {
                    ref2.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref2.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref2] = value;
              if (hasOwn(setupState, ref2)) {
                setupState[ref2] = value;
              }
            } else if (_isRef) {
              ref2.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect$1(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    let hasMismatch = false;
    const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
    const isComment = (node) => node.nodeType === 8;
    function createHydrationFunctions(rendererInternals) {
      const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, createText, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
      const hydrate2 = (vnode, container) => {
        if (!container.hasChildNodes()) {
          patch(null, vnode, container);
          flushPostFlushCbs$1();
          container._vnode = vnode;
          return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs$1();
        container._vnode = vnode;
        if (hasMismatch && true) {
          console.error(`Hydration completed but contains mismatches.`);
        }
      };
      const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type: type2, ref: ref2, shapeFlag, patchFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2) {
          optimized = false;
          vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type2) {
          case Text$1:
            if (domType !== 3) {
              if (vnode.children === "") {
                insert(vnode.el = createText(""), parentNode(node), node);
                nextNode = node;
              } else {
                nextNode = onMismatch();
              }
            } else {
              if (node.data !== vnode.children) {
                hasMismatch = true;
                node.data = vnode.children;
              }
              nextNode = nextSibling(node);
            }
            break;
          case Comment:
            if (domType !== 8 || isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = nextSibling(node);
            }
            break;
          case Static:
            if (domType !== 1 && domType !== 3) {
              nextNode = onMismatch();
            } else {
              nextNode = node;
              const needToAdoptContent = !vnode.children.length;
              for (let i2 = 0; i2 < vnode.staticCount; i2++) {
                if (needToAdoptContent)
                  vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                if (i2 === vnode.staticCount - 1) {
                  vnode.anchor = nextNode;
                }
                nextNode = nextSibling(nextNode);
              }
              return nextNode;
            }
            break;
          case Fragment:
            if (!isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            break;
          default:
            if (shapeFlag & 1) {
              if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
                nextNode = onMismatch();
              } else {
                nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
              }
            } else if (shapeFlag & 6) {
              vnode.slotScopeIds = slotScopeIds;
              const container = parentNode(node);
              mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
              nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
              if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
                nextNode = nextSibling(nextNode);
              }
              if (isAsyncWrapper(vnode)) {
                let subTree;
                if (isFragmentStart) {
                  subTree = createVNode(Fragment);
                  subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                } else {
                  subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                }
                subTree.el = node;
                vnode.component.subTree = subTree;
              }
            } else if (shapeFlag & 64) {
              if (domType !== 8) {
                nextNode = onMismatch();
              } else {
                nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
              }
            } else if (shapeFlag & 128) {
              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
            } else
              ;
        }
        if (ref2 != null) {
          setRef(ref2, null, parentSuspense, vnode);
        }
        return nextNode;
      };
      const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type: type2, props, patchFlag, shapeFlag, dirs } = vnode;
        const forcePatchValue = type2 === "input" && dirs || type2 === "option";
        if (forcePatchValue || patchFlag !== -1) {
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          if (props) {
            if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
              for (const key in props) {
                if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
                  patchProp2(el, key, null, props[key], false, void 0, parentComponent);
                }
              }
            } else if (props.onClick) {
              patchProp2(el, "onClick", null, props.onClick, false, void 0, parentComponent);
            }
          }
          let vnodeHooks;
          if (vnodeHooks = props && props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
            queueEffectWithSuspense$1(() => {
              vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
          if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
            let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
            while (next) {
              hasMismatch = true;
              const cur = next;
              next = next.nextSibling;
              remove2(cur);
            }
          } else if (shapeFlag & 8) {
            if (el.textContent !== vnode.children) {
              hasMismatch = true;
              el.textContent = vnode.children;
            }
          }
        }
        return el.nextSibling;
      };
      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        for (let i2 = 0; i2 < l; i2++) {
          const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
          if (node) {
            node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          } else if (vnode.type === Text$1 && !vnode.children) {
            continue;
          } else {
            hasMismatch = true;
            patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
          }
        }
        return node;
      };
      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") {
          return nextSibling(vnode.anchor = next);
        } else {
          hasMismatch = true;
          insert(vnode.anchor = createComment(`]`), container, next);
          return next;
        }
      };
      const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        vnode.el = null;
        if (isFragment) {
          const end = locateClosingAsyncAnchor(node);
          while (true) {
            const next2 = nextSibling(node);
            if (next2 && next2 !== end) {
              remove2(next2);
            } else {
              break;
            }
          }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove2(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
      };
      const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
          node = nextSibling(node);
          if (node && isComment(node)) {
            if (node.data === "[")
              match++;
            if (node.data === "]") {
              if (match === 0) {
                return nextSibling(node);
              } else {
                match--;
              }
            }
          }
        }
        return node;
      };
      return [hydrate2, hydrateNode];
    }
    const queuePostRenderEffect$1 = queueEffectWithSuspense$1;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function createHydrationRenderer(options) {
      return baseCreateRenderer(options, createHydrationFunctions);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP$1, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref2, shapeFlag } = n2;
        switch (type2) {
          case Text$1:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, isSVG);
            }
            break;
          case Fragment:
            processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            break;
          default:
            if (shapeFlag & 1) {
              processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (shapeFlag & 6) {
              processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (shapeFlag & 64) {
              type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
            } else if (shapeFlag & 128) {
              type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
            } else
              ;
        }
        if (ref2 != null && parentComponent) {
          setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) {
          mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type: type2, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
          el = vnode.el = hostCloneNode(vnode.el);
        } else {
          el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type2 !== "foreignObject", slotScopeIds, optimized);
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect$1(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ$1;
        const newProps = n2.props || EMPTY_OBJ$1;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        } else if (!optimized) {
          patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, isSVG);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect$1(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
          patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if (oldProps !== EMPTY_OBJ$1) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
              traverseStaticChildren(n1, n2, true);
            }
          } else {
            patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
          } else {
            mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
          return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent: parent2 } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent2, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect$1(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect$1(() => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode), parentSuspense);
            }
            if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect$1(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent: parent2, vnode } = instance;
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent2, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect$1(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect$1(() => invokeVNodeHook(vnodeHook, parent2, next, vnode), parentSuspense);
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect$1(componentUpdateFn, () => queueJob$1(update), instance.scope);
        const update = instance.update = () => effect2.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs$1(void 0, instance.update);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
          unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        } else {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i2 > e1) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved2 = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex2;
            if (prevChild.key != null) {
              newIndex2 = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex2 = j;
                  break;
                }
              }
            }
            if (newIndex2 === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex2 - s2] = i2 + 1;
              if (newIndex2 >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex2;
              } else {
                moved2 = true;
              }
              patch(prevChild, c2[newIndex2], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              patched++;
            }
          }
          const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (moved2) {
              if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el, container, anchor);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect$1(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove3 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove3();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove3, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type: type2, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref2 != null) {
          setRef(ref2, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
          } else if (dynamicChildren && (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect$1(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el, anchor, transition } = vnode;
        if (type2 === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect$1(um, parentSuspense);
        }
        queuePostRenderEffect$1(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      const render11 = (vnode, container, isSVG) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs$1();
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate2;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate2, hydrateNode] = createHydrationFns(internals);
      }
      return {
        render: render11,
        hydrate: hydrate2,
        createApp: createAppAPI(render11, hydrate2)
      };
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$7(ch1) && isArray$7(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j, u, v, c;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i2] = j;
            result.push(i2);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i2] = result[u - 1];
            }
            result[u] = i2;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    const isTeleport = (type2) => type2.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$3(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled2 = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            isSVG = isSVG || isTargetSVG(target);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
          };
          if (disabled2) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG = isSVG || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
          }
          if (disabled2) {
            if (!wasDisabled) {
              moveTeleport(n2, container, mainAnchor, internals, 1);
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
              if (nextTarget) {
                moveTeleport(n2, nextTarget, null, internals, 0);
              }
            } else if (wasDisabled) {
              moveTeleport(n2, target, targetAnchor, internals, 1);
            }
          }
        }
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        if (doRemove || !isTeleportDisabled(props)) {
          hostRemove(anchor);
          if (shapeFlag & 16) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, parentAnchor, 2);
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
      const target = vnode.target = resolveTarget(vnode.props, querySelector);
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        }
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    const Fragment = Symbol(void 0);
    const Text$1 = Symbol(void 0);
    const Comment = Symbol(void 0);
    const Static = Symbol(void 0);
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, true));
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(createVNode(type2, props, children, patchFlag, dynamicProps, true));
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    function transformVNodeArgs(transformer) {
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
      return ref2 != null ? isString$3(ref2) || isRef$1(ref2) || isFunction$6(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$3(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        type2 = Comment;
      }
      if (isVNode(type2)) {
        const cloned = cloneVNode(type2, props, true);
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString$3(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$b(style2)) {
          if (isProxy(style2) && !isArray$7(style2)) {
            style2 = extend$3({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString$3(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$b(type2) ? 4 : isFunction$6(type2) ? 2 : 0;
      return createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend$3({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref2, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$7(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text$1, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$7(child)) {
        return createVNode(Fragment, null, child.slice());
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text$1, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$7(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$6(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$7(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling$1(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid$1$1 = 0;
    function createComponentInstance(vnode, parent2, suspense) {
      const type2 = vnode.type;
      const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid$1$1++,
        vnode,
        type: type2,
        parent: parent2,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new EffectScope(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent2 ? parent2.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        emit: null,
        emitted: null,
        propsDefaults: EMPTY_OBJ$1,
        inheritAttrs: type2.inheritAttrs,
        ctx: EMPTY_OBJ$1,
        data: EMPTY_OBJ$1,
        props: EMPTY_OBJ$1,
        attrs: EMPTY_OBJ$1,
        slots: EMPTY_OBJ$1,
        refs: EMPTY_OBJ$1,
        setupState: EMPTY_OBJ$1,
        setupContext: null,
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent2 ? parent2.root : instance;
      instance.emit = emit$1.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance$1 = null;
    const getCurrentInstance = () => currentInstance$1 || currentRenderingInstance;
    const setCurrentInstance$1 = (instance) => {
      currentInstance$1 = instance;
      instance.scope.on();
    };
    const unsetCurrentInstance$1 = () => {
      currentInstance$1 && currentInstance$1.scope.off();
      currentInstance$1 = null;
    };
    function isStatefulComponent$1(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent$1(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isInSSRComponentSetup = false;
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw$1(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance$1(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling$1(setup, instance, 0, [instance.props, setupContext]);
        resetTracking();
        unsetCurrentInstance$1();
        if (isPromise$1(setupResult)) {
          setupResult.then(unsetCurrentInstance$1, unsetCurrentInstance$1);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError$1(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$6(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$b(setupResult)) {
        instance.setupState = proxyRefs$1(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile$1;
    let installWithProxy;
    function registerRuntimeCompiler(_compile) {
      compile$1 = _compile;
      installWithProxy = (i2) => {
        if (i2.render._rc) {
          i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
      };
    }
    const isRuntimeOnly = () => !compile$1;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile$1 && !Component.render) {
          const template2 = Component.template;
          if (template2) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$3(extend$3({
              isCustomElement,
              delimiters
            }, compilerOptions), componentCompilerOptions);
            Component.render = compile$1(template2, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP$1;
        if (installWithProxy) {
          installWithProxy(instance);
        }
      }
      {
        setCurrentInstance$1(instance);
        pauseTracking();
        applyOptions(instance);
        resetTracking();
        unsetCurrentInstance$1();
      }
    }
    function createAttrsProxy(instance) {
      return new Proxy(instance.attrs, {
        get(target, key) {
          track(instance, "get", "$attrs");
          return target[key];
        }
      });
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      let attrs;
      {
        return {
          get attrs() {
            return attrs || (attrs = createAttrsProxy(instance));
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy$1(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs$1(markRaw$1(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap$1) {
              return publicPropertiesMap$1[key](instance);
            }
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$6(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$6(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function defineProps() {
      return null;
    }
    function defineEmits() {
      return null;
    }
    function defineExpose(exposed) {
    }
    function withDefaults(props, defaults2) {
      return null;
    }
    function useSlots() {
      return getContext$1().slots;
    }
    function useAttrs() {
      return getContext$1().attrs;
    }
    function getContext$1() {
      const i2 = getCurrentInstance();
      return i2.setupContext || (i2.setupContext = createSetupContext(i2));
    }
    function mergeDefaults(raw, defaults2) {
      const props = isArray$7(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
      for (const key in defaults2) {
        const opt = props[key];
        if (opt) {
          if (isArray$7(opt) || isFunction$6(opt)) {
            props[key] = { type: opt, default: defaults2[key] };
          } else {
            opt.default = defaults2[key];
          }
        } else if (opt === null) {
          props[key] = { default: defaults2[key] };
        } else
          ;
      }
      return props;
    }
    function createPropsRestProxy(props, excludedKeys) {
      const ret = {};
      for (const key in props) {
        if (!excludedKeys.includes(key)) {
          Object.defineProperty(ret, key, {
            enumerable: true,
            get: () => props[key]
          });
        }
      }
      return ret;
    }
    function withAsyncContext(getAwaitable) {
      const ctx = getCurrentInstance();
      let awaitable = getAwaitable();
      unsetCurrentInstance$1();
      if (isPromise$1(awaitable)) {
        awaitable = awaitable.catch((e) => {
          setCurrentInstance$1(ctx);
          throw e;
        });
      }
      return [awaitable, () => setCurrentInstance$1(ctx)];
    }
    function h(type2, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$b(propsOrChildren) && !isArray$7(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type2, null, [propsOrChildren]);
          }
          return createVNode(type2, propsOrChildren);
        } else {
          return createVNode(type2, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type2, propsOrChildren, children);
      }
    }
    const ssrContextKey = Symbol(``);
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
          warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        }
        return ctx;
      }
    };
    function initCustomFormatter() {
      {
        return;
      }
    }
    function withMemo(memo, render11, cache2, index2) {
      const cached = cache2[index2];
      if (cached && isMemoSame(cached, memo)) {
        return cached;
      }
      const ret = render11();
      ret.memo = memo.slice();
      return cache2[index2] = ret;
    }
    function isMemoSame(cached, memo) {
      const prev = cached.memo;
      if (prev.length != memo.length) {
        return false;
      }
      for (let i2 = 0; i2 < prev.length; i2++) {
        if (hasChanged$1(prev[i2], memo[i2])) {
          return false;
        }
      }
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
      }
      return true;
    }
    const version$1 = "3.2.37";
    const _ssrUtils = {
      createComponentInstance,
      setupComponent,
      renderComponentRoot,
      setCurrentRenderingInstance,
      isVNode,
      normalizeVNode
    };
    const ssrUtils = _ssrUtils;
    const resolveFilter = null;
    const compatUtils = null;
    const svgNS = "http://www.w3.org/2000/svg";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent2, anchor) => {
        parent2.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent2 = child.parentNode;
        if (parent2) {
          parent2.removeChild(child);
        }
      },
      createElement: (tag, isSVG, is2, props) => {
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      cloneNode(el) {
        const cloned = el.cloneNode(true);
        if (`_value` in el) {
          cloned._value = el._value;
        }
        return cloned;
      },
      insertStaticContent(content, parent2, anchor, isSVG, start, end) {
        const before2 = anchor ? anchor.previousSibling : parent2.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent2.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
          const template2 = templateContainer.content;
          if (isSVG) {
            const wrapper = template2.firstChild;
            while (wrapper.firstChild) {
              template2.appendChild(wrapper.firstChild);
            }
            template2.removeChild(wrapper);
          }
          parent2.insertBefore(template2, anchor);
        }
        return [
          before2 ? before2.nextSibling : parent2.firstChild,
          anchor ? anchor.previousSibling : parent2.lastChild
        ];
      }
    };
    function patchClass(el, value, isSVG) {
      const transitionClasses = el._vtc;
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    function patchStyle(el, prev, next) {
      const style2 = el.style;
      const isCssString = isString$3(next);
      if (next && !isCssString) {
        for (const key in next) {
          setStyle(style2, key, next[key]);
        }
        if (prev && !isString$3(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        }
      } else {
        const currentDisplay = style2.display;
        if (isCssString) {
          if (prev !== next) {
            style2.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
        if ("_vod" in el) {
          style2.display = currentDisplay;
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$7(val)) {
        val.forEach((v) => setStyle(style2, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean = isSpecialBooleanAttr(key);
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
        el._value = value;
        const newValue = value == null ? "" : value;
        if (el.value !== newValue || el.tagName === "OPTION") {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
      let _getNow2 = Date.now;
      let skipTimestampCheck2 = false;
      if (typeof window !== "undefined") {
        if (Date.now() > document.createEvent("Event").timeStamp) {
          _getNow2 = performance.now.bind(performance);
        }
        const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
        skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
      }
      return [_getNow2, skipTimestampCheck2];
    })();
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const reset = () => {
      cachedNow = 0;
    };
    const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
    function addEventListener$1(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener$1(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el._vei || (el._vei = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener$1(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener$1(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      return [hyphenate(name.slice(2)), options];
    }
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
          callWithAsyncErrorHandling$1(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
        }
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$7(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
      } else {
        return value;
      }
    }
    const nativeOnRE = /^on[a-z]/;
    const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && nativeOnRE.test(key) && isFunction$6(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (nativeOnRE.test(key) && isString$3(value)) {
        return false;
      }
      return key in el;
    }
    function defineCustomElement(options, hydrate2) {
      const Comp = defineComponent(options);
      class VueCustomElement extends VueElement {
        constructor(initialProps) {
          super(Comp, initialProps, hydrate2);
        }
      }
      VueCustomElement.def = Comp;
      return VueCustomElement;
    }
    const defineSSRCustomElement = (options) => {
      return defineCustomElement(options, hydrate);
    };
    const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
    };
    class VueElement extends BaseClass {
      constructor(_def, _props = {}, hydrate2) {
        super();
        this._def = _def;
        this._props = _props;
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate2) {
          hydrate2(this._createVNode(), this.shadowRoot);
        } else {
          this.attachShadow({ mode: "open" });
        }
      }
      connectedCallback() {
        this._connected = true;
        if (!this._instance) {
          this._resolveDef();
        }
      }
      disconnectedCallback() {
        this._connected = false;
        nextTick$1(() => {
          if (!this._connected) {
            render$1m(null, this.shadowRoot);
            this._instance = null;
          }
        });
      }
      _resolveDef() {
        if (this._resolved) {
          return;
        }
        this._resolved = true;
        for (let i2 = 0; i2 < this.attributes.length; i2++) {
          this._setAttr(this.attributes[i2].name);
        }
        new MutationObserver((mutations) => {
          for (const m of mutations) {
            this._setAttr(m.attributeName);
          }
        }).observe(this, { attributes: true });
        const resolve2 = (def2) => {
          const { props, styles } = def2;
          const hasOptions = !isArray$7(props);
          const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
          let numberProps;
          if (hasOptions) {
            for (const key in this._props) {
              const opt = props[key];
              if (opt === Number || opt && opt.type === Number) {
                this._props[key] = toNumber$2(this._props[key]);
                (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
              }
            }
          }
          this._numberProps = numberProps;
          for (const key of Object.keys(this)) {
            if (key[0] !== "_") {
              this._setProp(key, this[key], true, false);
            }
          }
          for (const key of rawKeys.map(camelize)) {
            Object.defineProperty(this, key, {
              get() {
                return this._getProp(key);
              },
              set(val) {
                this._setProp(key, val);
              }
            });
          }
          this._applyStyles(styles);
          this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
          asyncDef().then(resolve2);
        } else {
          resolve2(this._def);
        }
      }
      _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
          value = toNumber$2(value);
        }
        this._setProp(camelize(key), value, false);
      }
      _getProp(key) {
        return this._props[key];
      }
      _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
          this._props[key] = val;
          if (shouldUpdate && this._instance) {
            this._update();
          }
          if (shouldReflect) {
            if (val === true) {
              this.setAttribute(hyphenate(key), "");
            } else if (typeof val === "string" || typeof val === "number") {
              this.setAttribute(hyphenate(key), val + "");
            } else if (!val) {
              this.removeAttribute(hyphenate(key));
            }
          }
        }
      }
      _update() {
        render$1m(this._createVNode(), this.shadowRoot);
      }
      _createVNode() {
        const vnode = createVNode(this._def, extend$3({}, this._props));
        if (!this._instance) {
          vnode.ce = (instance) => {
            this._instance = instance;
            instance.isCE = true;
            instance.emit = (event, ...args) => {
              this.dispatchEvent(new CustomEvent(event, {
                detail: args
              }));
            };
            let parent2 = this;
            while (parent2 = parent2 && (parent2.parentNode || parent2.host)) {
              if (parent2 instanceof VueElement) {
                instance.parent = parent2._instance;
                break;
              }
            }
          };
        }
        return vnode;
      }
      _applyStyles(styles) {
        if (styles) {
          styles.forEach((css2) => {
            const s = document.createElement("style");
            s.textContent = css2;
            this.shadowRoot.appendChild(s);
          });
        }
      }
    }
    function useCssModule(name = "$style") {
      {
        const instance = getCurrentInstance();
        if (!instance) {
          return EMPTY_OBJ$1;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
          return EMPTY_OBJ$1;
        }
        const mod = modules[name];
        if (!mod) {
          return EMPTY_OBJ$1;
        }
        return mod;
      }
    }
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        return;
      }
      const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
      watchPostEffect(setVars);
      onMounted(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c) => setVarsOnVNode(c, vars));
      } else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor)
            break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style2 = el.style;
        for (const key in vars) {
          style2.setProperty(`--${key}`, vars[key]);
        }
      }
    }
    const TRANSITION$1 = "transition";
    const ANIMATION = "animation";
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$3({}, BaseTransition.props, DOMTransitionPropsValidators);
    const callHook = (hook, args = []) => {
      if (isArray$7(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$7(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const { name = "v", type: type2, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame$1(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type2, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$3(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame$1(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type2, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$b(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$2(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const { _vtc } = el;
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el._vtc = void 0;
        }
      }
    }
    function nextFrame$1(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type2) {
        return resolve2();
      }
      const endEvent = type2 + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(TRANSITION$1 + "Delay");
      const transitionDurations = getStyleProperties(TRANSITION$1 + "Duration");
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(ANIMATION + "Delay");
      const animationDurations = getStyleProperties(ANIMATION + "Duration");
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type2 = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION$1) {
        if (transitionTimeout > 0) {
          type2 = TRANSITION$1;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type2 = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
        propCount = type2 ? type2 === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type2 === TRANSITION$1 && /\b(transform|all)(,|$)/.test(styles[TRANSITION$1 + "Property"]);
      return {
        type: type2,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
    }
    function toMs(s) {
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$3({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style2 = el.style;
            addTransitionClass(el, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb = el._moveCb = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.key != null) {
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
            }
          }
          if (prevChildren) {
            for (let i2 = 0; i2 < prevChildren.length; i2++) {
              const child = prevChildren[i2];
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el._moveCb) {
        el._moveCb();
      }
      if (el._enterCb) {
        el._enterCb();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone2 = el.cloneNode();
      if (el._vtc) {
        el._vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$7(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number2 || vnode.props && vnode.props.type === "number";
        addEventListener$1(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = toNumber$2(domValue);
          }
          el._assign(domValue);
        });
        if (trim2) {
          addEventListener$1(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener$1(el, "compositionstart", onCompositionStart);
          addEventListener$1(el, "compositionend", onCompositionEnd);
          addEventListener$1(el, "change", onCompositionEnd);
        }
      },
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing)
          return;
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim2 && el.value.trim() === value) {
            return;
          }
          if ((number2 || el.type === "number") && toNumber$2(el.value) === value) {
            return;
          }
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) {
          el.value = newValue;
        }
      }
    };
    const vModelCheckbox = {
      deep: true,
      created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener$1(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$2(el);
          const checked = el.checked;
          const assign2 = el._assign;
          if (isArray$7(modelValue)) {
            const index2 = looseIndexOf(modelValue, elementValue);
            const found = index2 !== -1;
            if (checked && !found) {
              assign2(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index2, 1);
              assign2(filtered);
            }
          } else if (isSet$3(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign2(cloned);
          } else {
            assign2(getCheckboxValue(el, checked));
          }
        });
      },
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray$7(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet$3(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
    }
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener$1(el, "change", () => {
          el._assign(getValue$2(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    const vModelSelect = {
      deep: true,
      created(el, { value, modifiers: { number: number2 } }, vnode) {
        const isSetModel = isSet$3(value);
        addEventListener$1(el, "change", () => {
          const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map((o) => number2 ? toNumber$2(getValue$2(o)) : getValue$2(o));
          el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
      },
      mounted(el, { value }) {
        setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
      },
      updated(el, { value }) {
        setSelected(el, value);
      }
    };
    function setSelected(el, value) {
      const isMultiple = el.multiple;
      if (isMultiple && !isArray$7(value) && !isSet$3(value)) {
        return;
      }
      for (let i2 = 0, l = el.options.length; i2 < l; i2++) {
        const option = el.options[i2];
        const optionValue = getValue$2(option);
        if (isMultiple) {
          if (isArray$7(value)) {
            option.selected = looseIndexOf(value, optionValue) > -1;
          } else {
            option.selected = value.has(optionValue);
          }
        } else {
          if (looseEqual(getValue$2(option), value)) {
            if (el.selectedIndex !== i2)
              el.selectedIndex = i2;
            return;
          }
        }
      }
      if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
      }
    }
    function getValue$2(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const vModelDynamic = {
      created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
      },
      mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
      },
      beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
      },
      updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
      }
    };
    function resolveDynamicModel(tagName, type2) {
      switch (tagName) {
        case "SELECT":
          return vModelSelect;
        case "TEXTAREA":
          return vModelText;
        default:
          switch (type2) {
            case "checkbox":
              return vModelCheckbox;
            case "radio":
              return vModelRadio;
            default:
              return vModelText;
          }
      }
    }
    function callModelHook(el, binding, vnode, prevVNode, hook) {
      const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
      const fn = modelToUse[hook];
      fn && fn(el, binding, vnode, prevVNode);
    }
    function initVModelForSSR() {
      vModelText.getSSRProps = ({ value }) => ({ value });
      vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && looseEqual(vnode.props.value, value)) {
          return { checked: true };
        }
      };
      vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if (isArray$7(value)) {
          if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
            return { checked: true };
          }
        } else if (isSet$3(value)) {
          if (vnode.props && value.has(vnode.props.value)) {
            return { checked: true };
          }
        } else if (value) {
          return { checked: true };
        }
      };
      vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== "string") {
          return;
        }
        const modelToUse = resolveDynamicModel(vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) {
          return modelToUse.getSSRProps(binding, vnode);
        }
      };
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      return (event, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      };
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn, modifiers) => {
      return (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      };
    };
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el._vod : "none";
    }
    function initVShowForSSR() {
      vShow.getSSRProps = ({ value }) => {
        if (!value) {
          return { style: { display: "none" } };
        }
      };
    }
    const rendererOptions = /* @__PURE__ */ extend$3({ patchProp }, nodeOps);
    let renderer;
    let enabledHydration = false;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    function ensureHydrationRenderer() {
      renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
      enabledHydration = true;
      return renderer;
    }
    const render$1m = (...args) => {
      ensureRenderer().render(...args);
    };
    const hydrate = (...args) => {
      ensureHydrationRenderer().hydrate(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app2._component;
        if (!isFunction$6(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    const createSSRApp = (...args) => {
      const app2 = ensureHydrationRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
          return mount(container, true, container instanceof SVGElement);
        }
      };
      return app2;
    };
    function normalizeContainer(container) {
      if (isString$3(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    let ssrDirectiveInitialized = false;
    const initDirectivesForSSR = () => {
      if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
      }
    };
    const compile = () => {
    };
    const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      compile,
      EffectScope,
      ReactiveEffect: ReactiveEffect$1,
      customRef,
      effect,
      effectScope,
      getCurrentScope,
      isProxy,
      isReactive: isReactive$1,
      isReadonly: isReadonly$1,
      isRef: isRef$1,
      isShallow: isShallow$1,
      markRaw: markRaw$1,
      onScopeDispose,
      proxyRefs: proxyRefs$1,
      reactive,
      readonly,
      ref,
      shallowReactive,
      shallowReadonly,
      shallowRef,
      stop,
      toRaw,
      toRef,
      toRefs,
      triggerRef,
      unref: unref$1,
      camelize,
      capitalize,
      normalizeClass,
      normalizeProps,
      normalizeStyle,
      toDisplayString,
      toHandlerKey,
      BaseTransition,
      Comment,
      Fragment,
      KeepAlive,
      Static,
      Suspense,
      Teleport,
      Text: Text$1,
      callWithAsyncErrorHandling: callWithAsyncErrorHandling$1,
      callWithErrorHandling: callWithErrorHandling$1,
      cloneVNode,
      compatUtils,
      computed,
      createBlock,
      createCommentVNode,
      createElementBlock,
      createElementVNode: createBaseVNode,
      createHydrationRenderer,
      createPropsRestProxy,
      createRenderer,
      createSlots,
      createStaticVNode,
      createTextVNode,
      createVNode,
      defineAsyncComponent,
      defineComponent,
      defineEmits,
      defineExpose,
      defineProps,
      get devtools() {
        return devtools;
      },
      getCurrentInstance,
      getTransitionRawChildren,
      guardReactiveProps,
      h,
      handleError: handleError$1,
      initCustomFormatter,
      inject,
      isMemoSame,
      isRuntimeOnly,
      isVNode,
      mergeDefaults,
      mergeProps,
      nextTick: nextTick$1,
      onActivated,
      onBeforeMount,
      onBeforeUnmount,
      onBeforeUpdate,
      onDeactivated,
      onErrorCaptured,
      onMounted,
      onRenderTracked,
      onRenderTriggered,
      onServerPrefetch,
      onUnmounted,
      onUpdated,
      openBlock,
      popScopeId,
      provide,
      pushScopeId,
      queuePostFlushCb: queuePostFlushCb$1,
      registerRuntimeCompiler,
      renderList,
      renderSlot,
      resolveComponent,
      resolveDirective,
      resolveDynamicComponent,
      resolveFilter,
      resolveTransitionHooks,
      setBlockTracking,
      setDevtoolsHook,
      setTransitionHooks,
      ssrContextKey,
      ssrUtils,
      toHandlers,
      transformVNodeArgs,
      useAttrs,
      useSSRContext,
      useSlots,
      useTransitionState,
      version: version$1,
      warn,
      watch,
      watchEffect,
      watchPostEffect,
      watchSyncEffect,
      withAsyncContext,
      withCtx,
      withDefaults,
      withDirectives,
      withMemo,
      withScopeId,
      Transition,
      TransitionGroup,
      VueElement,
      createApp,
      createSSRApp,
      defineCustomElement,
      defineSSRCustomElement,
      hydrate,
      initDirectivesForSSR,
      render: render$1m,
      useCssModule,
      useCssVars,
      vModelCheckbox,
      vModelDynamic,
      vModelRadio,
      vModelSelect,
      vModelText,
      vShow,
      withKeys,
      withModifiers
    }, Symbol.toStringTag, { value: "Module" }));
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].includes(getBasePlacement(placement)) ? "x" : "y";
    }
    function getLengthFromAxis(axis) {
      return axis === "y" ? "height" : "width";
    }
    function computeCoordsFromPlacement(_ref) {
      let {
        reference,
        floating,
        placement
      } = _ref;
      const commonX = reference.x + reference.width / 2 - floating.width / 2;
      const commonY = reference.y + reference.height / 2 - floating.height / 2;
      let coords;
      switch (getBasePlacement(placement)) {
        case "top":
          coords = {
            x: commonX,
            y: reference.y - floating.height
          };
          break;
        case "bottom":
          coords = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;
        case "right":
          coords = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;
        case "left":
          coords = {
            x: reference.x - floating.width,
            y: commonY
          };
          break;
        default:
          coords = {
            x: reference.x,
            y: reference.y
          };
      }
      const mainAxis = getMainAxisFromPlacement(placement);
      const length = getLengthFromAxis(mainAxis);
      switch (getAlignment(placement)) {
        case "start":
          coords[mainAxis] = coords[mainAxis] - (reference[length] / 2 - floating[length] / 2);
          break;
        case "end":
          coords[mainAxis] = coords[mainAxis] + (reference[length] / 2 - floating[length] / 2);
          break;
      }
      return coords;
    }
    const computePosition$1 = async (reference, floating, config2) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config2;
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x,
        y
      } = computeCoordsFromPlacement({
        ...rects,
        placement
      });
      let statefulPlacement = placement;
      let middlewareData = {};
      for (let i2 = 0; i2 < middleware.length; i2++) {
        const {
          name,
          fn
        } = middleware[i2];
        const {
          x: nextX,
          y: nextY,
          data: data2,
          reset: reset2
        } = await fn({
          x,
          y,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
          ...middlewareData,
          [name]: data2 != null ? data2 : {}
        };
        if (reset2) {
          if (typeof reset2 === "object") {
            if (reset2.placement) {
              statefulPlacement = reset2.placement;
            }
            if (reset2.rects) {
              rects = reset2.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset2.rects;
            }
            ({
              x,
              y
            } = computeCoordsFromPlacement({
              ...rects,
              placement: statefulPlacement
            }));
          }
          i2 = -1;
          continue;
        }
      }
      return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    function expandPaddingObject(padding) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
      };
    }
    function getSideObjectFromPadding(padding) {
      return typeof padding !== "number" ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
      };
    }
    function rectToClientRect(rect) {
      return {
        ...rect,
        top: rect.y,
        left: rect.x,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      };
    }
    async function detectOverflow(middlewareArguments, options) {
      if (options === void 0) {
        options = {};
      }
      const {
        x,
        y,
        platform: platform2,
        rects,
        elements,
        strategy
      } = middlewareArguments;
      const {
        boundary = "clippingParents",
        rootBoundary = "viewport",
        elementContext = "floating",
        altBoundary = false,
        padding = 0
      } = options;
      const paddingObject = getSideObjectFromPadding(padding);
      const altContext = elementContext === "floating" ? "reference" : "floating";
      const element = elements[altBoundary ? altContext : elementContext];
      const clippingClientRect = await platform2.getClippingClientRect({
        element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
          element: elements.floating
        }),
        boundary,
        rootBoundary
      });
      const elementClientRect = rectToClientRect(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: elementContext === "floating" ? {
          ...rects.floating,
          x,
          y
        } : rects.reference,
        offsetParent: await platform2.getOffsetParent({
          element: elements.floating
        }),
        strategy
      }));
      return {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
    }
    const min$1 = Math.min;
    const max$1 = Math.max;
    function within(min$1$1, value, max$1$1) {
      return max$1(min$1$1, min$1(value, max$1$1));
    }
    const arrow = (options) => ({
      name: "arrow",
      options,
      async fn(middlewareArguments) {
        const {
          element,
          padding = 0
        } = options != null ? options : {};
        const {
          x,
          y,
          placement,
          rects,
          platform: platform2
        } = middlewareArguments;
        if (element == null) {
          return {};
        }
        const paddingObject = getSideObjectFromPadding(padding);
        const coords = {
          x,
          y
        };
        const basePlacement = getBasePlacement(placement);
        const axis = getMainAxisFromPlacement(basePlacement);
        const length = getLengthFromAxis(axis);
        const arrowDimensions = await platform2.getDimensions({
          element
        });
        const minProp = axis === "y" ? "top" : "left";
        const maxProp = axis === "y" ? "bottom" : "right";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await platform2.getOffsetParent({
          element
        });
        const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
        const centerToReference = endDiff / 2 - startDiff / 2;
        const min2 = paddingObject[minProp];
        const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = within(min2, center, max2);
        return {
          data: {
            [axis]: offset2,
            centerOffset: center - offset2
          }
        };
      }
    });
    const hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
    }
    function getAlignmentSides(placement, rects) {
      const isStart = getAlignment(placement) === "start";
      const mainAxis = getMainAxisFromPlacement(placement);
      const length = getLengthFromAxis(mainAxis);
      let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
      if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
      }
      return {
        main: mainAlignmentSide,
        cross: getOppositePlacement(mainAlignmentSide)
      };
    }
    const hash = {
      start: "end",
      end: "start"
    };
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, (matched) => hash[matched]);
    }
    const basePlacements = ["top", "right", "bottom", "left"];
    const allPlacements = /* @__PURE__ */ basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
    function getPlacementList(alignment, autoAlignment, allowedPlacements) {
      const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement(placement) === placement);
      return allowedPlacementsSortedByAlignment.filter((placement) => {
        if (alignment) {
          return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
        }
        return true;
      });
    }
    const autoPlacement = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "autoPlacement",
        options,
        async fn(middlewareArguments) {
          var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
          const {
            x,
            y,
            rects,
            middlewareData,
            placement
          } = middlewareArguments;
          const {
            alignment = null,
            allowedPlacements = allPlacements,
            autoAlignment = true,
            ...detectOverflowOptions
          } = options;
          if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
            return {};
          }
          const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
          const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
          const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
          const currentPlacement = placements2[currentIndex];
          const {
            main,
            cross
          } = getAlignmentSides(currentPlacement, rects);
          if (placement !== currentPlacement) {
            return {
              x,
              y,
              reset: {
                placement: placements2[0]
              }
            };
          }
          const currentOverflows = [overflow[getBasePlacement(currentPlacement)], overflow[main], overflow[cross]];
          const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
            placement: currentPlacement,
            overflows: currentOverflows
          }];
          const nextPlacement = placements2[currentIndex + 1];
          if (nextPlacement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
          const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
            let {
              overflows
            } = _ref;
            return overflows.every((overflow2) => overflow2 <= 0);
          })) == null ? void 0 : _placementsSortedByLe.placement;
          return {
            data: {
              skip: true
            },
            reset: {
              placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
            }
          };
        }
      };
    };
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement(placement);
      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
    }
    const flip = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(middlewareArguments) {
          var _middlewareData$flip, _middlewareData$flip2;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement
          } = middlewareArguments;
          if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
            return {};
          }
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            flipAlignment = true,
            ...detectOverflowOptions
          } = options;
          const basePlacement = getBasePlacement(placement);
          const isBasePlacement = basePlacement === initialPlacement;
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[basePlacement]);
          }
          if (checkCrossAxis) {
            const {
              main,
              cross
            } = getAlignmentSides(placement, rects);
            overflows.push(overflow[main], overflow[cross]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side) => side <= 0)) {
            var _middlewareData$flip$, _middlewareData$flip3;
            const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = "bottom";
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$slice$;
                const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
            return {
              data: {
                skip: true
              },
              reset: {
                placement: resetPlacement
              }
            };
          }
          return {};
        }
      };
    };
    function convertValueToCoords(_ref) {
      let {
        placement,
        rects,
        value
      } = _ref;
      const basePlacement = getBasePlacement(placement);
      const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
      const rawValue = typeof value === "function" ? value({
        ...rects,
        placement
      }) : value;
      const {
        mainAxis,
        crossAxis
      } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawValue
      };
      return getMainAxisFromPlacement(basePlacement) === "x" ? {
        x: crossAxis,
        y: mainAxis * multiplier
      } : {
        x: mainAxis * multiplier,
        y: crossAxis
      };
    }
    const offset = function(value) {
      if (value === void 0) {
        value = 0;
      }
      return {
        name: "offset",
        options: value,
        fn(middlewareArguments) {
          const {
            x,
            y,
            placement,
            rects
          } = middlewareArguments;
          const diffCoords = convertValueToCoords({
            placement,
            rects,
            value
          });
          return {
            x: x + diffCoords.x,
            y: y + diffCoords.y,
            data: diffCoords
          };
        }
      };
    };
    function getCrossAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    const shift = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(middlewareArguments) {
          const {
            x,
            y,
            placement
          } = middlewareArguments;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x2,
                  y: y2
                } = _ref;
                return {
                  x: x2,
                  y: y2
                };
              }
            },
            ...detectOverflowOptions
          } = options;
          const coords = {
            x,
            y
          };
          const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
          const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));
          const crossAxis = getCrossAxis(mainAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = within(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = within(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...middlewareArguments,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x,
              y: limitedCoords.y - y
            }
          };
        }
      };
    };
    const size = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(middlewareArguments) {
          var _middlewareData$size;
          const {
            placement,
            rects,
            middlewareData
          } = middlewareArguments;
          const {
            apply: apply2,
            ...detectOverflowOptions
          } = options;
          if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
            return {};
          }
          const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
          const basePlacement = getBasePlacement(placement);
          const isEnd = getAlignment(placement) === "end";
          let heightSide;
          let widthSide;
          if (basePlacement === "top" || basePlacement === "bottom") {
            heightSide = basePlacement;
            widthSide = isEnd ? "left" : "right";
          } else {
            widthSide = basePlacement;
            heightSide = isEnd ? "top" : "bottom";
          }
          const xMin = max$1(overflow.left, 0);
          const xMax = max$1(overflow.right, 0);
          const yMin = max$1(overflow.top, 0);
          const yMax = max$1(overflow.bottom, 0);
          const dimensions = {
            height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom)) : overflow[heightSide]),
            width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : overflow[widthSide])
          };
          apply2 == null ? void 0 : apply2({
            ...dimensions,
            ...rects
          });
          return {
            data: {
              skip: true
            },
            reset: {
              rects: true
            }
          };
        }
      };
    };
    function isWindow(value) {
      return (value == null ? void 0 : value.toString()) === "[object Window]";
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (!isWindow(node)) {
        const ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function getNodeName(node) {
      return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
    }
    function isHTMLElement(value) {
      return value instanceof getWindow(value).HTMLElement;
    }
    function isElement(value) {
      return value instanceof getWindow(value).Element;
    }
    function isNode$1(value) {
      return value instanceof getWindow(value).Node;
    }
    function isShadowRoot(node) {
      const OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function isScrollParent(element) {
      const {
        overflow,
        overflowX,
        overflowY
      } = getComputedStyle$1(element);
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].includes(getNodeName(element));
    }
    function isContainingBlock(element) {
      const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
      const css2 = getComputedStyle$1(element);
      return css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].includes(css2.willChange) || isFirefox && css2.willChange === "filter" || isFirefox && (css2.filter ? css2.filter !== "none" : false);
    }
    const min = Math.min;
    const max = Math.max;
    const round = Math.round;
    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      const clientRect = element.getBoundingClientRect();
      let scaleX = 1;
      let scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      return {
        width: clientRect.width / scaleX,
        height: clientRect.height / scaleY,
        top: clientRect.top / scaleY,
        right: clientRect.right / scaleX,
        bottom: clientRect.bottom / scaleY,
        left: clientRect.left / scaleX,
        x: clientRect.left / scaleX,
        y: clientRect.top / scaleY
      };
    }
    function getDocumentElement(node) {
      return ((isNode$1(node) ? node.ownerDocument : node.document) || window.document).documentElement;
    }
    function getNodeScroll(element) {
      if (isWindow(element)) {
        return {
          scrollLeft: element.pageXOffset,
          scrollTop: element.pageYOffset
        };
      }
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
    }
    function isScaled(element) {
      const rect = getBoundingClientRect(element);
      return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
    }
    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          const offsetRect = getBoundingClientRect(offsetParent, true);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function getParentNode(node) {
      if (getNodeName(node) === "html") {
        return node;
      }
      return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      let currentNode = getParentNode(element);
      while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
        if (isContainingBlock(currentNode)) {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      const window2 = getWindow(element);
      let offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getDimensions(element) {
      return {
        width: element.offsetWidth,
        height: element.offsetHeight
      };
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
      let {
        rect,
        offsetParent,
        strategy
      } = _ref;
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      if (offsetParent === documentElement) {
        return rect;
      }
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          const offsetRect = getBoundingClientRect(offsetParent, true);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        }
      }
      return {
        ...rect,
        x: rect.x - scroll.scrollLeft + offsets.x,
        y: rect.y - scroll.scrollTop + offsets.y
      };
    }
    function getViewportRect(element) {
      const win = getWindow(element);
      const html = getDocumentElement(element);
      const visualViewport = win.visualViewport;
      let width = html.clientWidth;
      let height = html.clientHeight;
      let x = 0;
      let y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x,
        y
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      const html = getDocumentElement(element);
      const scroll = getNodeScroll(element);
      const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      let x = -scroll.scrollLeft + getWindowScrollBarX(element);
      const y = -scroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === "rtl") {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x,
        y
      };
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].includes(getNodeName(node))) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function getScrollParents(node, list) {
      var _node$ownerDocument;
      if (list === void 0) {
        list = [];
      }
      const scrollParent = getScrollParent(node);
      const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
      const win = getWindow(scrollParent);
      const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      const updatedList = list.concat(target);
      return isBody ? updatedList : updatedList.concat(getScrollParents(getParentNode(target)));
    }
    function contains(parent2, child) {
      const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
      if (parent2.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        let next = child;
        do {
          if (next && parent2 === next) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getInnerBoundingClientRect(element) {
      const clientRect = getBoundingClientRect(element);
      const top = clientRect.top + element.clientTop;
      const left = clientRect.left + element.clientLeft;
      return {
        top,
        left,
        x: left,
        y: top,
        right: left + element.clientWidth,
        bottom: top + element.clientHeight,
        width: element.clientWidth,
        height: element.clientHeight
      };
    }
    function getClientRectFromClippingParent(element, clippingParent) {
      if (clippingParent === "viewport") {
        return rectToClientRect(getViewportRect(element));
      }
      if (isElement(clippingParent)) {
        return getInnerBoundingClientRect(clippingParent);
      }
      return rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      const clippingParents = getScrollParents(getParentNode(element));
      const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
      const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
    }
    function getClippingClientRect(_ref) {
      let {
        element,
        boundary,
        rootBoundary
      } = _ref;
      const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      const clippingParents = [...mainClippingParents, rootBoundary];
      const firstClippingParent = clippingParents[0];
      const clippingRect = clippingParents.reduce((accRect, clippingParent) => {
        const rect = getClientRectFromClippingParent(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromClippingParent(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    const platform = {
      getElementRects: (_ref) => {
        let {
          reference,
          floating,
          strategy
        } = _ref;
        return {
          reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
          floating: {
            ...getDimensions(floating),
            x: 0,
            y: 0
          }
        };
      },
      convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
      getOffsetParent: (_ref2) => {
        let {
          element
        } = _ref2;
        return getOffsetParent(element);
      },
      isElement: (value) => isElement(value),
      getDocumentElement: (_ref3) => {
        let {
          element
        } = _ref3;
        return getDocumentElement(element);
      },
      getClippingClientRect: (args) => getClippingClientRect(args),
      getDimensions: (_ref4) => {
        let {
          element
        } = _ref4;
        return getDimensions(element);
      },
      getClientRects: (_ref5) => {
        let {
          element
        } = _ref5;
        return element.getClientRects();
      }
    };
    const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
      platform,
      ...options
    });
    var __defProp$1 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
    var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
    var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$1 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp$1.call(b, prop))
          __defNormalProp$1(a, prop, b[prop]);
      if (__getOwnPropSymbols$1)
        for (var prop of __getOwnPropSymbols$1(b)) {
          if (__propIsEnum$1.call(b, prop))
            __defNormalProp$1(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    const config$1 = {
      disabled: false,
      distance: 5,
      skidding: 0,
      container: "body",
      boundary: void 0,
      instantMove: false,
      disposeTimeout: 5e3,
      popperTriggers: [],
      strategy: "absolute",
      preventOverflow: true,
      flip: true,
      shift: true,
      overflowPadding: 0,
      arrowPadding: 0,
      arrowOverflow: true,
      themes: {
        tooltip: {
          placement: "top",
          triggers: ["hover", "focus", "touch"],
          hideTriggers: (events) => [...events, "click"],
          delay: {
            show: 200,
            hide: 0
          },
          handleResize: false,
          html: false,
          loadingContent: "..."
        },
        dropdown: {
          placement: "bottom",
          triggers: ["click"],
          delay: 0,
          handleResize: true,
          autoHide: true
        },
        menu: {
          $extend: "dropdown",
          triggers: ["hover", "focus"],
          popperTriggers: ["hover", "focus"],
          delay: {
            show: 0,
            hide: 400
          }
        }
      }
    };
    function getDefaultConfig(theme, key) {
      let themeConfig = config$1.themes[theme] || {};
      let value;
      do {
        value = themeConfig[key];
        if (typeof value === "undefined") {
          if (themeConfig.$extend) {
            themeConfig = config$1.themes[themeConfig.$extend] || {};
          } else {
            themeConfig = null;
            value = config$1[key];
          }
        } else {
          themeConfig = null;
        }
      } while (themeConfig);
      return value;
    }
    function getThemeClasses(theme) {
      const result = [theme];
      let themeConfig = config$1.themes[theme] || {};
      do {
        if (themeConfig.$extend && !themeConfig.$resetCss) {
          result.push(themeConfig.$extend);
          themeConfig = config$1.themes[themeConfig.$extend] || {};
        } else {
          themeConfig = null;
        }
      } while (themeConfig);
      return result.map((c) => `v-popper--theme-${c}`);
    }
    function getAllParentThemes(theme) {
      const result = [theme];
      let themeConfig = config$1.themes[theme] || {};
      do {
        if (themeConfig.$extend) {
          result.push(themeConfig.$extend);
          themeConfig = config$1.themes[themeConfig.$extend] || {};
        } else {
          themeConfig = null;
        }
      } while (themeConfig);
      return result;
    }
    let supportsPassive = false;
    if (typeof window !== "undefined") {
      supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window.addEventListener("test", null, opts);
      } catch (e) {
      }
    }
    let isIOS = false;
    if (typeof window !== "undefined" && typeof navigator !== "undefined") {
      isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }
    const placements = ["auto", "top", "bottom", "left", "right"].reduce((acc, base) => acc.concat([
      base,
      `${base}-start`,
      `${base}-end`
    ]), []);
    const SHOW_EVENT_MAP = {
      hover: "mouseenter",
      focus: "focus",
      click: "click",
      touch: "touchstart"
    };
    const HIDE_EVENT_MAP = {
      hover: "mouseleave",
      focus: "blur",
      click: "click",
      touch: "touchend"
    };
    function removeFromArray(array2, item) {
      const index2 = array2.indexOf(item);
      if (index2 !== -1) {
        array2.splice(index2, 1);
      }
    }
    function nextFrame() {
      return new Promise((resolve2) => requestAnimationFrame(() => {
        requestAnimationFrame(resolve2);
      }));
    }
    const shownPoppers = [];
    let hidingPopper = null;
    const shownPoppersByTheme = {};
    function getShownPoppersByTheme(theme) {
      let list = shownPoppersByTheme[theme];
      if (!list) {
        list = shownPoppersByTheme[theme] = [];
      }
      return list;
    }
    let Element$2 = function() {
    };
    if (typeof window !== "undefined") {
      Element$2 = window.Element;
    }
    function defaultPropFactory(prop) {
      return function(props) {
        return getDefaultConfig(props.theme, prop);
      };
    }
    const PROVIDE_KEY = "__floating-vue__popper";
    var PrivatePopper = () => defineComponent({
      name: "VPopper",
      provide() {
        return {
          [PROVIDE_KEY]: {
            parentPopper: this
          }
        };
      },
      inject: {
        [PROVIDE_KEY]: { default: null }
      },
      props: {
        theme: {
          type: String,
          required: true
        },
        targetNodes: {
          type: Function,
          required: true
        },
        referenceNode: {
          type: Function,
          required: true
        },
        popperNode: {
          type: Function,
          required: true
        },
        shown: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: String,
          default: null
        },
        ariaId: {
          default: null
        },
        disabled: {
          type: Boolean,
          default: defaultPropFactory("disabled")
        },
        positioningDisabled: {
          type: Boolean,
          default: defaultPropFactory("positioningDisabled")
        },
        placement: {
          type: String,
          default: defaultPropFactory("placement"),
          validator: (value) => placements.includes(value)
        },
        delay: {
          type: [String, Number, Object],
          default: defaultPropFactory("delay")
        },
        distance: {
          type: [Number, String],
          default: defaultPropFactory("distance")
        },
        skidding: {
          type: [Number, String],
          default: defaultPropFactory("skidding")
        },
        triggers: {
          type: Array,
          default: defaultPropFactory("triggers")
        },
        showTriggers: {
          type: [Array, Function],
          default: defaultPropFactory("showTriggers")
        },
        hideTriggers: {
          type: [Array, Function],
          default: defaultPropFactory("hideTriggers")
        },
        popperTriggers: {
          type: Array,
          default: defaultPropFactory("popperTriggers")
        },
        popperShowTriggers: {
          type: [Array, Function],
          default: defaultPropFactory("popperShowTriggers")
        },
        popperHideTriggers: {
          type: [Array, Function],
          default: defaultPropFactory("popperHideTriggers")
        },
        container: {
          type: [String, Object, Element$2, Boolean],
          default: defaultPropFactory("container")
        },
        boundary: {
          type: [String, Element$2],
          default: defaultPropFactory("boundary")
        },
        strategy: {
          type: String,
          validator: (value) => ["absolute", "fixed"].includes(value),
          default: defaultPropFactory("strategy")
        },
        autoHide: {
          type: [Boolean, Function],
          default: defaultPropFactory("autoHide")
        },
        handleResize: {
          type: Boolean,
          default: defaultPropFactory("handleResize")
        },
        instantMove: {
          type: Boolean,
          default: defaultPropFactory("instantMove")
        },
        eagerMount: {
          type: Boolean,
          default: defaultPropFactory("eagerMount")
        },
        popperClass: {
          type: [String, Array, Object],
          default: defaultPropFactory("popperClass")
        },
        computeTransformOrigin: {
          type: Boolean,
          default: defaultPropFactory("computeTransformOrigin")
        },
        autoMinSize: {
          type: Boolean,
          default: defaultPropFactory("autoMinSize")
        },
        autoSize: {
          type: [Boolean, String],
          default: defaultPropFactory("autoSize")
        },
        autoMaxSize: {
          type: Boolean,
          default: defaultPropFactory("autoMaxSize")
        },
        autoBoundaryMaxSize: {
          type: Boolean,
          default: defaultPropFactory("autoBoundaryMaxSize")
        },
        preventOverflow: {
          type: Boolean,
          default: defaultPropFactory("preventOverflow")
        },
        overflowPadding: {
          type: [Number, String],
          default: defaultPropFactory("overflowPadding")
        },
        arrowPadding: {
          type: [Number, String],
          default: defaultPropFactory("arrowPadding")
        },
        arrowOverflow: {
          type: Boolean,
          default: defaultPropFactory("arrowOverflow")
        },
        flip: {
          type: Boolean,
          default: defaultPropFactory("flip")
        },
        shift: {
          type: Boolean,
          default: defaultPropFactory("shift")
        },
        shiftCrossAxis: {
          type: Boolean,
          default: defaultPropFactory("shiftCrossAxis")
        }
      },
      emits: [
        "show",
        "hide",
        "update:shown",
        "apply-show",
        "apply-hide",
        "close-group",
        "close-directive",
        "auto-hide",
        "resize",
        "dispose"
      ],
      data() {
        return {
          isShown: false,
          isMounted: false,
          skipTransition: false,
          classes: {
            showFrom: false,
            showTo: false,
            hideFrom: false,
            hideTo: true
          },
          result: {
            x: 0,
            y: 0,
            placement: "",
            strategy: this.strategy,
            arrow: {
              x: 0,
              y: 0,
              centerOffset: 0
            },
            transformOrigin: null
          },
          shownChildren: /* @__PURE__ */ new Set(),
          lastAutoHide: true
        };
      },
      computed: {
        popperId() {
          return this.ariaId != null ? this.ariaId : this.randomId;
        },
        shouldMountContent() {
          return this.eagerMount || this.isMounted;
        },
        slotData() {
          return {
            popperId: this.popperId,
            isShown: this.isShown,
            shouldMountContent: this.shouldMountContent,
            skipTransition: this.skipTransition,
            autoHide: typeof this.autoHide === "function" ? this.lastAutoHide : this.autoHide,
            show: this.show,
            hide: this.hide,
            handleResize: this.handleResize,
            onResize: this.onResize,
            classes: __spreadProps(__spreadValues$1({}, this.classes), {
              popperClass: this.popperClass
            }),
            result: this.positioningDisabled ? null : this.result,
            attrs: this.$attrs
          };
        },
        parentPopper() {
          var _a;
          return (_a = this[PROVIDE_KEY]) == null ? void 0 : _a.parentPopper;
        },
        hasPopperShowTriggerHover() {
          var _a, _b;
          return ((_a = this.popperTriggers) == null ? void 0 : _a.includes("hover")) || ((_b = this.popperShowTriggers) == null ? void 0 : _b.includes("hover"));
        }
      },
      watch: __spreadValues$1(__spreadValues$1({
        shown: "$_autoShowHide",
        disabled(value) {
          if (value) {
            this.dispose();
          } else {
            this.init();
          }
        },
        async container() {
          if (this.isShown) {
            this.$_ensureTeleport();
            await this.$_computePosition();
          }
        }
      }, [
        "triggers",
        "positioningDisabled"
      ].reduce((acc, prop) => {
        acc[prop] = "$_refreshListeners";
        return acc;
      }, {})), [
        "placement",
        "distance",
        "skidding",
        "boundary",
        "strategy",
        "overflowPadding",
        "arrowPadding",
        "preventOverflow",
        "shift",
        "shiftCrossAxis",
        "flip"
      ].reduce((acc, prop) => {
        acc[prop] = "$_computePosition";
        return acc;
      }, {})),
      created() {
        this.$_isDisposed = true;
        this.randomId = `popper_${[Math.random(), Date.now()].map((n) => n.toString(36).substring(2, 10)).join("_")}`;
        if (this.autoMinSize) {
          console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.');
        }
        if (this.autoMaxSize) {
          console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
        }
      },
      mounted() {
        this.init();
        this.$_detachPopperNode();
      },
      activated() {
        this.$_autoShowHide();
      },
      deactivated() {
        this.hide();
      },
      beforeUnmount() {
        this.dispose();
      },
      methods: {
        show({ event = null, skipDelay = false, force = false } = {}) {
          var _a, _b;
          if (((_a = this.parentPopper) == null ? void 0 : _a.lockedChild) && this.parentPopper.lockedChild !== this)
            return;
          this.$_pendingHide = false;
          if (force || !this.disabled) {
            if (((_b = this.parentPopper) == null ? void 0 : _b.lockedChild) === this) {
              this.parentPopper.lockedChild = null;
            }
            this.$_scheduleShow(event, skipDelay);
            this.$emit("show");
            this.$_showFrameLocked = true;
            requestAnimationFrame(() => {
              this.$_showFrameLocked = false;
            });
          }
          this.$emit("update:shown", true);
        },
        hide({ event = null, skipDelay = false } = {}) {
          var _a;
          if (this.$_hideInProgress)
            return;
          if (this.shownChildren.size > 0) {
            this.$_pendingHide = true;
            return;
          }
          if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
            if (this.parentPopper) {
              this.parentPopper.lockedChild = this;
              clearTimeout(this.parentPopper.lockedChildTimer);
              this.parentPopper.lockedChildTimer = setTimeout(() => {
                if (this.parentPopper.lockedChild === this) {
                  this.parentPopper.lockedChild.hide({ skipDelay });
                  this.parentPopper.lockedChild = null;
                }
              }, 1e3);
            }
            return;
          }
          if (((_a = this.parentPopper) == null ? void 0 : _a.lockedChild) === this) {
            this.parentPopper.lockedChild = null;
          }
          this.$_pendingHide = false;
          this.$_scheduleHide(event, skipDelay);
          this.$emit("hide");
          this.$emit("update:shown", false);
        },
        init() {
          if (!this.$_isDisposed)
            return;
          this.$_isDisposed = false;
          this.isMounted = false;
          this.$_events = [];
          this.$_preventShow = false;
          this.$_referenceNode = this.referenceNode();
          this.$_targetNodes = this.targetNodes().filter((e) => e.nodeType === e.ELEMENT_NODE);
          this.$_popperNode = this.popperNode();
          this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
          this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
          this.$_swapTargetAttrs("title", "data-original-title");
          this.$_detachPopperNode();
          if (this.triggers.length) {
            this.$_addEventListeners();
          }
          if (this.shown) {
            this.show();
          }
        },
        dispose() {
          if (this.$_isDisposed)
            return;
          this.$_isDisposed = true;
          this.$_removeEventListeners();
          this.hide({ skipDelay: true });
          this.$_detachPopperNode();
          this.isMounted = false;
          this.isShown = false;
          this.$_updateParentShownChildren(false);
          this.$_swapTargetAttrs("data-original-title", "title");
          this.$emit("dispose");
        },
        async onResize() {
          if (this.isShown) {
            await this.$_computePosition();
            this.$emit("resize");
          }
        },
        async $_computePosition() {
          var _a;
          if (this.$_isDisposed || this.positioningDisabled)
            return;
          const options2 = {
            strategy: this.strategy,
            middleware: []
          };
          if (this.distance || this.skidding) {
            options2.middleware.push(offset({
              mainAxis: this.distance,
              crossAxis: this.skidding
            }));
          }
          const isPlacementAuto = this.placement.startsWith("auto");
          if (isPlacementAuto) {
            options2.middleware.push(autoPlacement({
              alignment: (_a = this.placement.split("-")[1]) != null ? _a : ""
            }));
          } else {
            options2.placement = this.placement;
          }
          if (this.preventOverflow) {
            if (this.shift) {
              options2.middleware.push(shift({
                padding: this.overflowPadding,
                boundary: this.boundary,
                crossAxis: this.shiftCrossAxis
              }));
            }
            if (!isPlacementAuto && this.flip) {
              options2.middleware.push(flip({
                padding: this.overflowPadding,
                boundary: this.boundary
              }));
            }
          }
          options2.middleware.push(arrow({
            element: this.$_arrowNode,
            padding: this.arrowPadding
          }));
          if (this.arrowOverflow) {
            options2.middleware.push({
              name: "arrowOverflow",
              fn: ({ placement, rects, middlewareData }) => {
                let overflow;
                const { centerOffset } = middlewareData.arrow;
                if (placement.startsWith("top") || placement.startsWith("bottom")) {
                  overflow = Math.abs(centerOffset) > rects.reference.width / 2;
                } else {
                  overflow = Math.abs(centerOffset) > rects.reference.height / 2;
                }
                return {
                  data: {
                    overflow
                  }
                };
              }
            });
          }
          if (this.autoMinSize || this.autoSize) {
            const autoSize = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
            options2.middleware.push({
              name: "autoSize",
              fn: ({ rects, placement, middlewareData }) => {
                var _a2;
                if ((_a2 = middlewareData.autoSize) == null ? void 0 : _a2.skip) {
                  return {};
                }
                let width;
                let height;
                if (placement.startsWith("top") || placement.startsWith("bottom")) {
                  width = rects.reference.width;
                } else {
                  height = rects.reference.height;
                }
                this.$_innerNode.style[autoSize === "min" ? "minWidth" : autoSize === "max" ? "maxWidth" : "width"] = width != null ? `${width}px` : null;
                this.$_innerNode.style[autoSize === "min" ? "minHeight" : autoSize === "max" ? "maxHeight" : "height"] = height != null ? `${height}px` : null;
                return {
                  data: {
                    skip: true
                  },
                  reset: {
                    rects: true
                  }
                };
              }
            });
          }
          if (this.autoMaxSize || this.autoBoundaryMaxSize) {
            this.$_innerNode.style.maxWidth = null;
            this.$_innerNode.style.maxHeight = null;
            options2.middleware.push(size({
              boundary: this.boundary,
              padding: this.overflowPadding,
              apply: ({ width, height }) => {
                this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
                this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
              }
            }));
          }
          const data2 = await computePosition(this.$_referenceNode, this.$_popperNode, options2);
          Object.assign(this.result, {
            x: data2.x,
            y: data2.y,
            placement: data2.placement,
            strategy: data2.strategy,
            arrow: __spreadValues$1(__spreadValues$1({}, data2.middlewareData.arrow), data2.middlewareData.arrowOverflow)
          });
        },
        $_scheduleShow(event = null, skipDelay = false) {
          this.$_updateParentShownChildren(true);
          this.$_hideInProgress = false;
          clearTimeout(this.$_scheduleTimer);
          if (hidingPopper && this.instantMove && hidingPopper.instantMove && hidingPopper !== this.parentPopper) {
            hidingPopper.$_applyHide(true);
            this.$_applyShow(true);
            return;
          }
          if (skipDelay) {
            this.$_applyShow();
          } else {
            this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
          }
        },
        $_scheduleHide(event = null, skipDelay = false) {
          if (this.shownChildren.size > 0) {
            this.$_pendingHide = true;
            return;
          }
          this.$_updateParentShownChildren(false);
          this.$_hideInProgress = true;
          clearTimeout(this.$_scheduleTimer);
          if (this.isShown) {
            hidingPopper = this;
          }
          if (skipDelay) {
            this.$_applyHide();
          } else {
            this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
          }
        },
        $_computeDelay(type2) {
          const delay = this.delay;
          return parseInt(delay && delay[type2] || delay || 0);
        },
        async $_applyShow(skipTransition = false) {
          clearTimeout(this.$_disposeTimer);
          clearTimeout(this.$_scheduleTimer);
          this.skipTransition = skipTransition;
          if (this.isShown) {
            return;
          }
          this.$_ensureTeleport();
          await nextFrame();
          await this.$_computePosition();
          await this.$_applyShowEffect();
          if (!this.positioningDisabled) {
            this.$_registerEventListeners([
              ...getScrollParents(this.$_referenceNode),
              ...getScrollParents(this.$_popperNode)
            ], "scroll", () => {
              this.$_computePosition();
            });
          }
        },
        async $_applyShowEffect() {
          if (this.$_hideInProgress)
            return;
          if (this.computeTransformOrigin) {
            const bounds = this.$_referenceNode.getBoundingClientRect();
            const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
            const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
            const x = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
            const y = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
            this.result.transformOrigin = `${x}px ${y}px`;
          }
          this.isShown = true;
          this.$_applyAttrsToTarget({
            "aria-describedby": this.popperId,
            "data-popper-shown": ""
          });
          const showGroup = this.showGroup;
          if (showGroup) {
            let popover;
            for (let i2 = 0; i2 < shownPoppers.length; i2++) {
              popover = shownPoppers[i2];
              if (popover.showGroup !== showGroup) {
                popover.hide();
                popover.$emit("close-group");
              }
            }
          }
          shownPoppers.push(this);
          document.body.classList.add("v-popper--some-open");
          for (const theme of getAllParentThemes(this.theme)) {
            getShownPoppersByTheme(theme).push(this);
            document.body.classList.add(`v-popper--some-open--${theme}`);
          }
          this.$emit("apply-show");
          this.classes.showFrom = true;
          this.classes.showTo = false;
          this.classes.hideFrom = false;
          this.classes.hideTo = false;
          await nextFrame();
          this.classes.showFrom = false;
          this.classes.showTo = true;
          this.$_popperNode.focus();
        },
        async $_applyHide(skipTransition = false) {
          if (this.shownChildren.size > 0) {
            this.$_pendingHide = true;
            this.$_hideInProgress = false;
            return;
          }
          clearTimeout(this.$_scheduleTimer);
          if (!this.isShown) {
            return;
          }
          this.skipTransition = skipTransition;
          removeFromArray(shownPoppers, this);
          if (shownPoppers.length === 0) {
            document.body.classList.remove("v-popper--some-open");
          }
          for (const theme of getAllParentThemes(this.theme)) {
            const list = getShownPoppersByTheme(theme);
            removeFromArray(list, this);
            if (list.length === 0) {
              document.body.classList.remove(`v-popper--some-open--${theme}`);
            }
          }
          if (hidingPopper === this) {
            hidingPopper = null;
          }
          this.isShown = false;
          this.$_applyAttrsToTarget({
            "aria-describedby": void 0,
            "data-popper-shown": void 0
          });
          clearTimeout(this.$_disposeTimer);
          const disposeTime = getDefaultConfig(this.theme, "disposeTimeout");
          if (disposeTime !== null) {
            this.$_disposeTimer = setTimeout(() => {
              if (this.$_popperNode) {
                this.$_detachPopperNode();
                this.isMounted = false;
              }
            }, disposeTime);
          }
          this.$_removeEventListeners("scroll");
          this.$emit("apply-hide");
          this.classes.showFrom = false;
          this.classes.showTo = false;
          this.classes.hideFrom = true;
          this.classes.hideTo = false;
          await nextFrame();
          this.classes.hideFrom = false;
          this.classes.hideTo = true;
        },
        $_autoShowHide() {
          if (this.shown) {
            this.show();
          } else {
            this.hide();
          }
        },
        $_ensureTeleport() {
          if (this.$_isDisposed)
            return;
          let container = this.container;
          if (typeof container === "string") {
            container = window.document.querySelector(container);
          } else if (container === false) {
            container = this.$_targetNodes[0].parentNode;
          }
          if (!container) {
            throw new Error("No container for popover: " + this.container);
          }
          container.appendChild(this.$_popperNode);
          this.isMounted = true;
        },
        $_addEventListeners() {
          const handleShow = (event) => {
            if (this.isShown && !this.$_hideInProgress) {
              return;
            }
            event.usedByTooltip = true;
            !this.$_preventShow && this.show({ event });
          };
          this.$_registerTriggerListeners(this.$_targetNodes, SHOW_EVENT_MAP, this.triggers, this.showTriggers, handleShow);
          this.$_registerTriggerListeners([this.$_popperNode], SHOW_EVENT_MAP, this.popperTriggers, this.popperShowTriggers, handleShow);
          const handleHide = (event) => {
            if (event.usedByTooltip) {
              return;
            }
            this.hide({ event });
          };
          this.$_registerTriggerListeners(this.$_targetNodes, HIDE_EVENT_MAP, this.triggers, this.hideTriggers, handleHide);
          this.$_registerTriggerListeners([this.$_popperNode], HIDE_EVENT_MAP, this.popperTriggers, this.popperHideTriggers, handleHide);
        },
        $_registerEventListeners(targetNodes, eventType, handler) {
          this.$_events.push({ targetNodes, eventType, handler });
          targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive ? {
            passive: true
          } : void 0));
        },
        $_registerTriggerListeners(targetNodes, eventMap, commonTriggers, customTrigger, handler) {
          let triggers = commonTriggers;
          if (customTrigger != null) {
            triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
          }
          triggers.forEach((trigger2) => {
            const eventType = eventMap[trigger2];
            if (eventType) {
              this.$_registerEventListeners(targetNodes, eventType, handler);
            }
          });
        },
        $_removeEventListeners(filterEventType) {
          const newList = [];
          this.$_events.forEach((listener) => {
            const { targetNodes, eventType, handler } = listener;
            if (!filterEventType || filterEventType === eventType) {
              targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
            } else {
              newList.push(listener);
            }
          });
          this.$_events = newList;
        },
        $_refreshListeners() {
          if (!this.$_isDisposed) {
            this.$_removeEventListeners();
            this.$_addEventListeners();
          }
        },
        $_handleGlobalClose(event, touch = false) {
          if (this.$_showFrameLocked)
            return;
          this.hide({ event });
          if (event.closePopover) {
            this.$emit("close-directive");
          } else {
            this.$emit("auto-hide");
          }
          if (touch) {
            this.$_preventShow = true;
            setTimeout(() => {
              this.$_preventShow = false;
            }, 300);
          }
        },
        $_detachPopperNode() {
          this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
        },
        $_swapTargetAttrs(attrFrom, attrTo) {
          for (const el of this.$_targetNodes) {
            const value = el.getAttribute(attrFrom);
            if (value) {
              el.removeAttribute(attrFrom);
              el.setAttribute(attrTo, value);
            }
          }
        },
        $_applyAttrsToTarget(attrs) {
          for (const el of this.$_targetNodes) {
            for (const n in attrs) {
              const value = attrs[n];
              if (value == null) {
                el.removeAttribute(n);
              } else {
                el.setAttribute(n, value);
              }
            }
          }
        },
        $_updateParentShownChildren(value) {
          let parent2 = this.parentPopper;
          while (parent2) {
            if (value) {
              parent2.shownChildren.add(this.randomId);
            } else {
              parent2.shownChildren.delete(this.randomId);
              if (parent2.$_pendingHide) {
                parent2.hide();
              }
            }
            parent2 = parent2.parentPopper;
          }
        },
        $_isAimingPopper() {
          const referenceBounds = this.$_referenceNode.getBoundingClientRect();
          if (mouseX >= referenceBounds.left && mouseX <= referenceBounds.right && mouseY >= referenceBounds.top && mouseY <= referenceBounds.bottom) {
            const popperBounds = this.$_popperNode.getBoundingClientRect();
            const vectorX = mouseX - mousePreviousX;
            const vectorY = mouseY - mousePreviousY;
            const distance = popperBounds.left + popperBounds.width / 2 - mousePreviousX + (popperBounds.top + popperBounds.height / 2) - mousePreviousY;
            const newVectorLength = distance + popperBounds.width + popperBounds.height;
            const edgeX = mousePreviousX + vectorX * newVectorLength;
            const edgeY = mousePreviousY + vectorY * newVectorLength;
            return lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.left, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.right, popperBounds.top) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.right, popperBounds.top, popperBounds.right, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.bottom, popperBounds.right, popperBounds.bottom);
          }
          return false;
        }
      },
      render() {
        return this.$slots.default(this.slotData);
      }
    });
    if (typeof document !== "undefined" && typeof window !== "undefined") {
      if (isIOS) {
        document.addEventListener("touchstart", handleGlobalMousedown, supportsPassive ? {
          passive: true,
          capture: true
        } : true);
        document.addEventListener("touchend", handleGlobalTouchend, supportsPassive ? {
          passive: true,
          capture: true
        } : true);
      } else {
        window.addEventListener("mousedown", handleGlobalMousedown, true);
        window.addEventListener("click", handleGlobalClick, true);
      }
      window.addEventListener("resize", computePositionAllShownPoppers);
    }
    function handleGlobalMousedown(event) {
      for (let i2 = 0; i2 < shownPoppers.length; i2++) {
        const popper = shownPoppers[i2];
        try {
          const popperContent = popper.popperNode();
          popper.$_mouseDownContains = popperContent.contains(event.target);
        } catch (e) {
        }
      }
    }
    function handleGlobalClick(event) {
      handleGlobalClose(event);
    }
    function handleGlobalTouchend(event) {
      handleGlobalClose(event, true);
    }
    function handleGlobalClose(event, touch = false) {
      const preventClose = {};
      for (let i2 = shownPoppers.length - 1; i2 >= 0; i2--) {
        const popper = shownPoppers[i2];
        try {
          const contains2 = popper.$_containsGlobalTarget = isContainingEventTarget(popper, event);
          popper.$_pendingHide = false;
          requestAnimationFrame(() => {
            popper.$_pendingHide = false;
            if (preventClose[popper.randomId])
              return;
            if (shouldAutoHide(popper, contains2, event)) {
              popper.$_handleGlobalClose(event, touch);
              if (!event.closeAllPopover && event.closePopover && contains2) {
                let parent22 = popper.parentPopper;
                while (parent22) {
                  preventClose[parent22.randomId] = true;
                  parent22 = parent22.parentPopper;
                }
                return;
              }
              let parent2 = popper.parentPopper;
              while (parent2) {
                if (shouldAutoHide(parent2, parent2.$_containsGlobalTarget, event)) {
                  parent2.$_handleGlobalClose(event, touch);
                } else {
                  break;
                }
                parent2 = parent2.parentPopper;
              }
            }
          });
        } catch (e) {
        }
      }
    }
    function isContainingEventTarget(popper, event) {
      const popperContent = popper.popperNode();
      return popper.$_mouseDownContains || popperContent.contains(event.target);
    }
    function shouldAutoHide(popper, contains2, event) {
      return event.closeAllPopover || event.closePopover && contains2 || getAutoHideResult(popper, event) && !contains2;
    }
    function getAutoHideResult(popper, event) {
      if (typeof popper.autoHide === "function") {
        const result = popper.autoHide(event);
        popper.lastAutoHide = result;
        return result;
      }
      return popper.autoHide;
    }
    function computePositionAllShownPoppers(event) {
      for (let i2 = 0; i2 < shownPoppers.length; i2++) {
        const popper = shownPoppers[i2];
        popper.$_computePosition(event);
      }
    }
    let mousePreviousX = 0;
    let mousePreviousY = 0;
    let mouseX = 0;
    let mouseY = 0;
    if (typeof window !== "undefined") {
      window.addEventListener("mousemove", (event) => {
        mousePreviousX = mouseX;
        mousePreviousY = mouseY;
        mouseX = event.clientX;
        mouseY = event.clientY;
      }, supportsPassive ? {
        passive: true
      } : void 0);
    }
    function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
      const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
      const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
      return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
    }
    var _export_sfc$1 = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$6$1 = {
      extends: PrivatePopper()
    };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", mergeProps({
        ref: "reference",
        class: "v-popper"
      }, _ctx.$attrs, {
        class: {
          "v-popper--shown": _ctx.slotData.isShown
        }
      }), [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)))
      ], 16);
    }
    var Popper$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$6$1, [["render", _sfc_render$3]]);
    function getInternetExplorerVersion() {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf("MSIE ");
      if (msie > 0) {
        return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
      }
      var trident = ua.indexOf("Trident/");
      if (trident > 0) {
        var rv = ua.indexOf("rv:");
        return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
      }
      var edge = ua.indexOf("Edge/");
      if (edge > 0) {
        return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
      }
      return -1;
    }
    let isIE;
    function initCompat() {
      if (!initCompat.init) {
        initCompat.init = true;
        isIE = getInternetExplorerVersion() !== -1;
      }
    }
    var script$6 = {
      name: "ResizeObserver",
      props: {
        emitOnMount: {
          type: Boolean,
          default: false
        },
        ignoreWidth: {
          type: Boolean,
          default: false
        },
        ignoreHeight: {
          type: Boolean,
          default: false
        }
      },
      emits: [
        "notify"
      ],
      mounted() {
        initCompat();
        nextTick$1(() => {
          this._w = this.$el.offsetWidth;
          this._h = this.$el.offsetHeight;
          if (this.emitOnMount) {
            this.emitSize();
          }
        });
        const object = document.createElement("object");
        this._resizeObject = object;
        object.setAttribute("aria-hidden", "true");
        object.setAttribute("tabindex", -1);
        object.onload = this.addResizeHandlers;
        object.type = "text/html";
        if (isIE) {
          this.$el.appendChild(object);
        }
        object.data = "about:blank";
        if (!isIE) {
          this.$el.appendChild(object);
        }
      },
      beforeUnmount() {
        this.removeResizeHandlers();
      },
      methods: {
        compareAndNotify() {
          if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
            this._w = this.$el.offsetWidth;
            this._h = this.$el.offsetHeight;
            this.emitSize();
          }
        },
        emitSize() {
          this.$emit("notify", {
            width: this._w,
            height: this._h
          });
        },
        addResizeHandlers() {
          this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
          this.compareAndNotify();
        },
        removeResizeHandlers() {
          if (this._resizeObject && this._resizeObject.onload) {
            if (!isIE && this._resizeObject.contentDocument) {
              this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
            }
            this.$el.removeChild(this._resizeObject);
            this._resizeObject.onload = null;
            this._resizeObject = null;
          }
        }
      }
    };
    const _withId = /* @__PURE__ */ withScopeId();
    pushScopeId("data-v-b329ee4c");
    const _hoisted_1$2$1 = {
      class: "resize-observer",
      tabindex: "-1"
    };
    popScopeId();
    const render$1l = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
      return openBlock(), createBlock("div", _hoisted_1$2$1);
    });
    script$6.render = render$1l;
    script$6.__scopeId = "data-v-b329ee4c";
    script$6.__file = "src/components/ResizeObserver.vue";
    var PrivateThemeClass = (prop = "theme") => ({
      computed: {
        themeClass() {
          return getThemeClasses(this[prop]);
        }
      }
    });
    const _sfc_main$5$1 = defineComponent({
      name: "VPopperContent",
      components: {
        ResizeObserver: script$6
      },
      mixins: [
        PrivateThemeClass()
      ],
      props: {
        popperId: String,
        theme: String,
        shown: Boolean,
        mounted: Boolean,
        skipTransition: Boolean,
        autoHide: Boolean,
        handleResize: Boolean,
        classes: Object,
        result: Object
      },
      emits: [
        "hide",
        "resize"
      ],
      methods: {
        toPx(value) {
          if (value != null && !isNaN(value)) {
            return `${value}px`;
          }
          return null;
        }
      }
    });
    const _hoisted_1$1$1 = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
    const _hoisted_2$1$1 = {
      ref: "inner",
      class: "v-popper__inner"
    };
    const _hoisted_3$1L = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1);
    const _hoisted_4$y = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1);
    const _hoisted_5$j = [
      _hoisted_3$1L,
      _hoisted_4$y
    ];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ResizeObserver = resolveComponent("ResizeObserver");
      return openBlock(), createElementBlock("div", {
        id: _ctx.popperId,
        ref: "popover",
        class: normalizeClass(["v-popper__popper", [
          _ctx.themeClass,
          _ctx.classes.popperClass,
          {
            "v-popper__popper--shown": _ctx.shown,
            "v-popper__popper--hidden": !_ctx.shown,
            "v-popper__popper--show-from": _ctx.classes.showFrom,
            "v-popper__popper--show-to": _ctx.classes.showTo,
            "v-popper__popper--hide-from": _ctx.classes.hideFrom,
            "v-popper__popper--hide-to": _ctx.classes.hideTo,
            "v-popper__popper--skip-transition": _ctx.skipTransition,
            "v-popper__popper--arrow-overflow": _ctx.result && _ctx.result.arrow.overflow,
            "v-popper__popper--no-positioning": !_ctx.result
          }
        ]]),
        style: normalizeStyle(_ctx.result ? {
          position: _ctx.result.strategy,
          transform: `translate3d(${Math.round(_ctx.result.x)}px,${Math.round(_ctx.result.y)}px,0)`
        } : void 0),
        "aria-hidden": _ctx.shown ? "false" : "true",
        tabindex: _ctx.autoHide ? 0 : void 0,
        "data-popper-placement": _ctx.result ? _ctx.result.placement : void 0,
        onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.autoHide && _ctx.$emit("hide"), ["esc"]))
      }, [
        createBaseVNode("div", {
          class: "v-popper__backdrop",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.autoHide && _ctx.$emit("hide"))
        }),
        createBaseVNode("div", {
          class: "v-popper__wrapper",
          style: normalizeStyle(_ctx.result ? {
            transformOrigin: _ctx.result.transformOrigin
          } : void 0)
        }, [
          createBaseVNode("div", _hoisted_2$1$1, [
            _ctx.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", null, [
                renderSlot(_ctx.$slots, "default")
              ]),
              _ctx.handleResize ? (openBlock(), createBlock(_component_ResizeObserver, {
                key: 0,
                onNotify: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("resize", $event))
              })) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true)
          ], 512),
          createBaseVNode("div", {
            ref: "arrow",
            class: "v-popper__arrow-container",
            style: normalizeStyle(_ctx.result ? {
              left: _ctx.toPx(_ctx.result.arrow.x),
              top: _ctx.toPx(_ctx.result.arrow.y)
            } : void 0)
          }, _hoisted_5$j, 4)
        ], 4)
      ], 46, _hoisted_1$1$1);
    }
    var PrivatePopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$5$1, [["render", _sfc_render$2]]);
    var PrivatePopperMethods = {
      methods: {
        show(...args) {
          return this.$refs.popper.show(...args);
        },
        hide(...args) {
          return this.$refs.popper.hide(...args);
        },
        dispose(...args) {
          return this.$refs.popper.dispose(...args);
        },
        onResize(...args) {
          return this.$refs.popper.onResize(...args);
        }
      }
    };
    const _sfc_main$4$1 = defineComponent({
      name: "VPopperWrapper",
      components: {
        Popper: Popper$1,
        PopperContent: PrivatePopperContent
      },
      mixins: [
        PrivatePopperMethods,
        PrivateThemeClass("finalTheme")
      ],
      props: {
        theme: {
          type: String,
          default: null
        }
      },
      computed: {
        finalTheme() {
          var _a;
          return (_a = this.theme) != null ? _a : this.$options.vPopperTheme;
        }
      },
      methods: {
        getTargetNodes() {
          return Array.from(this.$refs.popper.$el.children).filter((node) => node !== this.$refs.popperContent.$el);
        }
      }
    });
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_PopperContent = resolveComponent("PopperContent");
      const _component_Popper = resolveComponent("Popper");
      return openBlock(), createBlock(_component_Popper, {
        ref: "popper",
        theme: _ctx.finalTheme,
        "target-nodes": _ctx.getTargetNodes,
        "reference-node": () => _ctx.$refs.popper.$el,
        "popper-node": () => _ctx.$refs.popperContent.$el,
        class: normalizeClass([
          _ctx.themeClass
        ])
      }, {
        default: withCtx(({
          popperId,
          isShown,
          shouldMountContent,
          skipTransition,
          autoHide,
          show,
          hide,
          handleResize,
          onResize,
          classes,
          result
        }) => [
          renderSlot(_ctx.$slots, "default", {
            shown: isShown,
            show,
            hide
          }),
          createVNode(_component_PopperContent, {
            ref: "popperContent",
            "popper-id": popperId,
            theme: _ctx.finalTheme,
            shown: isShown,
            mounted: shouldMountContent,
            "skip-transition": skipTransition,
            "auto-hide": autoHide,
            "handle-resize": handleResize,
            classes,
            result,
            onHide: hide,
            onResize
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "popper", {
                shown: isShown,
                hide
              })
            ]),
            _: 2
          }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
        ]),
        _: 3
      }, 8, ["theme", "target-nodes", "reference-node", "popper-node", "class"]);
    }
    var PrivatePopperWrapper = /* @__PURE__ */ _export_sfc$1(_sfc_main$4$1, [["render", _sfc_render$1]]);
    const _sfc_main$3$1 = defineComponent(__spreadProps(__spreadValues$1({}, PrivatePopperWrapper), {
      name: "VDropdown",
      vPopperTheme: "dropdown"
    }));
    defineComponent(__spreadProps(__spreadValues$1({}, PrivatePopperWrapper), {
      name: "VMenu",
      vPopperTheme: "menu"
    }));
    defineComponent(__spreadProps(__spreadValues$1({}, PrivatePopperWrapper), {
      name: "VTooltip",
      vPopperTheme: "tooltip"
    }));
    const _sfc_main$13 = defineComponent({
      name: "VTooltipDirective",
      components: {
        Popper: PrivatePopper(),
        PopperContent: PrivatePopperContent
      },
      mixins: [
        PrivatePopperMethods
      ],
      inheritAttrs: false,
      props: {
        theme: {
          type: String,
          default: "tooltip"
        },
        html: {
          type: Boolean,
          default: (props) => getDefaultConfig(props.theme, "html")
        },
        content: {
          type: [String, Number, Function],
          default: null
        },
        loadingContent: {
          type: String,
          default: (props) => getDefaultConfig(props.theme, "loadingContent")
        }
      },
      data() {
        return {
          asyncContent: null
        };
      },
      computed: {
        isContentAsync() {
          return typeof this.content === "function";
        },
        loading() {
          return this.isContentAsync && this.asyncContent == null;
        },
        finalContent() {
          if (this.isContentAsync) {
            return this.loading ? this.loadingContent : this.asyncContent;
          }
          return this.content;
        }
      },
      watch: {
        content: {
          handler() {
            this.fetchContent(true);
          },
          immediate: true
        },
        async finalContent() {
          await this.$nextTick();
          this.$refs.popper.onResize();
        }
      },
      created() {
        this.$_fetchId = 0;
      },
      methods: {
        fetchContent(force) {
          if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
            this.asyncContent = null;
            this.$_loading = true;
            const fetchId = ++this.$_fetchId;
            const result = this.content(this);
            if (result.then) {
              result.then((res) => this.onResult(fetchId, res));
            } else {
              this.onResult(fetchId, result);
            }
          }
        },
        onResult(fetchId, result) {
          if (fetchId !== this.$_fetchId)
            return;
          this.$_loading = false;
          this.asyncContent = result;
        },
        onShow() {
          this.$_isShown = true;
          this.fetchContent();
        },
        onHide() {
          this.$_isShown = false;
        }
      }
    });
    const _hoisted_1$2d = ["innerHTML"];
    const _hoisted_2$1V = ["textContent"];
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_PopperContent = resolveComponent("PopperContent");
      const _component_Popper = resolveComponent("Popper");
      return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.$attrs, {
        theme: _ctx.theme,
        "popper-node": () => _ctx.$refs.popperContent.$el,
        onApplyShow: _ctx.onShow,
        onApplyHide: _ctx.onHide
      }), {
        default: withCtx(({
          popperId,
          isShown,
          shouldMountContent,
          skipTransition,
          autoHide,
          hide,
          handleResize,
          onResize,
          classes,
          result
        }) => [
          createVNode(_component_PopperContent, {
            ref: "popperContent",
            class: normalizeClass({
              "v-popper--tooltip-loading": _ctx.loading
            }),
            "popper-id": popperId,
            theme: _ctx.theme,
            shown: isShown,
            mounted: shouldMountContent,
            "skip-transition": skipTransition,
            "auto-hide": autoHide,
            "handle-resize": handleResize,
            classes,
            result,
            onHide: hide,
            onResize
          }, {
            default: withCtx(() => [
              _ctx.html ? (openBlock(), createElementBlock("div", {
                key: 0,
                innerHTML: _ctx.finalContent
              }, null, 8, _hoisted_1$2d)) : (openBlock(), createElementBlock("div", {
                key: 1,
                textContent: toDisplayString(_ctx.finalContent)
              }, null, 8, _hoisted_2$1V))
            ]),
            _: 2
          }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
        ]),
        _: 1
      }, 16, ["theme", "popper-node", "onApplyShow", "onApplyHide"]);
    }
    var PrivateTooltipDirective = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["render", _sfc_render]]);
    const TARGET_CLASS = "v-popper--has-tooltip";
    function getPlacement(options2, modifiers) {
      let result = options2.placement;
      if (!result && modifiers) {
        for (const pos of placements) {
          if (modifiers[pos]) {
            result = pos;
          }
        }
      }
      if (!result) {
        result = getDefaultConfig(options2.theme || "tooltip", "placement");
      }
      return result;
    }
    function getOptions(el, value, modifiers) {
      let options2;
      const type2 = typeof value;
      if (type2 === "string") {
        options2 = { content: value };
      } else if (value && type2 === "object") {
        options2 = value;
      } else {
        options2 = { content: false };
      }
      options2.placement = getPlacement(options2, modifiers);
      options2.targetNodes = () => [el];
      options2.referenceNode = () => el;
      return options2;
    }
    let directiveApp;
    let directives;
    let uid = 0;
    function ensureDirectiveApp() {
      if (directiveApp)
        return;
      directives = ref([]);
      directiveApp = createApp({
        name: "VTooltipDirectiveApp",
        setup() {
          return {
            directives
          };
        },
        render() {
          return this.directives.map((directive) => {
            return h(PrivateTooltipDirective, __spreadProps(__spreadValues$1({}, directive.options), {
              shown: directive.shown || directive.options.shown,
              key: directive.id
            }));
          });
        },
        devtools: {
          hide: true
        }
      });
      const mountTarget = document.createElement("div");
      document.body.appendChild(mountTarget);
      directiveApp.mount(mountTarget);
    }
    function createTooltip(el, value, modifiers) {
      ensureDirectiveApp();
      const options2 = ref(getOptions(el, value, modifiers));
      const shown = ref(false);
      const item = {
        id: uid++,
        options: options2,
        shown
      };
      directives.value.push(item);
      if (el.classList) {
        el.classList.add(TARGET_CLASS);
      }
      const result = el.$_popper = {
        options: options2,
        item,
        show() {
          shown.value = true;
        },
        hide() {
          shown.value = false;
        }
      };
      return result;
    }
    function destroyTooltip(el) {
      if (el.$_popper) {
        const index2 = directives.value.indexOf(el.$_popper.item);
        if (index2 !== -1)
          directives.value.splice(index2, 1);
        delete el.$_popper;
        delete el.$_popperOldShown;
        delete el.$_popperMountTarget;
      }
      if (el.classList) {
        el.classList.remove(TARGET_CLASS);
      }
    }
    function bind$4(el, { value, modifiers }) {
      const options2 = getOptions(el, value, modifiers);
      if (!options2.content || getDefaultConfig(options2.theme || "tooltip", "disabled")) {
        destroyTooltip(el);
      } else {
        let directive;
        if (el.$_popper) {
          directive = el.$_popper;
          directive.options.value = options2;
        } else {
          directive = createTooltip(el, value, modifiers);
        }
        if (typeof value.shown !== "undefined" && value.shown !== el.$_popperOldShown) {
          el.$_popperOldShown = value.shown;
          value.shown ? directive.show() : directive.hide();
        }
      }
    }
    var PrivateVTooltip = {
      beforeMount: bind$4,
      updated: bind$4,
      beforeUnmount(el) {
        destroyTooltip(el);
      }
    };
    function addListeners(el) {
      el.addEventListener("click", onClick);
      el.addEventListener("touchstart", onTouchStart, supportsPassive ? {
        passive: true
      } : false);
    }
    function removeListeners(el) {
      el.removeEventListener("click", onClick);
      el.removeEventListener("touchstart", onTouchStart);
      el.removeEventListener("touchend", onTouchEnd);
      el.removeEventListener("touchcancel", onTouchCancel);
    }
    function onClick(event) {
      const el = event.currentTarget;
      event.closePopover = !el.$_vclosepopover_touch;
      event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;
    }
    function onTouchStart(event) {
      if (event.changedTouches.length === 1) {
        const el = event.currentTarget;
        el.$_vclosepopover_touch = true;
        const touch = event.changedTouches[0];
        el.$_vclosepopover_touchPoint = touch;
        el.addEventListener("touchend", onTouchEnd);
        el.addEventListener("touchcancel", onTouchCancel);
      }
    }
    function onTouchEnd(event) {
      const el = event.currentTarget;
      el.$_vclosepopover_touch = false;
      if (event.changedTouches.length === 1) {
        const touch = event.changedTouches[0];
        const firstTouch = el.$_vclosepopover_touchPoint;
        event.closePopover = Math.abs(touch.screenY - firstTouch.screenY) < 20 && Math.abs(touch.screenX - firstTouch.screenX) < 20;
        event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;
      }
    }
    function onTouchCancel(event) {
      const el = event.currentTarget;
      el.$_vclosepopover_touch = false;
    }
    var PrivateVClosePopper = {
      beforeMount(el, { value, modifiers }) {
        el.$_closePopoverModifiers = modifiers;
        if (typeof value === "undefined" || value) {
          addListeners(el);
        }
      },
      updated(el, { value, oldValue, modifiers }) {
        el.$_closePopoverModifiers = modifiers;
        if (value !== oldValue) {
          if (typeof value === "undefined" || value) {
            addListeners(el);
          } else {
            removeListeners(el);
          }
        }
      },
      beforeUnmount(el) {
        removeListeners(el);
      }
    };
    const VTooltip = PrivateVTooltip;
    const VClosePopper = PrivateVClosePopper;
    const Dropdown = _sfc_main$3$1;
    var mapObj$1 = { exports: {} };
    const isObject$a = (value) => typeof value === "object" && value !== null;
    const mapObjectSkip = Symbol("skip");
    const isObjectCustom = (value) => isObject$a(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    const mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array2) => array2.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    mapObj$1.exports = (object, mapper, options) => {
      if (!isObject$a(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    mapObj$1.exports.mapObjectSkip = mapObjectSkip;
    var camelcase = { exports: {} };
    const UPPERCASE = /[\p{Lu}]/u;
    const LOWERCASE = /[\p{Ll}]/u;
    const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    const SEPARATORS = /[_.\- ]+/;
    const LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    const preserveCamelCase = (string2, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i2 = 0; i2 < string2.length; i2++) {
        const character = string2[i2];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string2 = string2.slice(0, i2) + "-" + string2.slice(i2);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i2++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string2 = string2.slice(0, i2 - 1) + "-" + string2.slice(i2 - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string2;
    };
    const preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    const postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    const camelCase$1 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string2) => string2.toLowerCase() : (string2) => string2.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string2) => string2.toUpperCase() : (string2) => string2.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    camelcase.exports = camelCase$1;
    camelcase.exports.default = camelCase$1;
    class QuickLRU {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    }
    var quickLru = QuickLRU;
    const mapObj = mapObj$1.exports;
    const camelCase = camelcase.exports;
    const QuickLru = quickLru;
    const has$1 = (array2, key) => array2.some((x) => {
      if (typeof x === "string") {
        return x === key;
      }
      x.lastIndex = 0;
      return x.test(key);
    });
    const cache = new QuickLru({ maxSize: 1e5 });
    const isObject$9 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    const camelCaseConvert = (input, options) => {
      if (!isObject$9(input)) {
        return input;
      }
      options = {
        deep: false,
        pascalCase: false,
        ...options
      };
      const { exclude, pascalCase, stopPaths, deep } = options;
      const stopPathsSet = new Set(stopPaths);
      const makeMapper = (parentPath) => (key, value) => {
        if (deep && isObject$9(value)) {
          const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
          if (!stopPathsSet.has(path)) {
            value = mapObj(value, makeMapper(path));
          }
        }
        if (!(exclude && has$1(exclude, key))) {
          const cacheKey = pascalCase ? `${key}_` : key;
          if (cache.has(cacheKey)) {
            key = cache.get(cacheKey);
          } else {
            const returnValue = camelCase(key, { pascalCase, locale: false });
            if (key.length < 100) {
              cache.set(cacheKey, returnValue);
            }
            key = returnValue;
          }
        }
        return [key, value];
      };
      return mapObj(input, makeMapper(void 0));
    };
    var camelcaseKeys = (input, options) => {
      if (Array.isArray(input)) {
        return Object.keys(input).map((key) => camelCaseConvert(input[key], options));
      }
      return camelCaseConvert(input, options);
    };
    var lib = {};
    var utilities = {};
    var array$1 = {};
    Object.defineProperty(array$1, "__esModule", { value: true });
    array$1.repeat = array$1.normalizeValueToStringArray = void 0;
    const normalizeValueToStringArray = (value) => {
      if (value) {
        return Array.isArray(value) ? value : [value];
      }
      return [];
    };
    array$1.normalizeValueToStringArray = normalizeValueToStringArray;
    const repeat = (times, initial, iterate) => {
      let result = initial;
      while (times--) {
        result = iterate(result);
      }
      return result;
    };
    array$1.repeat = repeat;
    var assert$2 = {};
    Object.defineProperty(assert$2, "__esModule", { value: true });
    assert$2.assert = void 0;
    const assert$1 = (value, error) => {
      if (!value) {
        throw error;
      }
    };
    assert$2.assert = assert$1;
    var assertions = {};
    var lodash_orderby = { exports: {} };
    (function(module2, exports2) {
      var LARGE_ARRAY_SIZE2 = 200;
      var FUNC_ERROR_TEXT2 = "Expected a function";
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
      var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991;
      var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag2 = "[object WeakMap]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
      var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, reLeadingDot2 = /^\./, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar2 = /\\(\\)?/g;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
      typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
      var freeGlobal2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var freeProcess2 = moduleExports2 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          return freeProcess2 && freeProcess2.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      function arrayMap2(array2, iteratee) {
        var index2 = -1, length = array2 ? array2.length : 0, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array2[index2], index2, array2);
        }
        return result;
      }
      function arraySome(array2, predicate) {
        var index2 = -1, length = array2 ? array2.length : 0;
        while (++index2 < length) {
          if (predicate(array2[index2], index2, array2)) {
            return true;
          }
        }
        return false;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseTimes2(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseUnary2(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue2(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject2(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg2(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
      var coreJsData2 = root2["__core-js_shared__"];
      var maskSrcKey2 = function() {
        var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var objectToString2 = objectProto2.toString;
      var reIsNative2 = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
      var nativeKeys2 = overArg2(Object.keys, Object);
      var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
      var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
      var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0, symbolToString2 = symbolProto2 ? symbolProto2.toString : void 0;
      function Hash2(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
      }
      function hashDelete2(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet2(key) {
        var data2 = this.__data__;
        if (nativeCreate2) {
          var result = data2[key];
          return result === HASH_UNDEFINED2 ? void 0 : result;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
      }
      function hashHas2(key) {
        var data2 = this.__data__;
        return nativeCreate2 ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
      }
      function hashSet2(key, value) {
        var data2 = this.__data__;
        data2[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
      }
      function listCacheDelete2(key) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice2.call(data2, index2, 1);
        }
        return true;
      }
      function listCacheGet2(key) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
        return index2 < 0 ? void 0 : data2[index2][1];
      }
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
        if (index2 < 0) {
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key) {
        return getMapData2(this, key)["delete"](key);
      }
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      function mapCacheSet2(key, value) {
        getMapData2(this, key).set(key, value);
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache(values) {
        var index2 = -1, length = values ? values.length : 0;
        this.__data__ = new MapCache2();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries) {
        this.__data__ = new ListCache2(entries);
      }
      function stackClear2() {
        this.__data__ = new ListCache2();
      }
      function stackDelete2(key) {
        return this.__data__["delete"](key);
      }
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      function stackSet2(key, value) {
        var cache2 = this.__data__;
        if (cache2 instanceof ListCache2) {
          var pairs = cache2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            return this;
          }
          cache2 = this.__data__ = new MapCache2(pairs);
        }
        cache2.set(key, value);
        return this;
      }
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var result = isArray2(value) || isArguments2(value) ? baseTimes2(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assocIndexOf2(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq2(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseFor2 = createBaseFor2();
      function baseForOwn(object, iteratee) {
        return object && baseFor2(object, iteratee, keys2);
      }
      function baseGet2(object, path) {
        path = isKey2(path, object) ? [path] : castPath2(path);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey2(path[index2++])];
        }
        return index2 && index2 == length ? object : void 0;
      }
      function baseGetTag2(value) {
        return objectToString2.call(value);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function baseIsEqual(value, other, customizer, bitmask, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObject2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack2);
      }
      function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack2) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = arrayTag2, othTag = arrayTag2;
        if (!objIsArr) {
          objTag = getTag2(object);
          objTag = objTag == argsTag2 ? objectTag2 : objTag;
        }
        if (!othIsArr) {
          othTag = getTag2(other);
          othTag = othTag == argsTag2 ? objectTag2 : othTag;
        }
        var objIsObj = objTag == objectTag2 && !isHostObject2(object), othIsObj = othTag == objectTag2 && !isHostObject2(other), isSameTag = objTag == othTag;
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack2());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack2) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack2);
        }
        if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack2());
        return equalObjects(object, other, equalFunc, customizer, bitmask, stack2);
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack2();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack2) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[objectToString2.call(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function baseMap(collection, iteratee) {
        var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index2] = iteratee(value, key, collection2);
        });
        return result;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey2(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey2(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
        };
      }
      function baseOrderBy(collection, iteratees, orders) {
        var index2 = -1;
        iteratees = arrayMap2(iteratees.length ? iteratees : [identity2], baseUnary2(baseIteratee));
        var result = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap2(iteratees, function(iteratee) {
            return iteratee(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet2(object, path);
        };
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol2(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
      }
      function castPath2(value) {
        return isArray2(value) ? value : stringToPath2(value);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result) {
            if (index2 >= ordersLength) {
              return result;
            }
            var order = orders[index2];
            return result * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor2(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function equalArrays(array2, other, equalFunc, customizer, bitmask, stack2) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack2.get(array2);
        if (stacked && stack2.get(other)) {
          return stacked == other;
        }
        var index2 = -1, result = true, seen2 = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
        stack2.set(array2, other);
        stack2.set(other, array2);
        while (++index2 < arrLength) {
          var arrValue = array2[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!seen2.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack2))) {
                return seen2.add(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack2))) {
            result = false;
            break;
          }
        }
        stack2["delete"](array2);
        stack2["delete"](other);
        return result;
      }
      function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack2) {
        switch (tag) {
          case dataViewTag2:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag2:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag2:
          case numberTag2:
            return eq2(+object, +other);
          case errorTag2:
            return object.name == other.name && object.message == other.message;
          case regexpTag2:
          case stringTag2:
            return object == other + "";
          case mapTag2:
            var convert = mapToArray;
          case setTag2:
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= UNORDERED_COMPARE_FLAG;
            stack2.set(object, other);
            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack2);
            stack2["delete"](object);
            return result;
          case symbolTag2:
            if (symbolValueOf2) {
              return symbolValueOf2.call(object) == symbolValueOf2.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, equalFunc, customizer, bitmask, stack2) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys2(object), objLength = objProps.length, othProps = keys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var stacked = stack2.get(object);
        if (stacked && stack2.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack2) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result;
      }
      function getMapData2(map, key) {
        var data2 = map.__data__;
        return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result = keys2(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : void 0;
      }
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
        getTag2 = function(value) {
          var result = objectToString2.call(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag2;
              case mapCtorString2:
                return mapTag2;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag2;
              case weakMapCtorString2:
                return weakMapTag2;
            }
          }
          return result;
        };
      }
      function hasPath(object, path, hasFunc) {
        path = isKey2(path, object) ? [path] : castPath2(path);
        var result, index2 = -1, length = path.length;
        while (++index2 < length) {
          var key = toKey2(path[index2]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result) {
          return result;
        }
        var length = object ? object.length : 0;
        return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
      }
      function isIndex2(value, length) {
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isKey2(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object(object);
      }
      function isKeyable2(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      var stringToPath2 = memoize2(function(string2) {
        string2 = toString2(string2);
        var result = [];
        if (reLeadingDot2.test(string2)) {
          result.push("");
        }
        string2.replace(rePropName2, function(match, number2, quote, string3) {
          result.push(quote ? string3.replace(reEscapeChar2, "$1") : number2 || match);
        });
        return result;
      });
      function toKey2(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? void 0 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result);
          return result;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      function isArguments2(value) {
        return isArrayLikeObject2(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString2.call(value) == argsTag2);
      }
      var isArray2 = Array.isArray;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isFunction2(value) {
        var tag = isObject2(value) ? objectToString2.call(value) : "";
        return tag == funcTag2 || tag == genTag2;
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike2(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && objectToString2.call(value) == symbolTag2;
      }
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function toString2(value) {
        return value == null ? "" : baseToString2(value);
      }
      function get2(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet2(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      function identity2(value) {
        return value;
      }
      function property(path) {
        return isKey2(path) ? baseProperty(toKey2(path)) : basePropertyDeep(path);
      }
      module2.exports = orderBy;
    })(lodash_orderby, lodash_orderby.exports);
    var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(assertions, "__esModule", { value: true });
    assertions.hasChineseCharacter = assertions.has = assertions.notEmpty = assertions.notFalsy = assertions.isSameArray = void 0;
    const lodash_orderby_1 = __importDefault(lodash_orderby.exports);
    const isSameArray = (a, b) => {
      if (a.length !== b.length) {
        return false;
      }
      const sortedA = lodash_orderby_1.default(a);
      const sortedB = lodash_orderby_1.default(b);
      return sortedA.every((value, index2) => value === sortedB[index2]);
    };
    assertions.isSameArray = isSameArray;
    const notFalsy = (value) => Boolean(value);
    assertions.notFalsy = notFalsy;
    const notEmpty = (x) => x !== null && x !== void 0;
    assertions.notEmpty = notEmpty;
    const has = (data2, property) => Object.prototype.hasOwnProperty.call(data2, property);
    assertions.has = has;
    const hasChineseCharacter = (string2) => Boolean(/[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/.test(string2));
    assertions.hasChineseCharacter = hasChineseCharacter;
    var conditional$1 = {};
    Object.defineProperty(conditional$1, "__esModule", { value: true });
    conditional$1.conditionalString = conditional$1.conditional = conditional$1.nullable = void 0;
    const assertions_1 = assertions;
    const nullable$1 = (exp) => assertions_1.notFalsy(exp) ? exp : null;
    conditional$1.nullable = nullable$1;
    const conditional = (exp) => assertions_1.notFalsy(exp) ? exp : void 0;
    conditional$1.conditional = conditional;
    const conditionalString = (exp) => assertions_1.notFalsy(exp) ? String(exp) : "";
    conditional$1.conditionalString = conditionalString;
    var env = {};
    Object.defineProperty(env, "__esModule", { value: true });
    env.isNode = env.assertEnv = env.getEnv = void 0;
    const assert_1 = assert$2;
    const getEnv = (key, fallback = "") => {
      var _a;
      return (_a = process === null || process === void 0 ? void 0 : process.env[key]) !== null && _a !== void 0 ? _a : fallback;
    };
    env.getEnv = getEnv;
    const assertEnv = (key) => {
      const value = process === null || process === void 0 ? void 0 : process.env[key];
      assert_1.assert(value, new Error(`env variable ${key} not found`));
      return value;
    };
    env.assertEnv = assertEnv;
    const isNode = () => typeof window === "undefined";
    env.isNode = isNode;
    var pick$1 = {};
    var INFINITY$4 = 1 / 0, MAX_SAFE_INTEGER$2 = 9007199254740991;
    var argsTag$3 = "[object Arguments]", funcTag$4 = "[object Function]", genTag$3 = "[object GeneratorFunction]", symbolTag$5 = "[object Symbol]";
    var freeGlobal$3 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
    var freeSelf$2 = typeof self == "object" && self && self.Object === Object && self;
    var root$3 = freeGlobal$3 || freeSelf$2 || Function("return this")();
    function apply$1(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap$1(array2, iteratee) {
      var index2 = -1, length = array2 ? array2.length : 0, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    function arrayPush$1(array2, values) {
      var index2 = -1, length = values.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    var objectProto$g = Object.prototype;
    var hasOwnProperty$c = objectProto$g.hasOwnProperty;
    var objectToString$4 = objectProto$g.toString;
    var Symbol$4 = root$3.Symbol, propertyIsEnumerable$2 = objectProto$g.propertyIsEnumerable, spreadableSymbol = Symbol$4 ? Symbol$4.isConcatSpreadable : void 0;
    var nativeMax$2 = Math.max;
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index2 = -1, length = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length) {
        var value = array2[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush$1(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index2 = -1, length = props.length, result = {};
      while (++index2 < length) {
        var key = props[index2], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest$1(func, start) {
      start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax$2(args.length - start, 0), array2 = Array(length);
        while (++index2 < length) {
          array2[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = array2;
        return apply$1(func, this, otherArgs);
      };
    }
    function isFlattenable(value) {
      return isArray$6(value) || isArguments$2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function toKey$2(value) {
      if (typeof value == "string" || isSymbol$5(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
    }
    function isArguments$2(value) {
      return isArrayLikeObject$1(value) && hasOwnProperty$c.call(value, "callee") && (!propertyIsEnumerable$2.call(value, "callee") || objectToString$4.call(value) == argsTag$3);
    }
    var isArray$6 = Array.isArray;
    function isArrayLike$1(value) {
      return value != null && isLength$1(value.length) && !isFunction$5(value);
    }
    function isArrayLikeObject$1(value) {
      return isObjectLike$4(value) && isArrayLike$1(value);
    }
    function isFunction$5(value) {
      var tag = isObject$8(value) ? objectToString$4.call(value) : "";
      return tag == funcTag$4 || tag == genTag$3;
    }
    function isLength$1(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
    }
    function isObject$8(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike$4(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol$5(value) {
      return typeof value == "symbol" || isObjectLike$4(value) && objectToString$4.call(value) == symbolTag$5;
    }
    var pick = baseRest$1(function(object, props) {
      return object == null ? {} : basePick(object, arrayMap$1(baseFlatten(props, 1), toKey$2));
    });
    var lodash_pick = pick;
    (function(exports2) {
      var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.pickState = exports2.pick = void 0;
      const lodash_pick_1 = __importDefault2(lodash_pick);
      var lodash_pick_2 = lodash_pick;
      Object.defineProperty(exports2, "pick", { enumerable: true, get: function() {
        return __importDefault2(lodash_pick_2).default;
      } });
      const pickState = (...keys2) => (state) => lodash_pick_1.default(state, ...keys2);
      exports2.pickState = pickState;
    })(pick$1);
    var string$1 = {};
    Object.defineProperty(string$1, "__esModule", { value: true });
    string$1.UrlSafeBase64 = string$1.toTitle = void 0;
    const env_1 = env;
    function toTitle(string2) {
      if (typeof string2 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string2.toLowerCase().replace(/(?:^|\s|-)\S/g, (x) => x.toUpperCase()).replace(/-/g, " ");
    }
    string$1.toTitle = toTitle;
    const replaceNonUrlSafeCharacters = (base64String) => base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
    const restoreNonUrlSafeCharacters = (base64String) => base64String.replace(/-/g, "+").replace(/_/g, "/");
    const CHARACTER_SET_OF_BTOA_ATOB = "latin1";
    string$1.UrlSafeBase64 = {
      isSafe: (input) => /^[\w-]*$/.test(input),
      encode: (rawString) => {
        const encodedString = env_1.isNode() ? Buffer.from(rawString, CHARACTER_SET_OF_BTOA_ATOB).toString("base64") : btoa(rawString);
        return replaceNonUrlSafeCharacters(encodedString);
      },
      decode: (encodedString) => {
        const nonUrlSafeEncodedString = restoreNonUrlSafeCharacters(encodedString);
        return env_1.isNode() ? Buffer.from(nonUrlSafeEncodedString, "base64").toString(CHARACTER_SET_OF_BTOA_ATOB) : atob(nonUrlSafeEncodedString);
      },
      replaceNonUrlSafeCharacters,
      restoreNonUrlSafeCharacters
    };
    var types$1 = {};
    Object.defineProperty(types$1, "__esModule", { value: true });
    (function(exports2) {
      var __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.orderBy = void 0;
      __exportStar(array$1, exports2);
      __exportStar(assert$2, exports2);
      __exportStar(assertions, exports2);
      __exportStar(conditional$1, exports2);
      __exportStar(env, exports2);
      __exportStar(pick$1, exports2);
      __exportStar(string$1, exports2);
      __exportStar(types$1, exports2);
      var lodash_orderby_12 = lodash_orderby.exports;
      Object.defineProperty(exports2, "orderBy", { enumerable: true, get: function() {
        return __importDefault2(lodash_orderby_12).default;
      } });
    })(utilities);
    (function(exports2) {
      var __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(utilities, exports2);
    })(lib);
    var FUNC_ERROR_TEXT$4 = "Expected a function";
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var INFINITY$3 = 1 / 0;
    var funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", symbolTag$4 = "[object Symbol]";
    var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/, reLeadingDot = /^\./, rePropName$2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar$2 = /\\(\\)?/g;
    var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
    var freeGlobal$2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
    var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
    var root$2 = freeGlobal$2 || freeSelf$1 || Function("return this")();
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto$1 = Array.prototype, funcProto$3 = Function.prototype, objectProto$f = Object.prototype;
    var coreJsData$2 = root$2["__core-js_shared__"];
    var maskSrcKey$1 = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var funcToString$3 = funcProto$3.toString;
    var hasOwnProperty$b = objectProto$f.hasOwnProperty;
    var objectToString$3 = objectProto$f.toString;
    var reIsNative$1 = RegExp("^" + funcToString$3.call(hasOwnProperty$b).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol$3 = root$2.Symbol, splice$1 = arrayProto$1.splice;
    var Map$3 = getNative$1(root$2, "Map"), nativeCreate$2 = getNative$1(Object, "create");
    var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString$1 = symbolProto$2 ? symbolProto$2.toString : void 0;
    function Hash$1(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear$1() {
      this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
    }
    function hashDelete$1(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet$1(key) {
      var data2 = this.__data__;
      if (nativeCreate$2) {
        var result = data2[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$b.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas$1(key) {
      var data2 = this.__data__;
      return nativeCreate$2 ? data2[key] !== void 0 : hasOwnProperty$b.call(data2, key);
    }
    function hashSet$1(key, value) {
      var data2 = this.__data__;
      data2[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$2 : value;
      return this;
    }
    Hash$1.prototype.clear = hashClear$1;
    Hash$1.prototype["delete"] = hashDelete$1;
    Hash$1.prototype.get = hashGet$1;
    Hash$1.prototype.has = hashHas$1;
    Hash$1.prototype.set = hashSet$1;
    function ListCache$1(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear$1() {
      this.__data__ = [];
    }
    function listCacheDelete$1(key) {
      var data2 = this.__data__, index2 = assocIndexOf$1(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice$1.call(data2, index2, 1);
      }
      return true;
    }
    function listCacheGet$1(key) {
      var data2 = this.__data__, index2 = assocIndexOf$1(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas$1(key) {
      return assocIndexOf$1(this.__data__, key) > -1;
    }
    function listCacheSet$1(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf$1(data2, key);
      if (index2 < 0) {
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    ListCache$1.prototype.clear = listCacheClear$1;
    ListCache$1.prototype["delete"] = listCacheDelete$1;
    ListCache$1.prototype.get = listCacheGet$1;
    ListCache$1.prototype.has = listCacheHas$1;
    ListCache$1.prototype.set = listCacheSet$1;
    function MapCache$1(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear$1() {
      this.__data__ = {
        "hash": new Hash$1(),
        "map": new (Map$3 || ListCache$1)(),
        "string": new Hash$1()
      };
    }
    function mapCacheDelete$1(key) {
      return getMapData$1(this, key)["delete"](key);
    }
    function mapCacheGet$1(key) {
      return getMapData$1(this, key).get(key);
    }
    function mapCacheHas$1(key) {
      return getMapData$1(this, key).has(key);
    }
    function mapCacheSet$1(key, value) {
      getMapData$1(this, key).set(key, value);
      return this;
    }
    MapCache$1.prototype.clear = mapCacheClear$1;
    MapCache$1.prototype["delete"] = mapCacheDelete$1;
    MapCache$1.prototype.get = mapCacheGet$1;
    MapCache$1.prototype.has = mapCacheHas$1;
    MapCache$1.prototype.set = mapCacheSet$1;
    function assocIndexOf$1(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq$1(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet$1(object, path) {
      path = isKey$1(path, object) ? [path] : castPath$1(path);
      var index2 = 0, length = path.length;
      while (object != null && index2 < length) {
        object = object[toKey$1(path[index2++])];
      }
      return index2 && index2 == length ? object : void 0;
    }
    function baseIsNative$1(value) {
      if (!isObject$7(value) || isMasked$1(value)) {
        return false;
      }
      var pattern = isFunction$4(value) || isHostObject(value) ? reIsNative$1 : reIsHostCtor$1;
      return pattern.test(toSource$1(value));
    }
    function baseToString$1(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol$4(value)) {
        return symbolToString$1 ? symbolToString$1.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
    }
    function castPath$1(value) {
      return isArray$5(value) ? value : stringToPath$3(value);
    }
    function getMapData$1(map, key) {
      var data2 = map.__data__;
      return isKeyable$1(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative$1(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative$1(value) ? value : void 0;
    }
    function isKey$1(value, object) {
      if (isArray$5(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$4(value)) {
        return true;
      }
      return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
    }
    function isKeyable$1(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked$1(func) {
      return !!maskSrcKey$1 && maskSrcKey$1 in func;
    }
    var stringToPath$3 = memoize$1(function(string2) {
      string2 = toString$2(string2);
      var result = [];
      if (reLeadingDot.test(string2)) {
        result.push("");
      }
      string2.replace(rePropName$2, function(match, number2, quote, string3) {
        result.push(quote ? string3.replace(reEscapeChar$2, "$1") : number2 || match);
      });
      return result;
    });
    function toKey$1(value) {
      if (typeof value == "string" || isSymbol$4(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
    }
    function toSource$1(func) {
      if (func != null) {
        try {
          return funcToString$3.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize$1(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$4);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result);
        return result;
      };
      memoized.cache = new (memoize$1.Cache || MapCache$1)();
      return memoized;
    }
    memoize$1.Cache = MapCache$1;
    function eq$1(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray$5 = Array.isArray;
    function isFunction$4(value) {
      var tag = isObject$7(value) ? objectToString$3.call(value) : "";
      return tag == funcTag$3 || tag == genTag$2;
    }
    function isObject$7(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike$3(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol$4(value) {
      return typeof value == "symbol" || isObjectLike$3(value) && objectToString$3.call(value) == symbolTag$4;
    }
    function toString$2(value) {
      return value == null ? "" : baseToString$1(value);
    }
    function get$1(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet$1(object, path);
      return result === void 0 ? defaultValue : result;
    }
    var lodash_get = get$1;
    class StructError extends TypeError {
      constructor(failure, failures) {
        let cached;
        const {
          message,
          ...rest
        } = failure;
        const {
          path
        } = failure;
        const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
        super(msg);
        this.value = void 0;
        this.key = void 0;
        this.type = void 0;
        this.refinement = void 0;
        this.path = void 0;
        this.branch = void 0;
        this.failures = void 0;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          var _cached;
          return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
        };
      }
    }
    function isIterable(x) {
      return isObject$6(x) && typeof x[Symbol.iterator] === "function";
    }
    function isObject$6(x) {
      return typeof x === "object" && x != null;
    }
    function print(value) {
      return typeof value === "string" ? JSON.stringify(value) : "" + value;
    }
    function shiftIterator(input) {
      const {
        done,
        value
      } = input.next();
      return done ? void 0 : value;
    }
    function toFailure(result, context, struct, value) {
      if (result === true) {
        return;
      } else if (result === false) {
        result = {};
      } else if (typeof result === "string") {
        result = {
          message: result
        };
      }
      const {
        path,
        branch
      } = context;
      const {
        type: type2
      } = struct;
      const {
        refinement,
        message = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
      } = result;
      return {
        value,
        type: type2,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
      };
    }
    function* toFailures(result, context, struct, value) {
      if (!isIterable(result)) {
        result = [result];
      }
      for (const r of result) {
        const failure = toFailure(r, context, struct, value);
        if (failure) {
          yield failure;
        }
      }
    }
    function* run(value, struct, options) {
      if (options === void 0) {
        options = {};
      }
      const {
        path = [],
        branch = [value],
        coerce = false,
        mask: mask2 = false
      } = options;
      const ctx = {
        path,
        branch
      };
      if (coerce) {
        value = struct.coercer(value, ctx);
        if (mask2 && struct.type !== "type" && isObject$6(struct.schema) && isObject$6(value) && !Array.isArray(value)) {
          for (const key in value) {
            if (struct.schema[key] === void 0) {
              delete value[key];
            }
          }
        }
      }
      let status = "valid";
      for (const failure of struct.validator(value, ctx)) {
        status = "not_valid";
        yield [failure, void 0];
      }
      for (let [k, v, s] of struct.entries(value, ctx)) {
        const ts = run(v, s, {
          path: k === void 0 ? path : [...path, k],
          branch: k === void 0 ? branch : [...branch, v],
          coerce,
          mask: mask2
        });
        for (const t of ts) {
          if (t[0]) {
            status = t[0].refinement != null ? "not_refined" : "not_valid";
            yield [t[0], void 0];
          } else if (coerce) {
            v = t[1];
            if (k === void 0) {
              value = v;
            } else if (value instanceof Map) {
              value.set(k, v);
            } else if (value instanceof Set) {
              value.add(v);
            } else if (isObject$6(value)) {
              value[k] = v;
            }
          }
        }
      }
      if (status !== "not_valid") {
        for (const failure of struct.refiner(value, ctx)) {
          status = "not_refined";
          yield [failure, void 0];
        }
      }
      if (status === "valid") {
        yield [void 0, value];
      }
    }
    class Struct {
      constructor(props) {
        this.TYPE = void 0;
        this.type = void 0;
        this.schema = void 0;
        this.coercer = void 0;
        this.validator = void 0;
        this.refiner = void 0;
        this.entries = void 0;
        const {
          type: type2,
          schema,
          validator: validator2,
          refiner,
          coercer = (value) => value,
          entries = function* () {
          }
        } = props;
        this.type = type2;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator2) {
          this.validator = (value, context) => {
            const result = validator2(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      assert(value) {
        return assert(value, this);
      }
      create(value) {
        return create(value, this);
      }
      is(value) {
        return is(value, this);
      }
      mask(value) {
        return mask(value, this);
      }
      validate(value, options) {
        if (options === void 0) {
          options = {};
        }
        return validate$1(value, this, options);
      }
    }
    function assert(value, struct) {
      const result = validate$1(value, struct);
      if (result[0]) {
        throw result[0];
      }
    }
    function create(value, struct) {
      const result = validate$1(value, struct, {
        coerce: true
      });
      if (result[0]) {
        throw result[0];
      } else {
        return result[1];
      }
    }
    function mask(value, struct) {
      const result = validate$1(value, struct, {
        coerce: true,
        mask: true
      });
      if (result[0]) {
        throw result[0];
      } else {
        return result[1];
      }
    }
    function is(value, struct) {
      const result = validate$1(value, struct);
      return !result[0];
    }
    function validate$1(value, struct, options) {
      if (options === void 0) {
        options = {};
      }
      const tuples = run(value, struct, options);
      const tuple = shiftIterator(tuples);
      if (tuple[0]) {
        const error = new StructError(tuple[0], function* () {
          for (const t of tuples) {
            if (t[0]) {
              yield t[0];
            }
          }
        });
        return [error, void 0];
      } else {
        const v = tuple[1];
        return [void 0, v];
      }
    }
    function define(name, validator2) {
      return new Struct({
        type: name,
        schema: null,
        validator: validator2
      });
    }
    function array(Element2) {
      return new Struct({
        type: "array",
        schema: Element2,
        *entries(value) {
          if (Element2 && Array.isArray(value)) {
            for (const [i2, v] of value.entries()) {
              yield [i2, v, Element2];
            }
          }
        },
        coercer(value) {
          return Array.isArray(value) ? value.slice() : value;
        },
        validator(value) {
          return Array.isArray(value) || "Expected an array value, but received: " + print(value);
        }
      });
    }
    function nullable(struct) {
      return new Struct({
        ...struct,
        validator: (value, ctx) => value === null || struct.validator(value, ctx),
        refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
      });
    }
    function number() {
      return define("number", (value) => {
        return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
      });
    }
    function optional(struct) {
      return new Struct({
        ...struct,
        validator: (value, ctx) => value === void 0 || struct.validator(value, ctx),
        refiner: (value, ctx) => value === void 0 || struct.refiner(value, ctx)
      });
    }
    function record(Key, Value) {
      return new Struct({
        type: "record",
        schema: null,
        *entries(value) {
          if (isObject$6(value)) {
            for (const k in value) {
              const v = value[k];
              yield [k, k, Key];
              yield [k, v, Value];
            }
          }
        },
        validator(value) {
          return isObject$6(value) || "Expected an object, but received: " + print(value);
        }
      });
    }
    function string() {
      return define("string", (value) => {
        return typeof value === "string" || "Expected a string, but received: " + print(value);
      });
    }
    function type(schema) {
      const keys2 = Object.keys(schema);
      return new Struct({
        type: "type",
        schema,
        *entries(value) {
          if (isObject$6(value)) {
            for (const k of keys2) {
              yield [k, value[k], schema[k]];
            }
          }
        },
        validator(value) {
          return isObject$6(value) || "Expected an object, but received: " + print(value);
        }
      });
    }
    const crypto$1 = crypto;
    const isCryptoKey = (key) => key instanceof CryptoKey;
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    function concat(...buffers) {
      const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
      const buf = new Uint8Array(size2);
      let i2 = 0;
      buffers.forEach((buffer2) => {
        buf.set(buffer2, i2);
        i2 += buffer2.length;
      });
      return buf;
    }
    const decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i2 = 0; i2 < binary.length; i2++) {
        bytes[i2] = binary.charCodeAt(i2);
      }
      return bytes;
    };
    const decode$1 = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch (_a) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
    class JOSEError extends Error {
      constructor(message) {
        var _a;
        super(message);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
    }
    class JWTClaimValidationFailed extends JOSEError {
      constructor(message, claim = "unspecified", reason = "unspecified") {
        super(message);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
    }
    class JWTExpired extends JOSEError {
      constructor(message, claim = "unspecified", reason = "unspecified") {
        super(message);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
    }
    class JOSEAlgNotAllowed extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    }
    class JOSENotSupported extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    }
    class JWSInvalid extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    }
    class JWTInvalid extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    }
    class JWKSInvalid extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    }
    class JWKSNoMatchingKey extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    }
    class JWKSMultipleMatchingKeys extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    }
    class JWKSTimeout extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    }
    class JWSSignatureVerificationFailed extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    }
    function isCloudflareWorkers() {
      return typeof WebSocketPair === "function";
    }
    function unusable(name, prop = "algorithm.name") {
      return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
    }
    function isAlgorithm(algorithm, name) {
      return algorithm.name === name;
    }
    function getHashLength(hash2) {
      return parseInt(hash2.name.slice(4), 10);
    }
    function getNamedCurve(alg) {
      switch (alg) {
        case "ES256":
          return "P-256";
        case "ES384":
          return "P-384";
        case "ES512":
          return "P-521";
        default:
          throw new Error("unreachable");
      }
    }
    function checkUsage(key, usages) {
      if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = "CryptoKey does not support this operation, its usages must include ";
        if (usages.length > 2) {
          const last = usages.pop();
          msg += `one of ${usages.join(", ")}, or ${last}.`;
        } else if (usages.length === 2) {
          msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
          msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
      }
    }
    function checkSigCryptoKey(key, alg, ...usages) {
      switch (alg) {
        case "HS256":
        case "HS384":
        case "HS512": {
          if (!isAlgorithm(key.algorithm, "HMAC"))
            throw unusable("HMAC");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case "RS256":
        case "RS384":
        case "RS512": {
          if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
            throw unusable("RSASSA-PKCS1-v1_5");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case "PS256":
        case "PS384":
        case "PS512": {
          if (!isAlgorithm(key.algorithm, "RSA-PSS"))
            throw unusable("RSA-PSS");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case (isCloudflareWorkers() && "EdDSA"): {
          if (!isAlgorithm(key.algorithm, "NODE-ED25519"))
            throw unusable("NODE-ED25519");
          break;
        }
        case "ES256":
        case "ES384":
        case "ES512": {
          if (!isAlgorithm(key.algorithm, "ECDSA"))
            throw unusable("ECDSA");
          const expected = getNamedCurve(alg);
          const actual = key.algorithm.namedCurve;
          if (actual !== expected)
            throw unusable(expected, "algorithm.namedCurve");
          break;
        }
        default:
          throw new TypeError("CryptoKey does not support this operation");
      }
      checkUsage(key, usages);
    }
    const invalidKeyInput = (actual, ...types2) => {
      let msg = "Key must be ";
      if (types2.length > 2) {
        const last = types2.pop();
        msg += `one of type ${types2.join(", ")}, or ${last}.`;
      } else if (types2.length === 2) {
        msg += `one of type ${types2[0]} or ${types2[1]}.`;
      } else {
        msg += `of type ${types2[0]}.`;
      }
      if (actual == null) {
        msg += ` Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += ` Received function ${actual.name}`;
      } else if (typeof actual === "object" && actual != null) {
        if (actual.constructor && actual.constructor.name) {
          msg += ` Received an instance of ${actual.constructor.name}`;
        }
      }
      return msg;
    };
    const isKeyLike = (key) => {
      return isCryptoKey(key);
    };
    const types = ["CryptoKey"];
    const isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    const isDisjoint$1 = isDisjoint;
    function isObjectLike$2(value) {
      return typeof value === "object" && value !== null;
    }
    function isObject$5(input) {
      if (!isObjectLike$2(input) || Object.prototype.toString.call(input) !== "[object Object]") {
        return false;
      }
      if (Object.getPrototypeOf(input) === null) {
        return true;
      }
      let proto = input;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(input) === proto;
    }
    const checkKeyLength = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
    function subtleMapping(jwk) {
      let algorithm;
      let keyUsages;
      switch (jwk.kty) {
        case "oct": {
          switch (jwk.alg) {
            case "HS256":
            case "HS384":
            case "HS512":
              algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
              keyUsages = ["sign", "verify"];
              break;
            case "A128CBC-HS256":
            case "A192CBC-HS384":
            case "A256CBC-HS512":
              throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
            case "A128GCM":
            case "A192GCM":
            case "A256GCM":
            case "A128GCMKW":
            case "A192GCMKW":
            case "A256GCMKW":
              algorithm = { name: "AES-GCM" };
              keyUsages = ["encrypt", "decrypt"];
              break;
            case "A128KW":
            case "A192KW":
            case "A256KW":
              algorithm = { name: "AES-KW" };
              keyUsages = ["wrapKey", "unwrapKey"];
              break;
            case "PBES2-HS256+A128KW":
            case "PBES2-HS384+A192KW":
            case "PBES2-HS512+A256KW":
              algorithm = { name: "PBKDF2" };
              keyUsages = ["deriveBits"];
              break;
            default:
              throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
          }
          break;
        }
        case "RSA": {
          switch (jwk.alg) {
            case "PS256":
            case "PS384":
            case "PS512":
              algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
              keyUsages = jwk.d ? ["sign"] : ["verify"];
              break;
            case "RS256":
            case "RS384":
            case "RS512":
              algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
              keyUsages = jwk.d ? ["sign"] : ["verify"];
              break;
            case "RSA-OAEP":
            case "RSA-OAEP-256":
            case "RSA-OAEP-384":
            case "RSA-OAEP-512":
              algorithm = {
                name: "RSA-OAEP",
                hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
              };
              keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
              break;
            default:
              throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
          }
          break;
        }
        case "EC": {
          switch (jwk.alg) {
            case "ES256":
              algorithm = { name: "ECDSA", namedCurve: "P-256" };
              keyUsages = jwk.d ? ["sign"] : ["verify"];
              break;
            case "ES384":
              algorithm = { name: "ECDSA", namedCurve: "P-384" };
              keyUsages = jwk.d ? ["sign"] : ["verify"];
              break;
            case "ES512":
              algorithm = { name: "ECDSA", namedCurve: "P-521" };
              keyUsages = jwk.d ? ["sign"] : ["verify"];
              break;
            case "ECDH-ES":
            case "ECDH-ES+A128KW":
            case "ECDH-ES+A192KW":
            case "ECDH-ES+A256KW":
              algorithm = { name: "ECDH", namedCurve: jwk.crv };
              keyUsages = jwk.d ? ["deriveBits"] : [];
              break;
            default:
              throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
          }
          break;
        }
        case (isCloudflareWorkers() && "OKP"):
          if (jwk.alg !== "EdDSA") {
            throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
          }
          switch (jwk.crv) {
            case "Ed25519":
              algorithm = { name: "NODE-ED25519", namedCurve: "NODE-ED25519" };
              keyUsages = jwk.d ? ["sign"] : ["verify"];
              break;
            default:
              throw new JOSENotSupported('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value');
          }
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
      }
      return { algorithm, keyUsages };
    }
    const parse = async (jwk) => {
      var _a, _b;
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
      ];
      if (algorithm.name === "PBKDF2") {
        return crypto$1.subtle.importKey("raw", decode$1(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      return crypto$1.subtle.importKey("jwk", keyData, ...rest);
    };
    const asKeyObject = parse;
    async function importJWK(jwk, alg, octAsKeyObject) {
      if (!isObject$5(jwk)) {
        throw new TypeError("JWK must be an object");
      }
      alg || (alg = jwk.alg);
      if (typeof alg !== "string" || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      switch (jwk.kty) {
        case "oct":
          if (typeof jwk.k !== "string" || !jwk.k) {
            throw new TypeError('missing "k" (Key Value) Parameter value');
          }
          octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
          if (octAsKeyObject) {
            return asKeyObject({ ...jwk, alg, ext: false });
          }
          return decode$1(jwk.k);
        case "RSA":
          if (jwk.oth !== void 0) {
            throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
          }
        case "EC":
        case "OKP":
          return asKeyObject({ ...jwk, alg });
        default:
          throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
      }
    }
    const symmetricTypeCheck = (key) => {
      if (key instanceof Uint8Array)
        return;
      if (!isKeyLike(key)) {
        throw new TypeError(invalidKeyInput(key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    const asymmetricTypeCheck = (key, usage) => {
      if (!isKeyLike(key)) {
        throw new TypeError(invalidKeyInput(key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    const checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(key);
      } else {
        asymmetricTypeCheck(key, usage);
      }
    };
    const checkKeyType$1 = checkKeyType;
    function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
      if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
      }
      if (!protectedHeader || protectedHeader.crit === void 0) {
        return /* @__PURE__ */ new Set();
      }
      if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
      }
      let recognized;
      if (recognizedOption !== void 0) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
      } else {
        recognized = recognizedDefault;
      }
      for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
          throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === void 0) {
          throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
          throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
      }
      return new Set(protectedHeader.crit);
    }
    const validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    const validateAlgorithms$1 = validateAlgorithms;
    function subtleDsa(alg, algorithm) {
      const hash2 = `SHA-${alg.slice(-3)}`;
      switch (alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          return { hash: hash2, name: "HMAC" };
        case "PS256":
        case "PS384":
        case "PS512":
          return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
        case "RS256":
        case "RS384":
        case "RS512":
          return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
        case "ES256":
        case "ES384":
        case "ES512":
          return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
        case (isCloudflareWorkers() && "EdDSA"):
          const { namedCurve } = algorithm;
          return { name: namedCurve, namedCurve };
        default:
          throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    function getCryptoKey(alg, key, usage) {
      if (isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return key;
      }
      if (key instanceof Uint8Array) {
        if (!alg.startsWith("HS")) {
          throw new TypeError(invalidKeyInput(key, ...types));
        }
        return crypto$1.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
      }
      throw new TypeError(invalidKeyInput(key, ...types, "Uint8Array"));
    }
    const verify = async (alg, key, signature, data2) => {
      const cryptoKey = await getCryptoKey(alg, key, "verify");
      checkKeyLength(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await crypto$1.subtle.verify(algorithm, cryptoKey, signature, data2);
      } catch (_a) {
        return false;
      }
    };
    const verify$1 = verify;
    async function flattenedVerify(jws, key, options) {
      var _a;
      if (!isObject$5(jws)) {
        throw new JWSInvalid("Flattened JWS must be an object");
      }
      if (jws.protected === void 0 && jws.header === void 0) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
      }
      if (jws.protected !== void 0 && typeof jws.protected !== "string") {
        throw new JWSInvalid("JWS Protected Header incorrect type");
      }
      if (jws.payload === void 0) {
        throw new JWSInvalid("JWS Payload missing");
      }
      if (typeof jws.signature !== "string") {
        throw new JWSInvalid("JWS Signature missing or incorrect type");
      }
      if (jws.header !== void 0 && !isObject$5(jws.header)) {
        throw new JWSInvalid("JWS Unprotected Header incorrect type");
      }
      let parsedProt = {};
      if (jws.protected) {
        const protectedHeader = decode$1(jws.protected);
        try {
          parsedProt = JSON.parse(decoder.decode(protectedHeader));
        } catch (_b) {
          throw new JWSInvalid("JWS Protected Header is invalid");
        }
      }
      if (!isDisjoint$1(parsedProt, jws.header)) {
        throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...parsedProt,
        ...jws.header
      };
      const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
      let b64 = true;
      if (extensions.has("b64")) {
        b64 = parsedProt.b64;
        if (typeof b64 !== "boolean") {
          throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
      }
      const { alg } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
      }
      const algorithms = options && validateAlgorithms$1("algorithms", options.algorithms);
      if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
      }
      if (b64) {
        if (typeof jws.payload !== "string") {
          throw new JWSInvalid("JWS Payload must be a string");
        }
      } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
      }
      let resolvedKey = false;
      if (typeof key === "function") {
        key = await key(parsedProt, jws);
        resolvedKey = true;
      }
      checkKeyType$1(alg, key, "verify");
      const data2 = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
      const signature = decode$1(jws.signature);
      const verified = await verify$1(alg, key, signature, data2);
      if (!verified) {
        throw new JWSSignatureVerificationFailed();
      }
      let payload;
      if (b64) {
        payload = decode$1(jws.payload);
      } else if (typeof jws.payload === "string") {
        payload = encoder.encode(jws.payload);
      } else {
        payload = jws.payload;
      }
      const result = { payload };
      if (jws.protected !== void 0) {
        result.protectedHeader = parsedProt;
      }
      if (jws.header !== void 0) {
        result.unprotectedHeader = jws.header;
      }
      if (resolvedKey) {
        return { ...result, key };
      }
      return result;
    }
    async function compactVerify(jws, key, options) {
      if (jws instanceof Uint8Array) {
        jws = decoder.decode(jws);
      }
      if (typeof jws !== "string") {
        throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
      }
      const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
      if (length !== 3) {
        throw new JWSInvalid("Invalid Compact JWS");
      }
      const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
      const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: verified.key };
      }
      return result;
    }
    const epoch = (date) => Math.floor(date.getTime() / 1e3);
    const minute = 60;
    const hour = minute * 60;
    const day = hour * 24;
    const week = day * 7;
    const year = day * 365.25;
    const REGEX$1 = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    const secs = (str) => {
      const matched = REGEX$1.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
    const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    const checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    const jwtPayload = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch (_a) {
      }
      if (!isObject$5(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { issuer } = options;
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      const { subject } = options;
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      const { audience } = options;
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now2 = epoch(currentDate || new Date());
      if ((payload.iat !== void 0 || options.maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now2 + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now2 - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (options.maxTokenAge) {
        const age = now2 - payload.iat;
        const max2 = typeof options.maxTokenAge === "number" ? options.maxTokenAge : secs(options.maxTokenAge);
        if (age - tolerance > max2) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
    async function jwtVerify(jwt, key, options) {
      var _a;
      const verified = await compactVerify(jwt, key, options);
      if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
      }
      const payload = jwtPayload(verified.protectedHeader, verified.payload, options);
      const result = { payload, protectedHeader: verified.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: verified.key };
      }
      return result;
    }
    function getKtyFromAlg(alg) {
      switch (typeof alg === "string" && alg.slice(0, 2)) {
        case "RS":
        case "PS":
          return "RSA";
        case "ES":
          return "EC";
        case "Ed":
          return "OKP";
        default:
          throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
      }
    }
    function isJWKSLike(jwks) {
      return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
    }
    function isJWKLike(key) {
      return isObject$5(key);
    }
    function clone$1(obj) {
      if (typeof structuredClone === "function") {
        return structuredClone(obj);
      }
      return JSON.parse(JSON.stringify(obj));
    }
    class LocalJWKSet {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone$1(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
          throw new JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[alg] === void 0) {
          const keyObject = await importJWK({ ...jwk, ext: true }, alg);
          if (keyObject instanceof Uint8Array || keyObject.type !== "public") {
            throw new JWKSInvalid("JSON Web Key Set members must be public keys");
          }
          cached[alg] = keyObject;
        }
        return cached[alg];
      }
    }
    const fetchJwks = async (url, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch (_a) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    const fetchJwks$1 = fetchJwks;
    class RemoteJWKSet extends LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          return new Promise((resolve2) => {
            const isDone = () => {
              if (this._pendingFetch === void 0) {
                resolve2();
              } else {
                setTimeout(isDone, 5);
              }
            };
            isDone();
          });
        }
        if (!this._pendingFetch) {
          this._pendingFetch = fetchJwks$1(this._url, this._timeoutDuration, this._options).then((json) => {
            if (!isJWKSLike(json)) {
              throw new JWKSInvalid("JSON Web Key Set malformed");
            }
            this._jwks = { keys: json.keys };
            this._jwksTimestamp = Date.now();
            this._pendingFetch = void 0;
          }).catch((err) => {
            this._pendingFetch = void 0;
            throw err;
          });
        }
        await this._pendingFetch;
      }
    }
    function createRemoteJWKSet(url, options) {
      return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
    }
    function $parcel$exportWildcard(dest, source) {
      Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) {
          return;
        }
        Object.defineProperty(dest, key, {
          enumerable: true,
          get: function get2() {
            return source[key];
          }
        });
      });
      return dest;
    }
    function $parcel$export$1(e, n, v, s) {
      Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
    }
    var $1eda3e9ea5865065$exports = {};
    var $ce6f2a62716522ae$exports = {};
    $parcel$export$1($ce6f2a62716522ae$exports, "fetchTokenByAuthorizationCode", () => $ce6f2a62716522ae$export$684f740cd70532d4);
    $parcel$export$1($ce6f2a62716522ae$exports, "fetchTokenByRefreshToken", () => $ce6f2a62716522ae$export$9909137b467efb8b);
    var $5422b71ae76f21f1$exports = {};
    $parcel$export$1($5422b71ae76f21f1$exports, "ContentType", () => $5422b71ae76f21f1$export$e2e108cbe2e4f865);
    $parcel$export$1($5422b71ae76f21f1$exports, "TokenGrantType", () => $5422b71ae76f21f1$export$3f2aafdd1ccae76c);
    $parcel$export$1($5422b71ae76f21f1$exports, "QueryKey", () => $5422b71ae76f21f1$export$65f63a8bc3cba53d);
    $parcel$export$1($5422b71ae76f21f1$exports, "Prompt", () => $5422b71ae76f21f1$export$83716a4aa1642908);
    const $5422b71ae76f21f1$export$e2e108cbe2e4f865 = {
      formUrlEncoded: {
        "Content-Type": "application/x-www-form-urlencoded"
      }
    };
    let $5422b71ae76f21f1$export$3f2aafdd1ccae76c;
    (function(TokenGrantType1) {
      TokenGrantType1["AuthorizationCode"] = "authorization_code";
      TokenGrantType1["RefreshToken"] = "refresh_token";
    })($5422b71ae76f21f1$export$3f2aafdd1ccae76c || ($5422b71ae76f21f1$export$3f2aafdd1ccae76c = {}));
    let $5422b71ae76f21f1$export$65f63a8bc3cba53d;
    (function(QueryKey1) {
      QueryKey1["ClientId"] = "client_id";
      QueryKey1["Code"] = "code";
      QueryKey1["CodeChallenge"] = "code_challenge";
      QueryKey1["CodeChallengeMethod"] = "code_challenge_method";
      QueryKey1["CodeVerifier"] = "code_verifier";
      QueryKey1["Error"] = "error";
      QueryKey1["ErrorDescription"] = "error_description";
      QueryKey1["GrantType"] = "grant_type";
      QueryKey1["IdToken"] = "id_token";
      QueryKey1["IdTokenHint"] = "id_token_hint";
      QueryKey1["PostLogoutRedirectUri"] = "post_logout_redirect_uri";
      QueryKey1["Prompt"] = "prompt";
      QueryKey1["RedirectUri"] = "redirect_uri";
      QueryKey1["RefreshToken"] = "refresh_token";
      QueryKey1["Resource"] = "resource";
      QueryKey1["ResponseType"] = "response_type";
      QueryKey1["Scope"] = "scope";
      QueryKey1["State"] = "state";
      QueryKey1["Token"] = "token";
    })($5422b71ae76f21f1$export$65f63a8bc3cba53d || ($5422b71ae76f21f1$export$65f63a8bc3cba53d = {}));
    let $5422b71ae76f21f1$export$83716a4aa1642908;
    (function(Prompt1) {
      Prompt1["Consent"] = "consent";
      Prompt1["Login"] = "login";
    })($5422b71ae76f21f1$export$83716a4aa1642908 || ($5422b71ae76f21f1$export$83716a4aa1642908 = {}));
    const $ce6f2a62716522ae$export$684f740cd70532d4 = async ({ clientId, tokenEndpoint, redirectUri, codeVerifier, code, resource }, requester) => {
      const parameters = new URLSearchParams();
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.ClientId, clientId);
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.Code, code);
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.CodeVerifier, codeVerifier);
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.RedirectUri, redirectUri);
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.GrantType, $5422b71ae76f21f1$export$3f2aafdd1ccae76c.AuthorizationCode);
      if (resource)
        parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.Resource, resource);
      const snakeCaseCodeTokenResponse = await requester(tokenEndpoint, {
        method: "POST",
        headers: $5422b71ae76f21f1$export$e2e108cbe2e4f865.formUrlEncoded,
        body: parameters
      });
      return camelcaseKeys(snakeCaseCodeTokenResponse);
    };
    const $ce6f2a62716522ae$export$9909137b467efb8b = async ({ clientId, tokenEndpoint, refreshToken, resource, scopes }, requester) => {
      const parameters = new URLSearchParams();
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.ClientId, clientId);
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.RefreshToken, refreshToken);
      parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.GrantType, $5422b71ae76f21f1$export$3f2aafdd1ccae76c.RefreshToken);
      if (resource)
        parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.Resource, resource);
      if (scopes == null ? void 0 : scopes.length)
        parameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.Scope, scopes.join(" "));
      const snakeCaseRefreshTokenTokenResponse = await requester(tokenEndpoint, {
        method: "POST",
        headers: $5422b71ae76f21f1$export$e2e108cbe2e4f865.formUrlEncoded,
        body: parameters
      });
      return camelcaseKeys(snakeCaseRefreshTokenTokenResponse);
    };
    var $eefdbfea5ec3abd9$exports = {};
    $parcel$export$1($eefdbfea5ec3abd9$exports, "discoveryPath", () => $eefdbfea5ec3abd9$export$815bda5ead26b243);
    $parcel$export$1($eefdbfea5ec3abd9$exports, "fetchOidcConfig", () => $eefdbfea5ec3abd9$export$98242d8e822ad11f);
    const $eefdbfea5ec3abd9$export$815bda5ead26b243 = "/oidc/.well-known/openid-configuration";
    const $eefdbfea5ec3abd9$export$98242d8e822ad11f = async (endpoint, requester) => camelcaseKeys(await requester(endpoint));
    var $7397ba7739ada584$exports = {};
    $parcel$export$1($7397ba7739ada584$exports, "revoke", () => $7397ba7739ada584$export$573f8dbbf6fbef75);
    const $7397ba7739ada584$export$573f8dbbf6fbef75 = async (revocationEndpoint, clientId, token, requester) => requester(revocationEndpoint, {
      method: "POST",
      headers: $5422b71ae76f21f1$export$e2e108cbe2e4f865.formUrlEncoded,
      body: new URLSearchParams({
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.ClientId]: clientId,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.Token]: token
      })
    });
    var $bfba480b8ff41607$exports = {};
    $parcel$export$1($bfba480b8ff41607$exports, "generateSignInUri", () => $bfba480b8ff41607$export$b01a187f12b774c6);
    var $40555044b252dc61$exports = {};
    var $2cac19d9fad63bff$exports = {};
    $parcel$export$1($2cac19d9fad63bff$exports, "parseUriParameters", () => $2cac19d9fad63bff$export$4851e69315d5b72c);
    $parcel$export$1($2cac19d9fad63bff$exports, "verifyAndParseCodeFromCallbackUri", () => $2cac19d9fad63bff$export$dc3fae3c99763885);
    var $ab66c74b65acc6a3$exports = {};
    $parcel$export$1($ab66c74b65acc6a3$exports, "LogtoError", () => $ab66c74b65acc6a3$export$ba60d77e6748b659);
    $parcel$export$1($ab66c74b65acc6a3$exports, "logtoRequestErrorSchema", () => $ab66c74b65acc6a3$export$cccd51a00718f001);
    $parcel$export$1($ab66c74b65acc6a3$exports, "LogtoRequestError", () => $ab66c74b65acc6a3$export$e6e15b8ba42b9b70);
    $parcel$export$1($ab66c74b65acc6a3$exports, "OidcError", () => $ab66c74b65acc6a3$export$d4832bcf9ce430e0);
    const $ab66c74b65acc6a3$var$logtoErrorCodes = Object.freeze({
      id_token: {
        invalid_iat: "Invalid issued at time in the ID token",
        invalid_token: "Invalid ID token"
      },
      callback_uri_verification: {
        redirect_uri_mismatched: "The callback URI mismatches the redirect URI.",
        error_found: "Error found in the callback URI",
        missing_state: "Missing state in the callback URI",
        state_mismatched: "State mismatched in the callback URI",
        missing_code: "Missing code in the callback URI"
      },
      crypto_subtle_unavailable: "Crypto.subtle is unavailable in insecure contexts (non-HTTPS).",
      unexpected_response_error: "Unexpected response error from the server."
    });
    const $ab66c74b65acc6a3$var$getMessageByErrorCode = (errorCode) => {
      const message = lodash_get($ab66c74b65acc6a3$var$logtoErrorCodes, errorCode);
      if (typeof message === "string")
        return message;
      return errorCode;
    };
    class $ab66c74b65acc6a3$export$ba60d77e6748b659 extends Error {
      constructor(code, data2) {
        super($ab66c74b65acc6a3$var$getMessageByErrorCode(code));
        this.code = code;
        this.data = data2;
      }
    }
    const $ab66c74b65acc6a3$export$cccd51a00718f001 = type({
      code: string(),
      message: string()
    });
    class $ab66c74b65acc6a3$export$e6e15b8ba42b9b70 extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
      }
    }
    class $ab66c74b65acc6a3$export$d4832bcf9ce430e0 {
      constructor(error, errorDescription) {
        this.error = error;
        this.errorDescription = errorDescription;
      }
    }
    const $2cac19d9fad63bff$export$4851e69315d5b72c = (uri) => {
      const [, queryString = ""] = uri.split("?");
      return new URLSearchParams(queryString);
    };
    const $2cac19d9fad63bff$export$dc3fae3c99763885 = (callbackUri, redirectUri, state) => {
      if (!callbackUri.startsWith(redirectUri))
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("callback_uri_verification.redirect_uri_mismatched");
      const uriParameters = $2cac19d9fad63bff$export$4851e69315d5b72c(callbackUri);
      const error = lib.conditional(uriParameters.get($5422b71ae76f21f1$export$65f63a8bc3cba53d.Error));
      const errorDescription = lib.conditional(uriParameters.get($5422b71ae76f21f1$export$65f63a8bc3cba53d.ErrorDescription));
      if (error)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("callback_uri_verification.error_found", new $ab66c74b65acc6a3$export$d4832bcf9ce430e0(error, errorDescription));
      const stateFromCallbackUri = uriParameters.get($5422b71ae76f21f1$export$65f63a8bc3cba53d.State);
      if (!stateFromCallbackUri)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("callback_uri_verification.missing_state");
      if (stateFromCallbackUri !== state)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("callback_uri_verification.state_mismatched");
      const code = uriParameters.get($5422b71ae76f21f1$export$65f63a8bc3cba53d.Code);
      if (!code)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("callback_uri_verification.missing_code");
      return code;
    };
    var $dfd50234d3585f12$exports = {};
    $parcel$export$1($dfd50234d3585f12$exports, "verifyIdToken", () => $dfd50234d3585f12$export$b5b3317c8aecbcd5);
    $parcel$export$1($dfd50234d3585f12$exports, "decodeIdToken", () => $dfd50234d3585f12$export$aac2d5b7f5cd16d5);
    const $dfd50234d3585f12$var$issuedAtTimeTolerance = 60;
    const $dfd50234d3585f12$var$IdTokenClaimsSchema = type({
      iss: string(),
      sub: string(),
      aud: string(),
      exp: number(),
      iat: number(),
      at_hash: nullable(optional(string())),
      name: nullable(optional(string())),
      username: nullable(optional(string())),
      avatar: nullable(optional(string())),
      role_names: nullable(optional(array(string())))
    });
    const $dfd50234d3585f12$export$b5b3317c8aecbcd5 = async (idToken, clientId, issuer, jwks) => {
      var _a;
      const result = await jwtVerify(idToken, jwks, {
        audience: clientId,
        issuer
      });
      if (Math.abs(((_a = result.payload.iat) != null ? _a : 0) - Date.now() / 1e3) > $dfd50234d3585f12$var$issuedAtTimeTolerance)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("id_token.invalid_iat");
    };
    const $dfd50234d3585f12$export$aac2d5b7f5cd16d5 = (token) => {
      const { 1: encodedPayload } = token.split(".");
      if (!encodedPayload)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("id_token.invalid_token");
      const json = lib.UrlSafeBase64.decode(encodedPayload);
      const idTokenClaims = JSON.parse(json);
      assert(idTokenClaims, $dfd50234d3585f12$var$IdTokenClaimsSchema);
      return idTokenClaims;
    };
    var $570e2e6b31a027ff$exports = {};
    $parcel$export$1($570e2e6b31a027ff$exports, "withReservedScopes", () => $570e2e6b31a027ff$export$887ed125f549a57);
    const $570e2e6b31a027ff$export$887ed125f549a57 = (originalScopes) => {
      const uniqueScopes = /* @__PURE__ */ new Set([
        "openid",
        "offline_access",
        "profile",
        ...originalScopes != null ? originalScopes : []
      ]);
      return Array.from(uniqueScopes).join(" ");
    };
    $parcel$exportWildcard($40555044b252dc61$exports, $2cac19d9fad63bff$exports);
    $parcel$exportWildcard($40555044b252dc61$exports, $ab66c74b65acc6a3$exports);
    $parcel$exportWildcard($40555044b252dc61$exports, $dfd50234d3585f12$exports);
    $parcel$exportWildcard($40555044b252dc61$exports, $570e2e6b31a027ff$exports);
    const $bfba480b8ff41607$var$codeChallengeMethod = "S256";
    const $bfba480b8ff41607$var$responseType = "code";
    const $bfba480b8ff41607$export$b01a187f12b774c6 = ({ authorizationEndpoint, clientId, redirectUri, codeChallenge, state, scopes, resources, prompt }) => {
      const urlSearchParameters = new URLSearchParams({
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.ClientId]: clientId,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.RedirectUri]: redirectUri,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.CodeChallenge]: codeChallenge,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.CodeChallengeMethod]: $bfba480b8ff41607$var$codeChallengeMethod,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.State]: state,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.ResponseType]: $bfba480b8ff41607$var$responseType,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.Prompt]: prompt != null ? prompt : $5422b71ae76f21f1$export$83716a4aa1642908.Consent,
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.Scope]: $570e2e6b31a027ff$export$887ed125f549a57(scopes)
      });
      for (const resource of resources != null ? resources : [])
        urlSearchParameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.Resource, resource);
      return `${authorizationEndpoint}?${urlSearchParameters.toString()}`;
    };
    var $fcccd93c698efc4f$exports = {};
    $parcel$export$1($fcccd93c698efc4f$exports, "generateSignOutUri", () => $fcccd93c698efc4f$export$b3c9a2bd2330de28);
    const $fcccd93c698efc4f$export$b3c9a2bd2330de28 = ({ endSessionEndpoint, idToken, postLogoutRedirectUri }) => {
      const urlSearchParameters = new URLSearchParams({
        [$5422b71ae76f21f1$export$65f63a8bc3cba53d.IdTokenHint]: idToken
      });
      if (postLogoutRedirectUri)
        urlSearchParameters.append($5422b71ae76f21f1$export$65f63a8bc3cba53d.PostLogoutRedirectUri, postLogoutRedirectUri);
      return `${endSessionEndpoint}?${urlSearchParameters.toString()}`;
    };
    $parcel$exportWildcard($1eda3e9ea5865065$exports, $ce6f2a62716522ae$exports);
    $parcel$exportWildcard($1eda3e9ea5865065$exports, $eefdbfea5ec3abd9$exports);
    $parcel$exportWildcard($1eda3e9ea5865065$exports, $7397ba7739ada584$exports);
    $parcel$exportWildcard($1eda3e9ea5865065$exports, $bfba480b8ff41607$exports);
    $parcel$exportWildcard($1eda3e9ea5865065$exports, $fcccd93c698efc4f$exports);
    var FUNC_ERROR_TEXT$3 = "Expected a function";
    var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN$1 = 0 / 0;
    var symbolTag$3 = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary$1 = /^0b[01]+$/i;
    var reIsOctal$1 = /^0o[0-7]+$/i;
    var freeParseInt$1 = parseInt;
    var objectProto$e = Object.prototype;
    var objectToString$2 = objectProto$e.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$3);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject$4(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike$1(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol$3(value) {
      return typeof value == "symbol" || isObjectLike$1(value) && objectToString$2.call(value) == symbolTag$3;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber$1(value);
      if (value === INFINITY$2 || value === -INFINITY$2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber$1(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol$3(value)) {
        return NAN$1;
      }
      if (isObject$4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary$1.test(value);
      return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
    }
    var lodash_once = once;
    function $parcel$export(e, n, v, s) {
      Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
    }
    var $4ec05cedcef20733$exports = {};
    $parcel$export($4ec05cedcef20733$exports, "LogtoClientError", () => $4ec05cedcef20733$export$877962ca249b8fc8);
    const $4ec05cedcef20733$var$logtoClientErrorCodes = Object.freeze({
      sign_in_session: {
        invalid: "Invalid sign-in session.",
        not_found: "Sign-in session not found."
      },
      not_authenticated: "Not authenticated.",
      get_access_token_by_refresh_token_failed: "Failed to get access token by refresh token.",
      invalid_id_token: "Invalid id token."
    });
    const $4ec05cedcef20733$var$getMessageByErrorCode = (errorCode) => {
      const message = lodash_get($4ec05cedcef20733$var$logtoClientErrorCodes, errorCode);
      if (typeof message === "string")
        return message;
      return errorCode;
    };
    class $4ec05cedcef20733$export$877962ca249b8fc8 extends Error {
      constructor(code, data2) {
        super($4ec05cedcef20733$var$getMessageByErrorCode(code));
        this.code = code;
        this.data = data2;
      }
    }
    var $50f2bb780a45e70c$exports = {};
    $parcel$export($50f2bb780a45e70c$exports, "AccessTokenSchema", () => $50f2bb780a45e70c$export$77bdbaff506443f4);
    $parcel$export($50f2bb780a45e70c$exports, "LogtoSignInSessionItemSchema", () => $50f2bb780a45e70c$export$7b65a75f516b80e1);
    $parcel$export($50f2bb780a45e70c$exports, "LogtoAccessTokenMapSchema", () => $50f2bb780a45e70c$export$4ae7b9c313038df5);
    const $50f2bb780a45e70c$export$77bdbaff506443f4 = type({
      token: string(),
      scope: string(),
      expiresAt: number()
    });
    const $50f2bb780a45e70c$export$7b65a75f516b80e1 = type({
      redirectUri: string(),
      codeVerifier: string(),
      state: string()
    });
    const $50f2bb780a45e70c$export$4ae7b9c313038df5 = record(string(), $50f2bb780a45e70c$export$77bdbaff506443f4);
    const $8449a5dbad0d6387$export$8d54726fdbf08e0a = (fetchFunction) => {
      return async (...args) => {
        const response = await fetchFunction(...args);
        if (!response.ok) {
          const responseJson = await response.json();
          if (!$ab66c74b65acc6a3$export$cccd51a00718f001.is(responseJson))
            throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("unexpected_response_error", responseJson);
          const { code, message } = responseJson;
          throw new $ab66c74b65acc6a3$export$e6e15b8ba42b9b70(code, message);
        }
        return response.json();
      };
    };
    const $dcfd5d64758ae70b$export$8f595bd2a47bcea6 = (resource = "", scopes = []) => `${scopes.slice().sort().join(" ")}@${resource}`;
    const $dcfd5d64758ae70b$export$5d9c34f69c80822b = (endpoint) => new URL($eefdbfea5ec3abd9$export$815bda5ead26b243, endpoint).toString();
    class $19775a679e2952df$export$2e2bcd8739ae039 {
      constructor(logtoConfig, adapter) {
        __publicField(this, "getOidcConfig", lodash_once(this._getOidcConfig));
        __publicField(this, "getJwtVerifyGetKey", lodash_once(this._getJwtVerifyGetKey));
        __publicField(this, "accessTokenMap", /* @__PURE__ */ new Map());
        __publicField(this, "getAccessTokenPromiseMap", /* @__PURE__ */ new Map());
        var _a;
        this.logtoConfig = {
          ...logtoConfig,
          prompt: (_a = logtoConfig.prompt) != null ? _a : $5422b71ae76f21f1$export$83716a4aa1642908.Consent,
          scopes: $570e2e6b31a027ff$export$887ed125f549a57(logtoConfig.scopes).split(" ")
        };
        this.adapter = adapter;
        this._idToken = this.adapter.storage.getItem("idToken");
        if (this.logtoConfig.persistAccessToken)
          this.loadAccessTokenMap();
      }
      get isAuthenticated() {
        return Boolean(this.idToken);
      }
      get signInSession() {
        const jsonItem = this.adapter.storage.getItem("signInSession");
        if (!jsonItem)
          return null;
        try {
          const item = JSON.parse(jsonItem);
          (0, assert)(item, (0, $50f2bb780a45e70c$export$7b65a75f516b80e1));
          return item;
        } catch (error) {
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("sign_in_session.invalid", error);
        }
      }
      set signInSession(logtoSignInSessionItem) {
        if (!logtoSignInSessionItem) {
          this.adapter.storage.removeItem("signInSession");
          return;
        }
        const jsonItem = JSON.stringify(logtoSignInSessionItem);
        this.adapter.storage.setItem("signInSession", jsonItem);
      }
      get refreshToken() {
        return this.adapter.storage.getItem("refreshToken");
      }
      set refreshToken(refreshToken) {
        if (!refreshToken) {
          this.adapter.storage.removeItem("refreshToken");
          return;
        }
        this.adapter.storage.setItem("refreshToken", refreshToken);
      }
      get idToken() {
        return this._idToken;
      }
      set idToken(idToken) {
        this._idToken = idToken;
        if (!idToken) {
          this.adapter.storage.removeItem("idToken");
          return;
        }
        this.adapter.storage.setItem("idToken", idToken);
      }
      async getAccessToken(resource) {
        if (!this.idToken)
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("not_authenticated");
        const accessTokenKey = $dcfd5d64758ae70b$export$8f595bd2a47bcea6(resource);
        const accessToken = this.accessTokenMap.get(accessTokenKey);
        if (accessToken && accessToken.expiresAt > Date.now() / 1e3)
          return accessToken.token;
        if (accessToken)
          this.accessTokenMap.delete(accessTokenKey);
        const cachedPromise = this.getAccessTokenPromiseMap.get(accessTokenKey);
        if (cachedPromise)
          return cachedPromise;
        const promise = this.getAccessTokenByRefreshToken(resource);
        this.getAccessTokenPromiseMap.set(accessTokenKey, promise);
        const token = await promise;
        this.getAccessTokenPromiseMap.delete(accessTokenKey);
        return token;
      }
      getIdTokenClaims() {
        if (!this.idToken)
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("not_authenticated");
        return $dfd50234d3585f12$export$aac2d5b7f5cd16d5(this.idToken);
      }
      async signIn(redirectUri) {
        const { appId: clientId, prompt, resources, scopes } = this.logtoConfig;
        const { authorizationEndpoint } = await this.getOidcConfig();
        const codeVerifier = this.adapter.generateCodeVerifier();
        const codeChallenge = await this.adapter.generateCodeChallenge(codeVerifier);
        const state = this.adapter.generateState();
        const signInUri = $bfba480b8ff41607$export$b01a187f12b774c6({
          authorizationEndpoint,
          clientId,
          redirectUri,
          codeChallenge,
          state,
          scopes,
          resources,
          prompt
        });
        this.signInSession = {
          redirectUri,
          codeVerifier,
          state
        };
        this.refreshToken = null;
        this.idToken = null;
        this.adapter.navigate(signInUri);
      }
      isSignInRedirected(url) {
        const { signInSession } = this;
        if (!signInSession)
          return false;
        const { redirectUri } = signInSession;
        const { origin, pathname } = new URL(url);
        return `${origin}${pathname}` === redirectUri;
      }
      async handleSignInCallback(callbackUri) {
        const { signInSession, logtoConfig, adapter } = this;
        const { requester } = adapter;
        if (!signInSession)
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("sign_in_session.not_found");
        const { redirectUri, state, codeVerifier } = signInSession;
        const code = $2cac19d9fad63bff$export$dc3fae3c99763885(callbackUri, redirectUri, state);
        const { appId: clientId } = logtoConfig;
        const { tokenEndpoint } = await this.getOidcConfig();
        const codeTokenResponse = await $ce6f2a62716522ae$export$684f740cd70532d4({
          clientId,
          tokenEndpoint,
          redirectUri,
          codeVerifier,
          code
        }, requester);
        await this.verifyIdToken(codeTokenResponse.idToken);
        this.saveCodeToken(codeTokenResponse);
        this.signInSession = null;
      }
      async signOut(postLogoutRedirectUri) {
        if (!this.idToken)
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("not_authenticated");
        const { appId: clientId } = this.logtoConfig;
        const { endSessionEndpoint, revocationEndpoint } = await this.getOidcConfig();
        if (this.refreshToken)
          try {
            await (0, $7397ba7739ada584$export$573f8dbbf6fbef75)(revocationEndpoint, clientId, this.refreshToken, this.adapter.requester);
          } catch {
          }
        const url = $fcccd93c698efc4f$export$b3c9a2bd2330de28({
          endSessionEndpoint,
          postLogoutRedirectUri,
          idToken: this.idToken
        });
        this.accessTokenMap.clear();
        this.refreshToken = null;
        this.idToken = null;
        this.adapter.navigate(url);
      }
      async getAccessTokenByRefreshToken(resource) {
        if (!this.refreshToken)
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("not_authenticated");
        try {
          const accessTokenKey = (0, $dcfd5d64758ae70b$export$8f595bd2a47bcea6)(resource);
          const { appId: clientId } = this.logtoConfig;
          const { tokenEndpoint } = await this.getOidcConfig();
          const { accessToken, refreshToken, idToken, scope, expiresIn } = await (0, $ce6f2a62716522ae$export$9909137b467efb8b)({
            clientId,
            tokenEndpoint,
            refreshToken: this.refreshToken,
            resource,
            scopes: resource ? [
              "offline_access"
            ] : void 0
          }, this.adapter.requester);
          this.accessTokenMap.set(accessTokenKey, {
            token: accessToken,
            scope,
            expiresAt: Math.round(Date.now() / 1e3) + expiresIn
          });
          this.saveAccessTokenMap();
          this.refreshToken = refreshToken;
          if (idToken) {
            await this.verifyIdToken(idToken);
            this.idToken = idToken;
          }
          return accessToken;
        } catch (error) {
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("get_access_token_by_refresh_token_failed", error);
        }
      }
      async _getOidcConfig() {
        const { endpoint } = this.logtoConfig;
        const discoveryEndpoint = $dcfd5d64758ae70b$export$5d9c34f69c80822b(endpoint);
        return $eefdbfea5ec3abd9$export$98242d8e822ad11f(discoveryEndpoint, this.adapter.requester);
      }
      async _getJwtVerifyGetKey() {
        const { jwksUri } = await this.getOidcConfig();
        return createRemoteJWKSet(new URL(jwksUri));
      }
      async verifyIdToken(idToken) {
        const { appId } = this.logtoConfig;
        const { issuer } = await this.getOidcConfig();
        const jwtVerifyGetKey = await this.getJwtVerifyGetKey();
        try {
          await (0, $dfd50234d3585f12$export$b5b3317c8aecbcd5)(idToken, appId, issuer, jwtVerifyGetKey);
        } catch (error) {
          throw new $4ec05cedcef20733$export$877962ca249b8fc8("invalid_id_token", error);
        }
      }
      saveCodeToken({ refreshToken, idToken, scope, accessToken, expiresIn }) {
        this.refreshToken = refreshToken != null ? refreshToken : null;
        this.idToken = idToken;
        const accessTokenKey = $dcfd5d64758ae70b$export$8f595bd2a47bcea6();
        const expiresAt = Date.now() / 1e3 + expiresIn;
        this.accessTokenMap.set(accessTokenKey, {
          token: accessToken,
          scope,
          expiresAt
        });
        this.saveAccessTokenMap();
      }
      saveAccessTokenMap() {
        if (!this.logtoConfig.persistAccessToken)
          return;
        const data2 = {};
        for (const [key, accessToken] of this.accessTokenMap.entries())
          data2[key] = accessToken;
        this.adapter.storage.setItem("accessToken", JSON.stringify(data2));
      }
      loadAccessTokenMap() {
        const raw = this.adapter.storage.getItem("accessToken");
        if (!raw)
          return;
        try {
          const json = JSON.parse(raw);
          (0, assert)(json, (0, $50f2bb780a45e70c$export$4ae7b9c313038df5));
          this.accessTokenMap.clear();
          for (const [key, accessToken] of Object.entries(json))
            this.accessTokenMap.set(key, accessToken);
        } catch {
        }
      }
    }
    const _hasbtoa = typeof btoa === "function";
    const _hasBuffer = typeof Buffer === "function";
    typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    const b64chs = Array.prototype.slice.call(b64ch);
    ((a) => {
      let tab = {};
      a.forEach((c, i2) => tab[c] = i2);
      return tab;
    })(b64chs);
    const _fromCC = String.fromCharCode.bind(String);
    typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
    const _mkUriSafe = (src2) => src2.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
    const btoaPolyfill = (bin) => {
      let u32, c0, c1, c2, asc = "";
      const pad = bin.length % 3;
      for (let i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    const _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
    const _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
      const maxargs = 4096;
      let strs = [];
      for (let i2 = 0, l = u8a.length; i2 < l; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    const $283691d41cf73b69$export$9b5c2da5fe7b4b2b = `logto`;
    class $283691d41cf73b69$export$2baa60fa09b100be {
      constructor(appId) {
        this.storageKey = `${$283691d41cf73b69$export$9b5c2da5fe7b4b2b}:${appId}`;
      }
      getItem(key) {
        if (key === "signInSession")
          return sessionStorage.getItem(this.storageKey);
        return localStorage.getItem(`${this.storageKey}:${key}`);
      }
      setItem(key, value) {
        if (key === "signInSession") {
          sessionStorage.setItem(this.storageKey, value);
          return;
        }
        localStorage.setItem(`${this.storageKey}:${key}`, value);
      }
      removeItem(key) {
        if (key === "signInSession") {
          sessionStorage.removeItem(this.storageKey);
          return;
        }
        localStorage.removeItem(`${this.storageKey}:${key}`);
      }
    }
    const $7faa35338215c9c1$var$generateRandomString = (length = 64) => fromUint8Array(crypto.getRandomValues(new Uint8Array(length)), true);
    const $7faa35338215c9c1$export$9ccd2716e53a229b = () => $7faa35338215c9c1$var$generateRandomString();
    const $7faa35338215c9c1$export$cf1891f923f5943a = () => $7faa35338215c9c1$var$generateRandomString();
    const $7faa35338215c9c1$export$414b01b1f867308a = async (codeVerifier) => {
      if (crypto.subtle === void 0)
        throw new $ab66c74b65acc6a3$export$ba60d77e6748b659("crypto_subtle_unavailable");
      const encodedCodeVerifier = new TextEncoder().encode(codeVerifier);
      const codeChallenge = new Uint8Array(await crypto.subtle.digest("SHA-256", encodedCodeVerifier));
      return fromUint8Array(codeChallenge, true);
    };
    const $90df2ab0e44b5eba$var$navigate = (url) => {
      window.location.assign(url);
    };
    class $90df2ab0e44b5eba$export$2e2bcd8739ae039 extends $19775a679e2952df$export$2e2bcd8739ae039 {
      constructor(config2) {
        const requester = $8449a5dbad0d6387$export$8d54726fdbf08e0a(fetch);
        super(config2, {
          requester,
          navigate: $90df2ab0e44b5eba$var$navigate,
          storage: new $283691d41cf73b69$export$2baa60fa09b100be(config2.appId),
          generateCodeChallenge: $7faa35338215c9c1$export$414b01b1f867308a,
          generateCodeVerifier: $7faa35338215c9c1$export$cf1891f923f5943a,
          generateState: $7faa35338215c9c1$export$9ccd2716e53a229b
        });
      }
    }
    const $cda0d5851de767d1$export$58f3af87e7a1a85a = "@logto/vue";
    const $cda0d5851de767d1$export$951b969b1220de04 = "@logto/vue:context";
    const $f63beecb5f2c2ea1$export$fd42f52fd3ae1109 = (client) => {
      const context = toRefs(reactive({
        logtoClient: client,
        isAuthenticated: client.isAuthenticated,
        loadingCount: 0,
        error: void 0
      }));
      const { isAuthenticated, loadingCount, error } = context;
      const isLoading1 = computed(() => loadingCount.value > 0);
      const setError = (_error, fallbackErrorMessage) => {
        if (_error instanceof Error)
          error.value = _error;
        else if (fallbackErrorMessage)
          error.value = new Error(fallbackErrorMessage);
        console.error(error);
      };
      const setLoading = (isLoading) => {
        if (isLoading)
          loadingCount.value += 1;
        else
          loadingCount.value = Math.max(0, loadingCount.value - 1);
      };
      const setIsAuthenticated = (_isAuthenticated) => {
        isAuthenticated.value = _isAuthenticated;
      };
      return {
        ...context,
        isLoading: isLoading1,
        setError,
        setLoading,
        setIsAuthenticated
      };
    };
    const $f63beecb5f2c2ea1$export$838ead842aa548e7 = () => {
      throw new Error("Must install Logto plugin first.");
    };
    const $eec30d751f04969b$export$6ad57c8ed6bec4 = (context) => {
      const { logtoClient, setLoading, setError, setIsAuthenticated } = context;
      const signIn = async (redirectUri) => {
        if (!logtoClient.value)
          return $f63beecb5f2c2ea1$export$838ead842aa548e7();
        try {
          setLoading(true);
          await logtoClient.value.signIn(redirectUri);
        } catch (error) {
          setError(error, "Unexpected error occurred while signing in.");
        } finally {
          setLoading(false);
        }
      };
      const signOut = async (postLogoutRedirectUri) => {
        if (!logtoClient.value)
          return $f63beecb5f2c2ea1$export$838ead842aa548e7();
        try {
          setLoading(true);
          await logtoClient.value.signOut(postLogoutRedirectUri);
        } catch (error) {
          setError(error, "Unexpected error occurred while signing out.");
        } finally {
          setLoading(false);
        }
      };
      const getAccessToken = async (resource) => {
        if (!logtoClient.value)
          return $f63beecb5f2c2ea1$export$838ead842aa548e7();
        try {
          setLoading(true);
          return await logtoClient.value.getAccessToken(resource);
        } catch (error) {
          setError(error, "Unexpected error occurred while getting access token.");
        } finally {
          setLoading(false);
        }
      };
      const getIdTokenClaims = () => {
        if (!logtoClient.value)
          return $f63beecb5f2c2ea1$export$838ead842aa548e7();
        try {
          return logtoClient.value.getIdTokenClaims();
        } catch (error) {
          setError(error, "Unexpected error occurred while getting id token claims.");
        }
      };
      const handleSignInCallback = async (callbackUri, callbackFunction) => {
        if (!logtoClient.value)
          return $f63beecb5f2c2ea1$export$838ead842aa548e7();
        try {
          setLoading(true);
          await logtoClient.value.handleSignInCallback(callbackUri);
          setIsAuthenticated(true);
          callbackFunction == null ? void 0 : callbackFunction();
        } catch (error) {
          setError(error, "Unexpected error occurred while handling sign in callback.");
        } finally {
          setLoading(false);
        }
      };
      return {
        signIn,
        signOut,
        getAccessToken,
        getIdTokenClaims,
        handleSignInCallback
      };
    };
    const $a52d863b14a9eb8e$export$d8f887f9089028d2 = {
      install(app2, config2) {
        const client = new $90df2ab0e44b5eba$export$2e2bcd8739ae039(config2);
        const context = $f63beecb5f2c2ea1$export$fd42f52fd3ae1109(client);
        const pluginMethods = $eec30d751f04969b$export$6ad57c8ed6bec4(context);
        const { isAuthenticated, isLoading, error } = context;
        app2.provide($cda0d5851de767d1$export$951b969b1220de04, context);
        app2.provide($cda0d5851de767d1$export$58f3af87e7a1a85a, {
          isAuthenticated: readonly(isAuthenticated),
          isLoading: readonly(isLoading),
          error: readonly(error),
          ...pluginMethods
        });
      }
    };
    const $a52d863b14a9eb8e$export$44fc9df4d2a1789a = () => {
      const logto = inject($cda0d5851de767d1$export$58f3af87e7a1a85a);
      if (!logto)
        return $f63beecb5f2c2ea1$export$838ead842aa548e7();
      return logto;
    };
    const $a52d863b14a9eb8e$export$84e88c4b3c082374 = (callback) => {
      const context = inject($cda0d5851de767d1$export$951b969b1220de04);
      if (!context)
        return $f63beecb5f2c2ea1$export$838ead842aa548e7();
      const { isAuthenticated, isLoading, logtoClient, error } = context;
      const { handleSignInCallback } = $eec30d751f04969b$export$6ad57c8ed6bec4(context);
      watchEffect(() => {
        var _a;
        const currentPageUrl = window.location.href;
        if (!isAuthenticated.value && ((_a = logtoClient.value) == null ? void 0 : _a.isSignInRedirected(currentPageUrl)))
          handleSignInCallback(currentPageUrl, callback);
      });
      return {
        isLoading: readonly(isLoading),
        isAuthenticated: readonly(isAuthenticated),
        error: readonly(error)
      };
    };
    /*!
      * vue-router v4.1.3
      * (c) 2022 Eduardo San Martin Morote
      * @license MIT
      */
    const isBrowser$2 = typeof window !== "undefined";
    function isESModule(obj) {
      return obj.__esModule || obj[Symbol.toStringTag] === "Module";
    }
    const assign$1 = Object.assign;
    function applyToParams(fn, params) {
      const newParams = {};
      for (const key in params) {
        const value = params[key];
        newParams[key] = isArray$3(value) ? value.map(fn) : fn(value);
      }
      return newParams;
    }
    const noop$5 = () => {
    };
    const isArray$3 = Array.isArray;
    const TRAILING_SLASH_RE = /\/$/;
    const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
    function parseURL(parseQuery2, location2, currentLocation = "/") {
      let path, query = {}, searchString = "", hash2 = "";
      const hashPos = location2.indexOf("#");
      let searchPos = location2.indexOf("?");
      if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
      }
      if (searchPos > -1) {
        path = location2.slice(0, searchPos);
        searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
        query = parseQuery2(searchString);
      }
      if (hashPos > -1) {
        path = path || location2.slice(0, hashPos);
        hash2 = location2.slice(hashPos, location2.length);
      }
      path = resolveRelativePath(path != null ? path : location2, currentLocation);
      return {
        fullPath: path + (searchString && "?") + searchString + hash2,
        path,
        query,
        hash: hash2
      };
    }
    function stringifyURL(stringifyQuery2, location2) {
      const query = location2.query ? stringifyQuery2(location2.query) : "";
      return location2.path + (query && "?") + query + (location2.hash || "");
    }
    function stripBase(pathname, base) {
      if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
      return pathname.slice(base.length) || "/";
    }
    function isSameRouteLocation(stringifyQuery2, a, b) {
      const aLastIndex = a.matched.length - 1;
      const bLastIndex = b.matched.length - 1;
      return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
    }
    function isSameRouteRecord(a, b) {
      return (a.aliasOf || a) === (b.aliasOf || b);
    }
    function isSameRouteLocationParams(a, b) {
      if (Object.keys(a).length !== Object.keys(b).length)
        return false;
      for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
          return false;
      }
      return true;
    }
    function isSameRouteLocationParamsValue(a, b) {
      return isArray$3(a) ? isEquivalentArray(a, b) : isArray$3(b) ? isEquivalentArray(b, a) : a === b;
    }
    function isEquivalentArray(a, b) {
      return isArray$3(b) ? a.length === b.length && a.every((value, i2) => value === b[i2]) : a.length === 1 && a[0] === b;
    }
    function resolveRelativePath(to, from) {
      if (to.startsWith("/"))
        return to;
      if (!to)
        return from;
      const fromSegments = from.split("/");
      const toSegments = to.split("/");
      let position = fromSegments.length - 1;
      let toPosition;
      let segment;
      for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        if (segment === ".")
          continue;
        if (segment === "..") {
          if (position > 1)
            position--;
        } else
          break;
      }
      return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
    }
    var NavigationType;
    (function(NavigationType2) {
      NavigationType2["pop"] = "pop";
      NavigationType2["push"] = "push";
    })(NavigationType || (NavigationType = {}));
    var NavigationDirection;
    (function(NavigationDirection2) {
      NavigationDirection2["back"] = "back";
      NavigationDirection2["forward"] = "forward";
      NavigationDirection2["unknown"] = "";
    })(NavigationDirection || (NavigationDirection = {}));
    function normalizeBase(base) {
      if (!base) {
        if (isBrowser$2) {
          const baseEl = document.querySelector("base");
          base = baseEl && baseEl.getAttribute("href") || "/";
          base = base.replace(/^\w+:\/\/[^\/]+/, "");
        } else {
          base = "/";
        }
      }
      if (base[0] !== "/" && base[0] !== "#")
        base = "/" + base;
      return removeTrailingSlash(base);
    }
    const BEFORE_HASH_RE = /^[^#]+#/;
    function createHref(base, location2) {
      return base.replace(BEFORE_HASH_RE, "#") + location2;
    }
    function getElementPosition(el, offset2) {
      const docRect = document.documentElement.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      return {
        behavior: offset2.behavior,
        left: elRect.left - docRect.left - (offset2.left || 0),
        top: elRect.top - docRect.top - (offset2.top || 0)
      };
    }
    const computeScrollPosition = () => ({
      left: window.pageXOffset,
      top: window.pageYOffset
    });
    function scrollToPosition(position) {
      let scrollToOptions;
      if ("el" in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
        const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
        if (!el) {
          return;
        }
        scrollToOptions = getElementPosition(el, position);
      } else {
        scrollToOptions = position;
      }
      if ("scrollBehavior" in document.documentElement.style)
        window.scrollTo(scrollToOptions);
      else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
      }
    }
    function getScrollKey(path, delta) {
      const position = history.state ? history.state.position - delta : -1;
      return position + path;
    }
    const scrollPositions = /* @__PURE__ */ new Map();
    function saveScrollPosition(key, scrollPosition) {
      scrollPositions.set(key, scrollPosition);
    }
    function getSavedScrollPosition(key) {
      const scroll = scrollPositions.get(key);
      scrollPositions.delete(key);
      return scroll;
    }
    let createBaseLocation = () => location.protocol + "//" + location.host;
    function createCurrentLocation(base, location2) {
      const { pathname, search, hash: hash2 } = location2;
      const hashPos = base.indexOf("#");
      if (hashPos > -1) {
        let slicePos = hash2.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
        let pathFromHash = hash2.slice(slicePos);
        if (pathFromHash[0] !== "/")
          pathFromHash = "/" + pathFromHash;
        return stripBase(pathFromHash, "");
      }
      const path = stripBase(pathname, base);
      return path + search + hash2;
    }
    function useHistoryListeners(base, historyState, currentLocation, replace) {
      let listeners = [];
      let teardowns = [];
      let pauseState = null;
      const popStateHandler = ({ state }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
          currentLocation.value = to;
          historyState.value = state;
          if (pauseState && pauseState === from) {
            pauseState = null;
            return;
          }
          delta = fromState ? state.position - fromState.position : 0;
        } else {
          replace(to);
        }
        listeners.forEach((listener) => {
          listener(currentLocation.value, from, {
            delta,
            type: NavigationType.pop,
            direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          });
        });
      };
      function pauseListeners() {
        pauseState = currentLocation.value;
      }
      function listen(callback) {
        listeners.push(callback);
        const teardown = () => {
          const index2 = listeners.indexOf(callback);
          if (index2 > -1)
            listeners.splice(index2, 1);
        };
        teardowns.push(teardown);
        return teardown;
      }
      function beforeUnloadListener() {
        const { history: history2 } = window;
        if (!history2.state)
          return;
        history2.replaceState(assign$1({}, history2.state, { scroll: computeScrollPosition() }), "");
      }
      function destroy() {
        for (const teardown of teardowns)
          teardown();
        teardowns = [];
        window.removeEventListener("popstate", popStateHandler);
        window.removeEventListener("beforeunload", beforeUnloadListener);
      }
      window.addEventListener("popstate", popStateHandler);
      window.addEventListener("beforeunload", beforeUnloadListener);
      return {
        pauseListeners,
        listen,
        destroy
      };
    }
    function buildState(back, current, forward, replaced = false, computeScroll = false) {
      return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null
      };
    }
    function useHistoryStateNavigation(base) {
      const { history: history2, location: location2 } = window;
      const currentLocation = {
        value: createCurrentLocation(base, location2)
      };
      const historyState = { value: history2.state };
      if (!historyState.value) {
        changeLocation(currentLocation.value, {
          back: null,
          current: currentLocation.value,
          forward: null,
          position: history2.length - 1,
          replaced: true,
          scroll: null
        }, true);
      }
      function changeLocation(to, state, replace2) {
        const hashIndex = base.indexOf("#");
        const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
        try {
          history2[replace2 ? "replaceState" : "pushState"](state, "", url);
          historyState.value = state;
        } catch (err) {
          {
            console.error(err);
          }
          location2[replace2 ? "replace" : "assign"](url);
        }
      }
      function replace(to, data2) {
        const state = assign$1({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data2, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
      }
      function push(to, data2) {
        const currentState = assign$1({}, historyState.value, history2.state, {
          forward: to,
          scroll: computeScrollPosition()
        });
        changeLocation(currentState.current, currentState, true);
        const state = assign$1({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data2);
        changeLocation(to, state, false);
        currentLocation.value = to;
      }
      return {
        location: currentLocation,
        state: historyState,
        push,
        replace
      };
    }
    function createWebHistory(base) {
      base = normalizeBase(base);
      const historyNavigation = useHistoryStateNavigation(base);
      const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
      function go(delta, triggerListeners = true) {
        if (!triggerListeners)
          historyListeners.pauseListeners();
        history.go(delta);
      }
      const routerHistory = assign$1({
        location: "",
        base,
        go,
        createHref: createHref.bind(null, base)
      }, historyNavigation, historyListeners);
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => historyNavigation.location.value
      });
      Object.defineProperty(routerHistory, "state", {
        enumerable: true,
        get: () => historyNavigation.state.value
      });
      return routerHistory;
    }
    function isRouteLocation(route) {
      return typeof route === "string" || route && typeof route === "object";
    }
    function isRouteName(name) {
      return typeof name === "string" || typeof name === "symbol";
    }
    const START_LOCATION_NORMALIZED = {
      path: "/",
      name: void 0,
      params: {},
      query: {},
      hash: "",
      fullPath: "/",
      matched: [],
      meta: {},
      redirectedFrom: void 0
    };
    const NavigationFailureSymbol = Symbol("");
    var NavigationFailureType;
    (function(NavigationFailureType2) {
      NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
      NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
      NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
    })(NavigationFailureType || (NavigationFailureType = {}));
    function createRouterError(type2, params) {
      {
        return assign$1(new Error(), {
          type: type2,
          [NavigationFailureSymbol]: true
        }, params);
      }
    }
    function isNavigationFailure(error, type2) {
      return error instanceof Error && NavigationFailureSymbol in error && (type2 == null || !!(error.type & type2));
    }
    const BASE_PARAM_PATTERN = "[^/]+?";
    const BASE_PATH_PARSER_OPTIONS = {
      sensitive: false,
      strict: false,
      start: true,
      end: true
    };
    const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
    function tokensToParser(segments, extraOptions) {
      const options = assign$1({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
      const score = [];
      let pattern = options.start ? "^" : "";
      const keys2 = [];
      for (const segment of segments) {
        const segmentScores = segment.length ? [] : [90];
        if (options.strict && !segment.length)
          pattern += "/";
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
          const token = segment[tokenIndex];
          let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
          if (token.type === 0) {
            if (!tokenIndex)
              pattern += "/";
            pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
            subSegmentScore += 40;
          } else if (token.type === 1) {
            const { value, repeatable, optional: optional2, regexp } = token;
            keys2.push({
              name: value,
              repeatable,
              optional: optional2
            });
            const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
            if (re2 !== BASE_PARAM_PATTERN) {
              subSegmentScore += 10;
              try {
                new RegExp(`(${re2})`);
              } catch (err) {
                throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
              }
            }
            let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
            if (!tokenIndex)
              subPattern = optional2 && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
            if (optional2)
              subPattern += "?";
            pattern += subPattern;
            subSegmentScore += 20;
            if (optional2)
              subSegmentScore += -8;
            if (repeatable)
              subSegmentScore += -20;
            if (re2 === ".*")
              subSegmentScore += -50;
          }
          segmentScores.push(subSegmentScore);
        }
        score.push(segmentScores);
      }
      if (options.strict && options.end) {
        const i2 = score.length - 1;
        score[i2][score[i2].length - 1] += 0.7000000000000001;
      }
      if (!options.strict)
        pattern += "/?";
      if (options.end)
        pattern += "$";
      else if (options.strict)
        pattern += "(?:/|$)";
      const re = new RegExp(pattern, options.sensitive ? "" : "i");
      function parse2(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
          return null;
        for (let i2 = 1; i2 < match.length; i2++) {
          const value = match[i2] || "";
          const key = keys2[i2 - 1];
          params[key.name] = value && key.repeatable ? value.split("/") : value;
        }
        return params;
      }
      function stringify2(params) {
        let path = "";
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
          if (!avoidDuplicatedSlash || !path.endsWith("/"))
            path += "/";
          avoidDuplicatedSlash = false;
          for (const token of segment) {
            if (token.type === 0) {
              path += token.value;
            } else if (token.type === 1) {
              const { value, repeatable, optional: optional2 } = token;
              const param = value in params ? params[value] : "";
              if (isArray$3(param) && !repeatable) {
                throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
              }
              const text = isArray$3(param) ? param.join("/") : param;
              if (!text) {
                if (optional2) {
                  if (segment.length < 2) {
                    if (path.endsWith("/"))
                      path = path.slice(0, -1);
                    else
                      avoidDuplicatedSlash = true;
                  }
                } else
                  throw new Error(`Missing required param "${value}"`);
              }
              path += text;
            }
          }
        }
        return path || "/";
      }
      return {
        re,
        score,
        keys: keys2,
        parse: parse2,
        stringify: stringify2
      };
    }
    function compareScoreArray(a, b) {
      let i2 = 0;
      while (i2 < a.length && i2 < b.length) {
        const diff = b[i2] - a[i2];
        if (diff)
          return diff;
        i2++;
      }
      if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
      } else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
      }
      return 0;
    }
    function comparePathParserScore(a, b) {
      let i2 = 0;
      const aScore = a.score;
      const bScore = b.score;
      while (i2 < aScore.length && i2 < bScore.length) {
        const comp = compareScoreArray(aScore[i2], bScore[i2]);
        if (comp)
          return comp;
        i2++;
      }
      if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
          return 1;
        if (isLastScoreNegative(bScore))
          return -1;
      }
      return bScore.length - aScore.length;
    }
    function isLastScoreNegative(score) {
      const last = score[score.length - 1];
      return score.length > 0 && last[last.length - 1] < 0;
    }
    const ROOT_TOKEN = {
      type: 0,
      value: ""
    };
    const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
    function tokenizePath(path) {
      if (!path)
        return [[]];
      if (path === "/")
        return [[ROOT_TOKEN]];
      if (!path.startsWith("/")) {
        throw new Error(`Invalid path "${path}"`);
      }
      function crash(message) {
        throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
      }
      let state = 0;
      let previousState = state;
      const tokens = [];
      let segment;
      function finalizeSegment() {
        if (segment)
          tokens.push(segment);
        segment = [];
      }
      let i2 = 0;
      let char;
      let buffer2 = "";
      let customRe = "";
      function consumeBuffer() {
        if (!buffer2)
          return;
        if (state === 0) {
          segment.push({
            type: 0,
            value: buffer2
          });
        } else if (state === 1 || state === 2 || state === 3) {
          if (segment.length > 1 && (char === "*" || char === "+"))
            crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
          segment.push({
            type: 1,
            value: buffer2,
            regexp: customRe,
            repeatable: char === "*" || char === "+",
            optional: char === "*" || char === "?"
          });
        } else {
          crash("Invalid state to consume buffer");
        }
        buffer2 = "";
      }
      function addCharToBuffer() {
        buffer2 += char;
      }
      while (i2 < path.length) {
        char = path[i2++];
        if (char === "\\" && state !== 2) {
          previousState = state;
          state = 4;
          continue;
        }
        switch (state) {
          case 0:
            if (char === "/") {
              if (buffer2) {
                consumeBuffer();
              }
              finalizeSegment();
            } else if (char === ":") {
              consumeBuffer();
              state = 1;
            } else {
              addCharToBuffer();
            }
            break;
          case 4:
            addCharToBuffer();
            state = previousState;
            break;
          case 1:
            if (char === "(") {
              state = 2;
            } else if (VALID_PARAM_RE.test(char)) {
              addCharToBuffer();
            } else {
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i2--;
            }
            break;
          case 2:
            if (char === ")") {
              if (customRe[customRe.length - 1] == "\\")
                customRe = customRe.slice(0, -1) + char;
              else
                state = 3;
            } else {
              customRe += char;
            }
            break;
          case 3:
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i2--;
            customRe = "";
            break;
          default:
            crash("Unknown state");
            break;
        }
      }
      if (state === 2)
        crash(`Unfinished custom RegExp for param "${buffer2}"`);
      consumeBuffer();
      finalizeSegment();
      return tokens;
    }
    function createRouteRecordMatcher(record2, parent2, options) {
      const parser = tokensToParser(tokenizePath(record2.path), options);
      const matcher = assign$1(parser, {
        record: record2,
        parent: parent2,
        children: [],
        alias: []
      });
      if (parent2) {
        if (!matcher.record.aliasOf === !parent2.record.aliasOf)
          parent2.children.push(matcher);
      }
      return matcher;
    }
    function createRouterMatcher(routes, globalOptions) {
      const matchers2 = [];
      const matcherMap = /* @__PURE__ */ new Map();
      globalOptions = mergeOptions$1({ strict: false, end: true, sensitive: false }, globalOptions);
      function getRecordMatcher(name) {
        return matcherMap.get(name);
      }
      function addRoute(record2, parent2, originalRecord) {
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record2);
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions$1(globalOptions, record2);
        const normalizedRecords = [
          mainNormalizedRecord
        ];
        if ("alias" in record2) {
          const aliases = typeof record2.alias === "string" ? [record2.alias] : record2.alias;
          for (const alias of aliases) {
            normalizedRecords.push(assign$1({}, mainNormalizedRecord, {
              components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
              path: alias,
              aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
            }));
          }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
          const { path } = normalizedRecord;
          if (parent2 && path[0] !== "/") {
            const parentPath = parent2.record.path;
            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
            normalizedRecord.path = parent2.record.path + (path && connectingSlash + path);
          }
          matcher = createRouteRecordMatcher(normalizedRecord, parent2, options);
          if (originalRecord) {
            originalRecord.alias.push(matcher);
          } else {
            originalMatcher = originalMatcher || matcher;
            if (originalMatcher !== matcher)
              originalMatcher.alias.push(matcher);
            if (isRootAdd && record2.name && !isAliasRecord(matcher))
              removeRoute(record2.name);
          }
          if (mainNormalizedRecord.children) {
            const children = mainNormalizedRecord.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
            }
          }
          originalRecord = originalRecord || matcher;
          insertMatcher(matcher);
        }
        return originalMatcher ? () => {
          removeRoute(originalMatcher);
        } : noop$5;
      }
      function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
          const matcher = matcherMap.get(matcherRef);
          if (matcher) {
            matcherMap.delete(matcherRef);
            matchers2.splice(matchers2.indexOf(matcher), 1);
            matcher.children.forEach(removeRoute);
            matcher.alias.forEach(removeRoute);
          }
        } else {
          const index2 = matchers2.indexOf(matcherRef);
          if (index2 > -1) {
            matchers2.splice(index2, 1);
            if (matcherRef.record.name)
              matcherMap.delete(matcherRef.record.name);
            matcherRef.children.forEach(removeRoute);
            matcherRef.alias.forEach(removeRoute);
          }
        }
      }
      function getRoutes() {
        return matchers2;
      }
      function insertMatcher(matcher) {
        let i2 = 0;
        while (i2 < matchers2.length && comparePathParserScore(matcher, matchers2[i2]) >= 0 && (matcher.record.path !== matchers2[i2].record.path || !isRecordChildOf(matcher, matchers2[i2])))
          i2++;
        matchers2.splice(i2, 0, matcher);
        if (matcher.record.name && !isAliasRecord(matcher))
          matcherMap.set(matcher.record.name, matcher);
      }
      function resolve2(location2, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ("name" in location2 && location2.name) {
          matcher = matcherMap.get(location2.name);
          if (!matcher)
            throw createRouterError(1, {
              location: location2
            });
          name = matcher.record.name;
          params = assign$1(paramsFromLocation(currentLocation.params, matcher.keys.filter((k) => !k.optional).map((k) => k.name)), location2.params);
          path = matcher.stringify(params);
        } else if ("path" in location2) {
          path = location2.path;
          matcher = matchers2.find((m) => m.re.test(path));
          if (matcher) {
            params = matcher.parse(path);
            name = matcher.record.name;
          }
        } else {
          matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers2.find((m) => m.re.test(currentLocation.path));
          if (!matcher)
            throw createRouterError(1, {
              location: location2,
              currentLocation
            });
          name = matcher.record.name;
          params = assign$1({}, currentLocation.params, location2.params);
          path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
          matched.unshift(parentMatcher.record);
          parentMatcher = parentMatcher.parent;
        }
        return {
          name,
          path,
          params,
          matched,
          meta: mergeMetaFields(matched)
        };
      }
      routes.forEach((route) => addRoute(route));
      return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
    }
    function paramsFromLocation(params, keys2) {
      const newParams = {};
      for (const key of keys2) {
        if (key in params)
          newParams[key] = params[key];
      }
      return newParams;
    }
    function normalizeRouteRecord(record2) {
      return {
        path: record2.path,
        redirect: record2.redirect,
        name: record2.name,
        meta: record2.meta || {},
        aliasOf: void 0,
        beforeEnter: record2.beforeEnter,
        props: normalizeRecordProps(record2),
        children: record2.children || [],
        instances: {},
        leaveGuards: /* @__PURE__ */ new Set(),
        updateGuards: /* @__PURE__ */ new Set(),
        enterCallbacks: {},
        components: "components" in record2 ? record2.components || null : record2.component && { default: record2.component }
      };
    }
    function normalizeRecordProps(record2) {
      const propsObject = {};
      const props = record2.props || false;
      if ("component" in record2) {
        propsObject.default = props;
      } else {
        for (const name in record2.components)
          propsObject[name] = typeof props === "boolean" ? props : props[name];
      }
      return propsObject;
    }
    function isAliasRecord(record2) {
      while (record2) {
        if (record2.record.aliasOf)
          return true;
        record2 = record2.parent;
      }
      return false;
    }
    function mergeMetaFields(matched) {
      return matched.reduce((meta, record2) => assign$1(meta, record2.meta), {});
    }
    function mergeOptions$1(defaults2, partialOptions) {
      const options = {};
      for (const key in defaults2) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
      }
      return options;
    }
    function isRecordChildOf(record2, parent2) {
      return parent2.children.some((child) => child === record2 || isRecordChildOf(record2, child));
    }
    const HASH_RE = /#/g;
    const AMPERSAND_RE = /&/g;
    const SLASH_RE = /\//g;
    const EQUAL_RE = /=/g;
    const IM_RE = /\?/g;
    const PLUS_RE = /\+/g;
    const ENC_BRACKET_OPEN_RE = /%5B/g;
    const ENC_BRACKET_CLOSE_RE = /%5D/g;
    const ENC_CARET_RE = /%5E/g;
    const ENC_BACKTICK_RE = /%60/g;
    const ENC_CURLY_OPEN_RE = /%7B/g;
    const ENC_PIPE_RE = /%7C/g;
    const ENC_CURLY_CLOSE_RE = /%7D/g;
    const ENC_SPACE_RE = /%20/g;
    function commonEncode(text) {
      return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
    }
    function encodeHash(text) {
      return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(text) {
      return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryKey(text) {
      return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text) {
      return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
    }
    function encodeParam(text) {
      return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
    }
    function decode(text) {
      try {
        return decodeURIComponent("" + text);
      } catch (err) {
      }
      return "" + text;
    }
    function parseQuery(search) {
      const query = {};
      if (search === "" || search === "?")
        return query;
      const hasLeadingIM = search[0] === "?";
      const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
      for (let i2 = 0; i2 < searchParams.length; ++i2) {
        const searchParam = searchParams[i2].replace(PLUS_RE, " ");
        const eqPos = searchParam.indexOf("=");
        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
          let currentValue = query[key];
          if (!isArray$3(currentValue)) {
            currentValue = query[key] = [currentValue];
          }
          currentValue.push(value);
        } else {
          query[key] = value;
        }
      }
      return query;
    }
    function stringifyQuery$1(query) {
      let search = "";
      for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
          if (value !== void 0) {
            search += (search.length ? "&" : "") + key;
          }
          continue;
        }
        const values = isArray$3(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
        values.forEach((value2) => {
          if (value2 !== void 0) {
            search += (search.length ? "&" : "") + key;
            if (value2 != null)
              search += "=" + value2;
          }
        });
      }
      return search;
    }
    function normalizeQuery(query) {
      const normalizedQuery = {};
      for (const key in query) {
        const value = query[key];
        if (value !== void 0) {
          normalizedQuery[key] = isArray$3(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
        }
      }
      return normalizedQuery;
    }
    const matchedRouteKey = Symbol("");
    const viewDepthKey = Symbol("");
    const routerKey = Symbol("");
    const routeLocationKey = Symbol("");
    const routerViewLocationKey = Symbol("");
    function useCallbacks() {
      let handlers = [];
      function add2(handler) {
        handlers.push(handler);
        return () => {
          const i2 = handlers.indexOf(handler);
          if (i2 > -1)
            handlers.splice(i2, 1);
        };
      }
      function reset2() {
        handlers = [];
      }
      return {
        add: add2,
        list: () => handlers,
        reset: reset2
      };
    }
    function guardToPromiseFn(guard, to, from, record2, name) {
      const enterCallbackArray = record2 && (record2.enterCallbacks[name] = record2.enterCallbacks[name] || []);
      return () => new Promise((resolve2, reject) => {
        const next = (valid) => {
          if (valid === false) {
            reject(createRouterError(4, {
              from,
              to
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to,
              to: valid
            }));
          } else {
            if (enterCallbackArray && record2.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve2();
          }
        };
        const guardReturn = guard.call(record2 && record2.instances[name], to, from, next);
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
          guardCall = guardCall.then(next);
        guardCall.catch((err) => reject(err));
      });
    }
    function extractComponentsGuards(matched, guardType, to, from) {
      const guards = [];
      for (const record2 of matched) {
        for (const name in record2.components) {
          let rawComponent = record2.components[name];
          if (guardType !== "beforeRouteEnter" && !record2.instances[name])
            continue;
          if (isRouteComponent(rawComponent)) {
            const options = rawComponent.__vccOpts || rawComponent;
            const guard = options[guardType];
            guard && guards.push(guardToPromiseFn(guard, to, from, record2, name));
          } else {
            let componentPromise = rawComponent();
            guards.push(() => componentPromise.then((resolved) => {
              if (!resolved)
                return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record2.path}"`));
              const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record2.components[name] = resolvedComponent;
              const options = resolvedComponent.__vccOpts || resolvedComponent;
              const guard = options[guardType];
              return guard && guardToPromiseFn(guard, to, from, record2, name)();
            }));
          }
        }
      }
      return guards;
    }
    function isRouteComponent(component) {
      return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
    }
    function useLink(props) {
      const router2 = inject(routerKey);
      const currentRoute = inject(routeLocationKey);
      const route = computed(() => router2.resolve(unref$1(props.to)));
      const activeRecordIndex = computed(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
          return -1;
        const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index2 > -1)
          return index2;
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2;
      });
      const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
      const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
      function navigate(e = {}) {
        if (guardEvent(e)) {
          return router2[unref$1(props.replace) ? "replace" : "push"](unref$1(props.to)).catch(noop$5);
        }
        return Promise.resolve();
      }
      return {
        route,
        href: computed(() => route.value.href),
        isActive,
        isExactActive,
        navigate
      };
    }
    const RouterLinkImpl = /* @__PURE__ */ defineComponent({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: {
          type: [String, Object],
          required: true
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
          type: String,
          default: "page"
        }
      },
      useLink,
      setup(props, { slots }) {
        const link = reactive(useLink(props));
        const { options } = inject(routerKey);
        const elClass = computed(() => ({
          [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
          [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
        }));
        return () => {
          const children = slots.default && slots.default(link);
          return props.custom ? children : h("a", {
            "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
            href: link.href,
            onClick: link.navigate,
            class: elClass.value
          }, children);
        };
      }
    });
    const RouterLink = RouterLinkImpl;
    function guardEvent(e) {
      if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      if (e.button !== void 0 && e.button !== 0)
        return;
      if (e.currentTarget && e.currentTarget.getAttribute) {
        const target = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(target))
          return;
      }
      if (e.preventDefault)
        e.preventDefault();
      return true;
    }
    function includesParams(outer, inner) {
      for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue)
            return false;
        } else {
          if (!isArray$3(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
            return false;
        }
      }
      return true;
    }
    function getOriginalPath(record2) {
      return record2 ? record2.aliasOf ? record2.aliasOf.path : record2.path : "";
    }
    const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
    const RouterViewImpl = /* @__PURE__ */ defineComponent({
      name: "RouterView",
      inheritAttrs: false,
      props: {
        name: {
          type: String,
          default: "default"
        },
        route: Object
      },
      compatConfig: { MODE: 3 },
      setup(props, { attrs, slots }) {
        const injectedRoute = inject(routerViewLocationKey);
        const routeToDisplay = computed(() => props.route || injectedRoute.value);
        const injectedDepth = inject(viewDepthKey, 0);
        const depth = computed(() => {
          let initialDepth = unref$1(injectedDepth);
          const { matched } = routeToDisplay.value;
          let matchedRoute;
          while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
            initialDepth++;
          }
          return initialDepth;
        });
        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
        provide(viewDepthKey, computed(() => depth.value + 1));
        provide(matchedRouteKey, matchedRouteRef);
        provide(routerViewLocationKey, routeToDisplay);
        const viewRef = ref();
        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
          if (to) {
            to.instances[name] = instance;
            if (from && from !== to && instance && instance === oldInstance) {
              if (!to.leaveGuards.size) {
                to.leaveGuards = from.leaveGuards;
              }
              if (!to.updateGuards.size) {
                to.updateGuards = from.updateGuards;
              }
            }
          }
          if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
            (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
          }
        }, { flush: "post" });
        return () => {
          const route = routeToDisplay.value;
          const currentName = props.name;
          const matchedRoute = matchedRouteRef.value;
          const ViewComponent = matchedRoute && matchedRoute.components[currentName];
          if (!ViewComponent) {
            return normalizeSlot(slots.default, { Component: ViewComponent, route });
          }
          const routePropsOption = matchedRoute.props[currentName];
          const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
          const onVnodeUnmounted = (vnode) => {
            if (vnode.component.isUnmounted) {
              matchedRoute.instances[currentName] = null;
            }
          };
          const component = h(ViewComponent, assign$1({}, routeProps, attrs, {
            onVnodeUnmounted,
            ref: viewRef
          }));
          return normalizeSlot(slots.default, { Component: component, route }) || component;
        };
      }
    });
    function normalizeSlot(slot, data2) {
      if (!slot)
        return null;
      const slotContent = slot(data2);
      return slotContent.length === 1 ? slotContent[0] : slotContent;
    }
    const RouterView = RouterViewImpl;
    function createRouter(options) {
      const matcher = createRouterMatcher(options.routes, options);
      const parseQuery$1 = options.parseQuery || parseQuery;
      const stringifyQuery$1$1 = options.stringifyQuery || stringifyQuery$1;
      const routerHistory = options.history;
      const beforeGuards = useCallbacks();
      const beforeResolveGuards = useCallbacks();
      const afterGuards = useCallbacks();
      const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
      let pendingLocation = START_LOCATION_NORMALIZED;
      if (isBrowser$2 && options.scrollBehavior && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
      const encodeParams = applyToParams.bind(null, encodeParam);
      const decodeParams = applyToParams.bind(null, decode);
      function addRoute(parentOrRoute, route) {
        let parent2;
        let record2;
        if (isRouteName(parentOrRoute)) {
          parent2 = matcher.getRecordMatcher(parentOrRoute);
          record2 = route;
        } else {
          record2 = parentOrRoute;
        }
        return matcher.addRoute(record2, parent2);
      }
      function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
          matcher.removeRoute(recordMatcher);
        }
      }
      function getRoutes() {
        return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
      }
      function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
      }
      function resolve2(rawLocation, currentLocation) {
        currentLocation = assign$1({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === "string") {
          const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
          const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
          const href2 = routerHistory.createHref(locationNormalized.fullPath);
          return assign$1(locationNormalized, matchedRoute2, {
            params: decodeParams(matchedRoute2.params),
            hash: decode(locationNormalized.hash),
            redirectedFrom: void 0,
            href: href2
          });
        }
        let matcherLocation;
        if ("path" in rawLocation) {
          matcherLocation = assign$1({}, rawLocation, {
            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
          });
        } else {
          const targetParams = assign$1({}, rawLocation.params);
          for (const key in targetParams) {
            if (targetParams[key] == null) {
              delete targetParams[key];
            }
          }
          matcherLocation = assign$1({}, rawLocation, {
            params: encodeParams(rawLocation.params)
          });
          currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash2 = rawLocation.hash || "";
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1$1, assign$1({}, rawLocation, {
          hash: encodeHash(hash2),
          path: matchedRoute.path
        }));
        const href = routerHistory.createHref(fullPath);
        return assign$1({
          fullPath,
          hash: hash2,
          query: stringifyQuery$1$1 === stringifyQuery$1 ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
        }, matchedRoute, {
          redirectedFrom: void 0,
          href
        });
      }
      function locationAsObject(to) {
        return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$1({}, to);
      }
      function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
          return createRouterError(8, {
            from,
            to
          });
        }
      }
      function push(to) {
        return pushWithRedirect(to);
      }
      function replace(to) {
        return push(assign$1(locationAsObject(to), { replace: true }));
      }
      function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
          const { redirect } = lastMatched;
          let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
          if (typeof newTargetLocation === "string") {
            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
            newTargetLocation.params = {};
          }
          return assign$1({
            query: to.query,
            hash: to.hash,
            params: "path" in newTargetLocation ? {} : to.params
          }, newTargetLocation);
        }
      }
      function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = pendingLocation = resolve2(to);
        const from = currentRoute.value;
        const data2 = to.state;
        const force = to.force;
        const replace2 = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
          return pushWithRedirect(assign$1(locationAsObject(shouldRedirect), {
            state: data2,
            force,
            replace: replace2
          }), redirectedFrom || targetLocation);
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1$1, from, targetLocation)) {
          failure = createRouterError(16, { to: toLocation, from });
          handleScroll(from, from, true, false);
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
          if (failure2) {
            if (isNavigationFailure(failure2, 2)) {
              return pushWithRedirect(assign$1({
                replace: replace2
              }, locationAsObject(failure2.to), {
                state: data2,
                force
              }), redirectedFrom || toLocation);
            }
          } else {
            failure2 = finalizeNavigation(toLocation, from, true, replace2, data2);
          }
          triggerAfterEach(toLocation, from, failure2);
          return failure2;
        });
      }
      function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
      }
      function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
        for (const record2 of leavingRecords) {
          record2.leaveGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards).then(() => {
          guards = [];
          for (const guard of beforeGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
          for (const record2 of updatingRecords) {
            record2.updateGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to, from));
            });
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const record2 of to.matched) {
            if (record2.beforeEnter && !from.matched.includes(record2)) {
              if (isArray$3(record2.beforeEnter)) {
                for (const beforeEnter of record2.beforeEnter)
                  guards.push(guardToPromiseFn(beforeEnter, to, from));
              } else {
                guards.push(guardToPromiseFn(record2.beforeEnter, to, from));
              }
            }
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          to.matched.forEach((record2) => record2.enterCallbacks = {});
          guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const guard of beforeResolveGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
      }
      function triggerAfterEach(to, from, failure) {
        for (const guard of afterGuards.list())
          guard(to, from, failure);
      }
      function finalizeNavigation(toLocation, from, isPush, replace2, data2) {
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
          return error;
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser$2 ? {} : history.state;
        if (isPush) {
          if (replace2 || isFirstNavigation)
            routerHistory.replace(toLocation.fullPath, assign$1({
              scroll: isFirstNavigation && state && state.scroll
            }, data2));
          else
            routerHistory.push(toLocation.fullPath, data2);
        }
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
      }
      let removeHistoryListener;
      function setupListeners() {
        if (removeHistoryListener)
          return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
          if (!router2.listening)
            return;
          const toLocation = resolve2(to);
          const shouldRedirect = handleRedirectRecord(toLocation);
          if (shouldRedirect) {
            pushWithRedirect(assign$1(shouldRedirect, { replace: true }), toLocation).catch(noop$5);
            return;
          }
          pendingLocation = toLocation;
          const from = currentRoute.value;
          if (isBrowser$2) {
            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
          }
          navigate(toLocation, from).catch((error) => {
            if (isNavigationFailure(error, 4 | 8)) {
              return error;
            }
            if (isNavigationFailure(error, 2)) {
              pushWithRedirect(error.to, toLocation).then((failure) => {
                if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                  routerHistory.go(-1, false);
                }
              }).catch(noop$5);
              return Promise.reject();
            }
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            }
            return triggerError(error, toLocation, from);
          }).then((failure) => {
            failure = failure || finalizeNavigation(toLocation, from, false);
            if (failure) {
              if (info.delta && !isNavigationFailure(failure, 8)) {
                routerHistory.go(-info.delta, false);
              } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
                routerHistory.go(-1, false);
              }
            }
            triggerAfterEach(toLocation, from, failure);
          }).catch(noop$5);
        });
      }
      let readyHandlers = useCallbacks();
      let errorHandlers = useCallbacks();
      let ready;
      function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorHandlers.list();
        if (list.length) {
          list.forEach((handler) => handler(error, to, from));
        } else {
          console.error(error);
        }
        return Promise.reject(error);
      }
      function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
          return Promise.resolve();
        return new Promise((resolve3, reject) => {
          readyHandlers.add([resolve3, reject]);
        });
      }
      function markAsReady(err) {
        if (!ready) {
          ready = !err;
          setupListeners();
          readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
          readyHandlers.reset();
        }
        return err;
      }
      function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser$2 || !scrollBehavior)
          return Promise.resolve();
        const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
        return nextTick$1().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
      }
      const go = (delta) => routerHistory.go(delta);
      let started;
      const installedApps = /* @__PURE__ */ new Set();
      const router2 = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve: resolve2,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorHandlers.add,
        isReady,
        install(app2) {
          const router3 = this;
          app2.component("RouterLink", RouterLink);
          app2.component("RouterView", RouterView);
          app2.config.globalProperties.$router = router3;
          Object.defineProperty(app2.config.globalProperties, "$route", {
            enumerable: true,
            get: () => unref$1(currentRoute)
          });
          if (isBrowser$2 && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
            started = true;
            push(routerHistory.location).catch((err) => {
            });
          }
          const reactiveRoute = {};
          for (const key in START_LOCATION_NORMALIZED) {
            reactiveRoute[key] = computed(() => currentRoute.value[key]);
          }
          app2.provide(routerKey, router3);
          app2.provide(routeLocationKey, reactive(reactiveRoute));
          app2.provide(routerViewLocationKey, currentRoute);
          const unmountApp = app2.unmount;
          installedApps.add(app2);
          app2.unmount = function() {
            installedApps.delete(app2);
            if (installedApps.size < 1) {
              pendingLocation = START_LOCATION_NORMALIZED;
              removeHistoryListener && removeHistoryListener();
              removeHistoryListener = null;
              currentRoute.value = START_LOCATION_NORMALIZED;
              started = false;
              ready = false;
            }
            unmountApp();
          };
        }
      };
      return router2;
    }
    function runGuardQueue(guards) {
      return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
    }
    function extractChangingRecords(to, from) {
      const leavingRecords = [];
      const updatingRecords = [];
      const enteringRecords = [];
      const len = Math.max(from.matched.length, to.matched.length);
      for (let i2 = 0; i2 < len; i2++) {
        const recordFrom = from.matched[i2];
        if (recordFrom) {
          if (to.matched.find((record2) => isSameRouteRecord(record2, recordFrom)))
            updatingRecords.push(recordFrom);
          else
            leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i2];
        if (recordTo) {
          if (!from.matched.find((record2) => isSameRouteRecord(record2, recordTo))) {
            enteringRecords.push(recordTo);
          }
        }
      }
      return [leavingRecords, updatingRecords, enteringRecords];
    }
    function useRouter() {
      return inject(routerKey);
    }
    function useRoute() {
      return inject(routeLocationKey);
    }
    /*!
      * mande v2.0.1
      * (c) 2022 Eduardo San Martin Morote
      * @license MIT
      */
    function stringifyQuery(query) {
      let searchParams = Object.keys(query).map((k) => [k, query[k]].map(encodeURIComponent).join("=")).join("&");
      return searchParams ? "?" + searchParams : "";
    }
    let trailingSlashRE = /\/+$/;
    let leadingSlashRE = /^\/+/;
    function joinURL(base, url) {
      return base.replace(trailingSlashRE, "") + "/" + url.replace(leadingSlashRE, "");
    }
    function removeNullishValues(headers) {
      return Object.keys(headers).reduce((newHeaders, headerName) => {
        if (headers[headerName] != null) {
          newHeaders[headerName] = headers[headerName];
        }
        return newHeaders;
      }, {});
    }
    const defaults$5 = {
      responseAs: "json",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      }
    };
    function mande(baseURL, passedInstanceOptions = {}, fetchPolyfill) {
      function _fetch(method, urlOrData, dataOrOptions, localOptions = {}) {
        let url;
        let data2;
        if (typeof urlOrData === "object") {
          url = "";
          data2 = urlOrData;
          localOptions = dataOrOptions || {};
        } else {
          url = urlOrData;
          data2 = dataOrOptions;
        }
        let mergedOptions = {
          ...defaults$5,
          ...instanceOptions,
          method,
          ...localOptions,
          headers: removeNullishValues({
            ...defaults$5.headers,
            ...instanceOptions.headers,
            ...localOptions.headers
          })
        };
        let query = {
          ...defaults$5.query,
          ...instanceOptions.query,
          ...localOptions.query
        };
        let { responseAs } = mergedOptions;
        url = joinURL(baseURL, typeof url === "number" ? "" + url : url || "");
        url += stringifyQuery(query);
        if (data2)
          mergedOptions.body = JSON.stringify(data2);
        return localFetch(url, mergedOptions).then((response) => Promise.all([
          response,
          responseAs === "response" ? response : response[responseAs]().catch(() => null)
        ])).then(([response, data3]) => {
          if (response.status >= 200 && response.status < 300) {
            return responseAs !== "response" && response.status == 204 ? null : data3;
          }
          let err = new Error(response.statusText);
          err.response = response;
          err.body = data3;
          throw err;
        });
      }
      const localFetch = typeof fetch != "undefined" ? fetch : fetchPolyfill;
      if (!localFetch) {
        throw new Error("No fetch function exists. Make sure to include a polyfill on Node.js.");
      }
      const instanceOptions = {
        query: {},
        headers: {},
        ...passedInstanceOptions
      };
      return {
        options: instanceOptions,
        post: _fetch.bind(null, "POST"),
        put: _fetch.bind(null, "PUT"),
        patch: _fetch.bind(null, "PATCH"),
        get: (url, options) => _fetch("GET", url, null, options),
        delete: (url, options) => _fetch("DELETE", url, null, options)
      };
    }
    var isVue2 = false;
    /*!
      * pinia v2.0.15
      * (c) 2022 Eduardo San Martin Morote
      * @license MIT
      */
    let activePinia;
    const setActivePinia = (pinia2) => activePinia = pinia2;
    const piniaSymbol = Symbol();
    function isPlainObject$3(o) {
      return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    function createPinia() {
      const scope = effectScope(true);
      const state = scope.run(() => ref({}));
      let _p = [];
      let toBeInstalled = [];
      const pinia2 = markRaw$1({
        install(app2) {
          setActivePinia(pinia2);
          {
            pinia2._a = app2;
            app2.provide(piniaSymbol, pinia2);
            app2.config.globalProperties.$pinia = pinia2;
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p.push(plugin);
          }
          return this;
        },
        _p,
        _a: null,
        _e: scope,
        _s: /* @__PURE__ */ new Map(),
        state
      });
      return pinia2;
    }
    const noop$4 = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop$4) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentInstance()) {
        onUnmounted(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    function mergeReactiveObjects(target, patchToApply) {
      for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
          continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject$3(targetValue) && isPlainObject$3(subPatch) && target.hasOwnProperty(key) && !isRef$1(subPatch) && !isReactive$1(subPatch)) {
          target[key] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target[key] = subPatch;
        }
      }
      return target;
    }
    const skipHydrateSymbol = Symbol();
    function shouldHydrate(obj) {
      return !isPlainObject$3(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign } = Object;
    function isComputed(o) {
      return !!(isRef$1(o) && o.effect);
    }
    function createOptionsStore(id, options, pinia2, hot) {
      const { state, actions, getters } = options;
      const initialState = pinia2.state.value[id];
      let store;
      function setup() {
        if (!initialState && true) {
          {
            pinia2.state.value[id] = state ? state() : {};
          }
        }
        const localState = toRefs(pinia2.state.value[id]);
        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
          computedGetters[name] = markRaw$1(computed(() => {
            setActivePinia(pinia2);
            const store2 = pinia2._s.get(id);
            return getters[name].call(store2, store2);
          }));
          return computedGetters;
        }, {}));
      }
      store = createSetupStore(id, setup, options, pinia2, hot, true);
      store.$reset = function $reset() {
        const newState = state ? state() : {};
        this.$patch(($state) => {
          assign($state, newState);
        });
      };
      return store;
    }
    function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
      let scope;
      const optionsForPlugin = assign({ actions: {} }, options);
      const $subscribeOptions = {
        deep: true
      };
      let isListening;
      let isSyncListening;
      let subscriptions = markRaw$1([]);
      let actionSubscriptions = markRaw$1([]);
      let debuggerEvents;
      const initialState = pinia2.state.value[$id];
      if (!isOptionsStore && !initialState && true) {
        {
          pinia2.state.value[$id] = {};
        }
      }
      ref({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia2.state.value[$id]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick$1().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
      }
      const $reset = noop$4;
      function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia2._s.delete($id);
      }
      function wrapAction(name, action) {
        return function() {
          setActivePinia(pinia2);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name,
            store,
            after,
            onError
          });
          let ret;
          try {
            ret = action.apply(this && this.$id === $id ? this : store, args);
          } catch (error) {
            triggerSubscriptions(onErrorCallbackList, error);
            throw error;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error) => {
              triggerSubscriptions(onErrorCallbackList, error);
              return Promise.reject(error);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
      }
      const partialStore = {
        _p: pinia2,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id,
                type: MutationType.direct,
                events: debuggerEvents
              }, state);
            }
          }, assign({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store = reactive(assign({}, partialStore));
      pinia2._s.set($id, store);
      const setupStore = pinia2._e.run(() => {
        scope = effectScope();
        return scope.run(() => setup());
      });
      for (const key in setupStore) {
        const prop = setupStore[key];
        if (isRef$1(prop) && !isComputed(prop) || isReactive$1(prop)) {
          if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop)) {
              if (isRef$1(prop)) {
                prop.value = initialState[key];
              } else {
                mergeReactiveObjects(prop, initialState[key]);
              }
            }
            {
              pinia2.state.value[$id][key] = prop;
            }
          }
        } else if (typeof prop === "function") {
          const actionValue = wrapAction(key, prop);
          {
            setupStore[key] = actionValue;
          }
          optionsForPlugin.actions[key] = prop;
        } else
          ;
      }
      {
        assign(store, setupStore);
        assign(toRaw(store), setupStore);
      }
      Object.defineProperty(store, "$state", {
        get: () => pinia2.state.value[$id],
        set: (state) => {
          $patch(($state) => {
            assign($state, state);
          });
        }
      });
      pinia2._p.forEach((extender) => {
        {
          assign(store, scope.run(() => extender({
            store,
            app: pinia2._a,
            pinia: pinia2,
            options: optionsForPlugin
          })));
        }
      });
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store;
    }
    function defineStore(idOrOptions, setup, setupOptions) {
      let id;
      let options;
      const isSetupStore = typeof setup === "function";
      if (typeof idOrOptions === "string") {
        id = idOrOptions;
        options = isSetupStore ? setupOptions : setup;
      } else {
        options = idOrOptions;
        id = idOrOptions.id;
      }
      function useStore(pinia2, hot) {
        const currentInstance2 = getCurrentInstance();
        pinia2 = pinia2 || currentInstance2 && inject(piniaSymbol);
        if (pinia2)
          setActivePinia(pinia2);
        pinia2 = activePinia;
        if (!pinia2._s.has(id)) {
          if (isSetupStore) {
            createSetupStore(id, setup, options, pinia2);
          } else {
            createOptionsStore(id, options, pinia2);
          }
        }
        const store = pinia2._s.get(id);
        return store;
      }
      useStore.$id = id;
      return useStore;
    }
    function storeToRefs(store) {
      if (isVue2) {
        return toRefs(store);
      } else {
        store = toRaw(store);
        const refs = {};
        for (const key in store) {
          const value = store[key];
          if (isRef$1(value) || isReactive$1(value)) {
            refs[key] = toRef(store, key);
          }
        }
        return refs;
      }
    }
    const useUserStore = defineStore("user", {
      state: () => ({
        accessToken: "",
        userInfo: null
      }),
      getters: {
        userName: (state) => {
          var _a;
          return ((_a = state.userInfo) == null ? void 0 : _a.username) || "";
        },
        avatar: (state) => {
          var _a;
          return ((_a = state.userInfo) == null ? void 0 : _a.avatar) || "";
        },
        uid: (state) => {
          var _a;
          return ((_a = state.userInfo) == null ? void 0 : _a.uid) || "";
        },
        isLogin: (state) => !!state.accessToken,
        isAdmin: (state) => {
          var _a, _b;
          return (_b = (_a = state.userInfo) == null ? void 0 : _a.roleNames) == null ? void 0 : _b.includes("admin");
        }
      },
      actions: {
        async fetchUserInfo() {
          if (!this.isLogin)
            return;
          const { data: data2 } = await logtoMeApi.get("");
          this.userInfo = {
            ...this.userInfo,
            avatar: data2.avatar || ""
          };
        },
        async updateAvatar(img) {
          if (!this.isLogin)
            return;
          await logtoMeApi.patch("", {
            avatar: img
          });
          this.userInfo = {
            ...this.userInfo,
            avatar: img
          };
        },
        setUserInfo(accessToken, userInfo) {
          this.accessToken = accessToken;
          this.userInfo = userInfo;
        },
        clearUserInfo() {
          this.accessToken = "";
          this.userInfo = null;
        }
      }
    });
    const apiURL = "/site";
    function setLang(lang2) {
      defaults$5.headers["x-language"] = lang2;
    }
    function setToken(token) {
      defaults$5.headers.Authorization = "Bearer " + token;
    }
    async function persistToken() {
      const { getAccessToken, getIdTokenClaims } = $a52d863b14a9eb8e$export$44fc9df4d2a1789a();
      const token = await (getAccessToken == null ? void 0 : getAccessToken("https://api.logto.io")) || "";
      const userInfo = await getIdTokenClaims();
      if (token)
        setToken(token);
      if (token && userInfo) {
        useUserStore().setUserInfo(token, {
          username: userInfo.username || userInfo.name || "",
          avatar: userInfo.avatar || "",
          roleNames: (userInfo == null ? void 0 : userInfo.role_names) || [],
          uid: userInfo.sub || ""
        });
      }
      return {
        token,
        userInfo
      };
    }
    const downloadApi = mande(`${apiURL}/api/data/download`);
    const materialApi = mande(`${apiURL}/api/data/material`);
    const projectApi = mande(`${apiURL}/api/data/project`);
    const logtoMeApi = mande(`${apiURL}/api/users/me`);
    const templatePreviewUrl = (templateId) => `${apiURL}/api/data/template/preview/${templateId}`;
    const i18nText = {
      zh: {
        loading: "\u52A0\u8F7D\u4E2D",
        downloadLoading: "\u6B63\u5728\u4E0B\u8F7D\u4E2D",
        unknownError: "\u672A\u77E5\u9519\u8BEF",
        projectSetting: "\u9879\u76EE\u8BBE\u7F6E",
        download: "\u4E0B\u8F7D",
        imageError: "\u56FE\u7247\u4E0A\u4F20\u5931\u8D25",
        SwitchDisplayMode: "\u5207\u6362\u5C55\u793A\u6A21\u5F0F",
        SwitchMaterialPanel: "\u5207\u6362\u7D20\u6750\u680F",
        SwitchConfigPanel: "\u5207\u6362\u8BBE\u7F6E\u680F",
        location: "\u91CD\u65B0\u5B9A\u4F4D",
        undo: "\u64A4\u9500",
        redo: "\u91CD\u505A",
        delete: "\u5220\u9664",
        sync: "\u540C\u6B65",
        copyComponent: "\u590D\u5236\u5F53\u524D\u7EC4\u4EF6",
        cut: "\u526A\u5207\u5230\u526A\u8D34\u677F",
        copyToClipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
        paste: "\u7C98\u8D34",
        pasteToInside: "\u7C98\u8D34\u5230\u9009\u4E2D\u7EC4\u4EF6\u5185",
        saveProject: "\u4FDD\u5B58\u9879\u76EE",
        saveMaterial: "\u4FDD\u5B58\u7EC4\u4EF6",
        switchDevice: "\u5207\u6362\u8BBE\u5907\u6A21\u5F0F",
        collapseAll: "\u6298\u53E0\u5168\u90E8\u914D\u7F6E\u9879",
        switchSection: "\u5207\u6362\u5230\u6307\u5B9A\u7AE0\u8282",
        nextSection: "\u4E0B\u4E00\u4E2A\u7AE0\u8282",
        prevSection: "\u4E0A\u4E00\u4E2A\u7AE0\u8282",
        nextComponent: "\u5207\u6362\u5230\u4E0B\u4E00\u4E2A\u540C\u7EA7\u7EC4\u4EF6",
        prevComponent: "\u5207\u6362\u5230\u4E0A\u4E00\u4E2A\u540C\u7EA7\u7EC4\u4EF6",
        parentComponent: "\u5207\u6362\u5230\u7236\u7EA7\u7EC4\u4EF6",
        childrenComponent: "\u5207\u6362\u5230\u5B50\u7EA7\u7EC4\u4EF6",
        switchShortcut: "\u5FEB\u6377\u952E\u5C55\u793A",
        noSectionTip: "\u4F7F\u7528\u300C\u7EC4\u4EF6\u300D\u524D\u9700\u8981\u5148\u6DFB\u52A0\u300C\u7AE0\u8282\u300D",
        deleteConfirm: "\u786E\u5B9A\u5220\u9664 {0} \u5417\uFF1F",
        deleteSuccess: "\u5220\u9664\u6210\u529F",
        notGroup: "\u672A\u5206\u7EC4",
        project: "\u9879\u76EE",
        template: "\u6A21\u677F",
        section: "\u7AE0\u8282",
        component: "\u7EC4\u4EF6",
        templateTip: "\u9009\u62E9\u4F60\u559C\u6B22\u7684\u6A21\u677F",
        templateStart: "\u5F00\u59CB\u521B\u9020\u4F60\u7684\u7F51\u7AD9",
        edit: "\u7F16\u8F91",
        noDataPlaceholder: "\u70B9\u51FB\u5DE6\u4FA7\u300C+\u300D\u53F7\uFF0C\u70B9\u51FB\u6216\u62D6\u62FD\u300C\u7AE0\u8282\u300D\u6DFB\u52A0\u5185\u5BB9",
        prevNode: "\u4E0A\u4E00\u4E2A\u7EC4\u4EF6",
        nextNode: "\u4E0B\u4E00\u4E2A\u7EC4\u4EF6",
        parentNode: "\u7236\u7EC4\u4EF6",
        childrenNode: "\u5B50\u7EC4\u4EF6",
        nameValidTip: "\u540D\u5B57\u4E0D\u80FD\u4F7F\u7528\u7279\u6B8A\u5B57\u7B26",
        nameExistTip: "\u540D\u79F0\u5DF2\u5B58\u5728",
        layers: "\u56FE\u5C42",
        ungroup: "\u89E3\u9664\u5206\u7EC4",
        ungroupTip: "\u6B64\u64CD\u4F5C\u4E0D\u53EF\u9006\uFF0C\u64A4\u9500\u53EF\u8FD8\u539F\u3002",
        ungroupNotify: "\u82E5\u9700\u8981\u5728\u5176\u4E2D\u6DFB\u52A0\u6216\u4FEE\u6539\uFF0C\u8BF7\u5148\u70B9\u51FB\u4E0A\u65B9\u7684\u300C\u89E3\u9664\u5206\u7EC4\u300D\u6309\u94AE",
        hidden: "\u9690\u85CF",
        visible: "\u663E\u793A",
        save: "\u4FDD\u5B58",
        copy: "\u590D\u5236",
        cutSuccess: "\u5DF2\u526A\u5207\u7EC4\u4EF6",
        copySuccess: "\u5DF2\u590D\u5236\u7EC4\u4EF6",
        pasteSuccess: "\u7C98\u8D34\u7EC4\u4EF6\u6210\u529F",
        brokenLink: "\u53D6\u6D88\u5173\u8054",
        linkTip: "\u662F\u5426\u5173\u8054\u5230\u539F\u7EC4\u4EF6",
        linkTipMsg: "\u5173\u8054\u540E\uFF0C\u7EC4\u4EF6\u7684\u914D\u7F6E\u548C\u5185\u5BB9\u4F1A\u540C\u6B65\u66F4\u65B0\u3002\n\u4E0D\u8FC7\u53EF\u4EE5\u70B9\u51FB\u300C\u53D6\u6D88\u5173\u8054\u300D\u6309\u94AE\u53D6\u6D88\u5355\u4E2A\u6216\u8005\u5168\u90E8\u914D\u7F6E\u7684\u5173\u8054\u3002",
        unlink: "\u89E3\u9664\u5173\u8054",
        unlinkSelf: "\u53EA\u89E3\u9664\u81EA\u8EAB",
        unlinkAll: "\u5305\u542B\u5B50\u7EC4\u4EF6",
        saveOf: "\u4FDD\u5B58\u4E3A",
        signOutTip: "\u9000\u51FA\u767B\u5F55\u540E\u4F60\u7684\u6570\u636E\u53EF\u80FD\u4F1A\u4E22\u5931",
        signOutTipTitle: "\u786E\u5B9A\u9000\u51FA\u767B\u5F55\u5417",
        routerDataTip: "\u4F60\u7684\u6570\u636E\u4ECD\u672A\u4FDD\u5B58\uFF0C\u786E\u5B9A\u8DF3\u8F6C\u5417",
        headerWidth: "\u5BBD\u5EA6",
        headerHeight: "\u9AD8\u5EA6",
        desktop: "\u684C\u9762\u7AEF",
        mobile: "\u79FB\u52A8\u7AEF",
        bothClient: "\u684C\u9762&\u79FB\u52A8\u7AEF",
        editMode: "\u7F16\u8F91\u6A21\u5F0F",
        dragMode: "\u62D6\u62FD\u6A21\u5F0F",
        previewMode: "\u9884\u89C8\u6A21\u5F0F",
        simulator: "\u6A21\u62DF\u5668",
        zoom: "\u7F29\u653E",
        mediaFontSize: "\u81EA\u9002\u5E94\u57FA\u51C6\u5B57\u53F7",
        mediaFontSizeTip: "\u5F53\u6D4F\u89C8\u5668\u5BBD\u5EA6\u5927\u4E8E\u7B49\u4E8E\u5F53\u524D\u6A21\u62DF\u8BBE\u5907\u5BBD\u5EA6\u65F6\uFF0C\u5B57\u53F7\u81EA\u52A8\u8C03\u6574\u4E3A\u8BBE\u7F6E\u5B57\u53F7\u3002",
        profile: "\u4E2A\u4EBA\u9875\u9762",
        signOut: "\u9000\u51FA\u767B\u5F55",
        signIn: "\u767B\u5F55",
        layout: "\u5E03\u5C40",
        size: "\u5C3A\u5BF8",
        spacing: "\u95F4\u8DDD",
        border: "\u8FB9\u6846",
        font: "\u5B57\u4F53",
        background: "\u80CC\u666F",
        container: "\u5BB9\u5668",
        basic: "\u57FA\u7840",
        position: "\u4F4D\u7F6E",
        event: "\u4E8B\u4EF6",
        animation: "\u52A8\u753B",
        effect: "\u6548\u679C",
        custom: "\u81EA\u5B9A\u4E49",
        notCover: "\u672A\u8BBE\u7F6E\u5C01\u9762",
        nameRequired: "\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A",
        saveSuccess: "\u4FDD\u5B58\u6210\u529F",
        name: "\u540D\u79F0",
        nameEn: "\u540D\u79F0(En)",
        category: "\u7C7B\u522B",
        categoryEn: "\u7C7B\u522B(En)",
        moduleSwitch: "\u5C01\u88C5",
        projectNameRequired: "\u9879\u76EE\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A",
        cover: "\u5C01\u9762\u56FE",
        ok: "\u786E\u5B9A",
        cancel: "\u53D6\u6D88",
        margin: "\u5916\u8FB9\u8DDD",
        padding: "\u5185\u8FB9\u8DDD",
        width: "\u5BBD\u5EA6",
        height: "\u9AD8\u5EA6",
        minWidth: "\u6700\u5C0F\u5BBD\u5EA6",
        maxWidth: "\u6700\u5927\u5BBD\u5EA6",
        minHeight: "\u6700\u5C0F\u9AD8\u5EA6",
        maxHeight: "\u6700\u5927\u9AD8\u5EA6",
        static: "\u9759\u6001\u5B9A\u4F4D",
        absolute: "\u7EDD\u5BF9\u5B9A\u4F4D",
        fixed: "\u56FA\u5B9A\u5B9A\u4F4D",
        direction: "\u65B9\u5411",
        fixedTip: "\u4F7F\u7528 Fixed \u65F6\u8BF7\u786E\u4FDD\u4F60\u7684\u5143\u7D20\u7F6E\u4E8E\u6700\u9876\u5C42\u5BB9\u5668\u4E2D",
        alwaysCenter: "\u603B\u662F\u5C45\u4E2D",
        all: "\u5168\u90E8",
        left: "\u5DE6",
        right: "\u53F3",
        top: "\u4E0A",
        bottom: "\u4E0B",
        lock: "\u9501\u5B9A",
        zIndex: "\u5C42\u7EA7",
        justifyStart: "\u5F00\u5934",
        justifyCenter: "\u5C45\u4E2D",
        justifyEnd: "\u7ED3\u5C3E",
        justifySpaceAround: "\u5747\u5300\u6392\u5217-\u7A7A\u95F4",
        justifySpaceBetween: "\u5747\u5300\u6392\u5217-\u8D77\u59CB",
        justifySpaceEvenly: "\u5747\u5300\u6392\u5217-\u95F4\u9694",
        alignStart: "\u5F00\u5934",
        alignCenter: "\u5C45\u4E2D",
        alignEnd: "\u7ED3\u5C3E",
        alignStretch: "\u62C9\u4F38",
        alignBaseline: "\u57FA\u7EBF",
        row: "\u6A2A\u5411",
        column: "\u7EB5\u5411",
        mainAxisAlign: "\u4E3B\u65B9\u5411\u5BF9\u9F50",
        crossAxisAlign: "\u7EB5\u5411\u5BF9\u9F50",
        wrap: "\u662F\u5426\u6362\u884C",
        reverse: "\u662F\u5426\u53CD\u5411\u6392\u5217",
        unitCircle: "\u5706\u5F62",
        unitRefined: "\u7CBE\u7EC6\u914D\u7F6E",
        unitAuto: "\u81EA\u9002\u5E94",
        unitNone: "\u65E0\u9650\u5236",
        unitStretch: "\u62C9\u4F38",
        fontSize: "\u5B57\u53F7",
        fontColor: "\u989C\u8272",
        lineHeight: "\u884C\u9AD8",
        fontWeight: "\u5B57\u91CD",
        textShadow: "\u6587\u5B57\u9634\u5F71",
        fontFamily: "\u5B57\u4F53",
        eventTriggerType: "\u89E6\u53D1\u65B9\u5F0F",
        eventTap: "\u70B9\u51FB",
        eventMouseDown: "\u9F20\u6807\u6309\u4E0B",
        eventTouchStart: "\u624B\u6307\u6309\u4E0B",
        link: "\u94FE\u63A5",
        function: "\u811A\u672C\u65B9\u6CD5",
        functionTip: "\u4FEE\u6539\u7684\u7EC4\u4EF6\u914D\u7F6E\u4F1A\u7ACB\u5373\u751F\u6548\uFF0C\u82E5\u60F3\u5728\u9884\u89C8\u6A21\u5F0F\u4E2D\u89E6\u53D1\u4E8B\u4EF6\uFF0C\u8BF7\u5148\u70B9\u51FB\u53F3\u4FA7\u89E3\u9501\u6309\u94AE\u3002",
        scrollTo: "\u6EDA\u52A8\u81F3",
        scrollToPlaceholder: "\u7EC4\u4EF6\u540D\u79F0\u6216\u8005\u9876\u90E8\u8DDD\u79BB",
        componentName: "\u7EC4\u4EF6\u540D\u79F0",
        linkPlaceholder: "\u8F93\u5165\u4E00\u4E2A\u94FE\u63A5",
        functionPlaceholder: "`event`: \u672C\u6B21\u4E8B\u4EF6\u53C2\u6570\n`data`: \u7EC4\u4EF6\u6570\u636E\n`getByName`: \u901A\u8FC7\u540D\u5B57\u83B7\u53D6\u5143\u7D20\n`getByTag`: \u901A\u8FC7 Tag \u83B7\u53D6\u5143\u7D20\u5217\u8868",
        stopPropagation: "\u963B\u6B62\u5192\u6CE1",
        openNewTab: "\u5728\u65B0\u6807\u7B7E\u9875\u6253\u5F00",
        hover: "\u60AC\u505C",
        active: "\u6FC0\u6D3B",
        ease: "\u7F13\u52A8",
        easeIn: "\u7F13\u52A8\u8FDB\u5165",
        easeOut: "\u7F13\u52A8\u51FA\u53BB",
        easeInOut: "\u7F13\u52A8\u8FDB\u51FA",
        linear: "\u7EBF\u6027",
        chooseAStyle: "\u9009\u62E9\u4E00\u79CD\u6837\u5F0F",
        target: "\u76EE\u6807",
        style: "\u6837\u5F0F",
        duration: "\u65F6\u957F",
        timing: "\u65F6\u5E8F",
        timingCode: "\u65F6\u5E8F\u4EE3\u7801",
        action: "\u52A8\u4F5C",
        addEffect: "\u6DFB\u52A0\u6548\u679C",
        opacity: "\u900F\u660E\u5EA6",
        filterBlur: "\u9AD8\u65AF\u6A21\u7CCA",
        filterCode: "\u6EE4\u955C\u4EE3\u7801",
        overflow: "\u6EA2\u51FA\u5904\u7406",
        scroll: "\u6EDA\u52A8",
        auto: "\u81EA\u52A8",
        cursor: "\u5149\u6807",
        inherit: "\u7EE7\u627F",
        default: "\u9ED8\u8BA4",
        pointer: "Pointer",
        move: "Move",
        text: "Text",
        wait: "Wait",
        help: "Help",
        notAllowed: "\u7981\u7528\u6001",
        shadow: "\u9634\u5F71",
        customShadow: "\u81EA\u5B9A\u4E49\u9634\u5F71",
        borderWidth: "\u8FB9\u6846\u5BBD\u5EA6",
        borderColor: "\u8FB9\u6846\u989C\u8272",
        borderStyle: "\u8FB9\u6846\u6837\u5F0F",
        cornerRadius: "\u5706\u89D2",
        preview: "\u9884\u89C8",
        textEmptyTip: "\u6587\u5B57\u4E3A\u7A7A\u65F6\u4F1A\u81EA\u52A8\u79FB\u9664\u8BE5\u7EC4\u4EF6",
        imgSrc: "\u56FE\u7247\u5730\u5740",
        whiteSpace: "\u5904\u7406\u65B9\u5F0F",
        whiteSpaceNormal: "\u6B63\u5E38",
        whiteSpaceNowrap: "\u4E0D\u6362\u884C",
        whiteSpacePre: "\u4FDD\u7559\u7A7A\u683C",
        whiteSpacePreWrap: "\u4FDD\u7559\u7A7A\u683C\u5E76\u6362\u884C",
        whiteSpacePreLine: "\u4FDD\u7559\u7A7A\u683C\u5E76\u81EA\u52A8\u6362\u884C",
        objectFit: "\u5BF9\u9F50\u65B9\u5F0F",
        objectFitContain: "\u539F\u6BD4\u4F8B-\u7F29\u653E",
        objectFitCover: "\u539F\u6BD4\u4F8B-\u88C1\u5207",
        objectFitFill: "\u586B\u5145",
        objectFitNone: "\u65E0",
        objectFitScaleDown: "\u539F\u6BD4\u4F8B-\u81EA\u52A8\u7F29\u653E",
        iconTip: '\u9ED8\u8BA4\u4F7F\u7528\u7B2C\u4E09\u65B9 CDN \u52A0\u8F7D\u56FE\u6807\uFF0C\u4E0D\u4FDD\u8BC1\u7A33\u5B9A\u6027\u3002\u56FE\u6807\u4F7F\u7528\u7684\u662F FontAwesome\uFF0C\u66F4\u591A\u56FE\u6807\u67E5\u9605\uFF1A<a href="https://fontawesome.com/v4/icons/" target="_blank">https://fontawesome.com/v4/icons/</a>',
        iconName: "\u56FE\u6807\u540D\u79F0",
        iconSize: "\u5C3A\u5BF8",
        iconColor: "\u989C\u8272",
        prefixClass: "Prefix Class",
        extraClass: "Extra Class",
        cssLink: "CSS Link",
        backgroundTypeNone: "\u65E0",
        backgroundTypeColor: "\u989C\u8272",
        backgroundTypeImage: "\u56FE\u7247",
        backgroundTypeGradient: "\u6E10\u53D8",
        backgroundColor: "\u80CC\u666F\u8272",
        backgroundLink: "\u56FE\u7247\u5730\u5740",
        backgroundSize: "\u56FE\u7247\u5927\u5C0F",
        backgroundSizeCover: "\u539F\u6BD4\u4F8B-\u88C1\u5207",
        backgroundSizeContain: "\u539F\u6BD4\u4F8B-\u7F29\u653E",
        backgroundSizeAuto: "\u81EA\u52A8",
        backgroundPosition: "\u80CC\u666F\u4F4D\u7F6E",
        backgroundRepeat: "\u80CC\u666F\u91CD\u590D",
        backgroundRepeatRepeat: "\u91CD\u590D",
        backgroundRepeatRepeatX: "\u6C34\u5E73\u91CD\u590D",
        backgroundRepeatRepeatY: "\u5782\u76F4\u91CD\u590D",
        backgroundRepeatNoRepeat: "\u4E0D\u91CD\u590D",
        fixedBackground: "\u56FA\u5B9A\u80CC\u666F",
        angle: "\u89D2\u5EA6",
        colorIndex: "\u989C\u8272 {0}",
        addColor: "\u6DFB\u52A0\u989C\u8272",
        fade: "\u6E10\u53D8",
        slideUp: "\u4E0A\u6ED1",
        slideDown: "\u4E0B\u6ED1",
        slideLeft: "\u5DE6\u6ED1",
        slideRight: "\u53F3\u6ED1",
        zoomIn: "\u7F29\u5C0F",
        zoomOut: "\u653E\u5927",
        rotateX: "X \u8F74\u65CB\u8F6C",
        rotateY: "Y \u8F74\u65CB\u8F6C",
        animationTriggerHover: "\u60AC\u505C",
        animationTriggerClick: "\u70B9\u51FB",
        animationTriggerScrollIntoView: "\u8FDB\u5165\u7A97\u53E3\u65F6",
        animationTriggerAlways: "\u603B\u662F",
        animationFillModeForwards: "\u6700\u540E\u4E00\u5E27",
        animationFillModeBackwards: "\u7B2C\u4E00\u5E27",
        animationFillModeBoth: "\u4E24\u8005",
        animationFillModeNone: "\u65E0",
        animationDirectionNormal: "\u6B63\u5E38",
        animationDirectionReverse: "\u53CD\u5411",
        animationDirectionAlternate: "\u4EA4\u66FF",
        animationDirectionAlternateReverse: "\u4EA4\u66FF\u53CD\u5411",
        animationTip: "\u53EA\u53EF\u5728 Preview \u6A21\u5F0F\u4E0B\u80FD\u9884\u89C8\u52A8\u753B\u6548\u679C",
        animationOffset: "\u504F\u79FB\u8DDD\u79BB(%)",
        delay: "\u5EF6\u8FDF(\u79D2)",
        fillMode: "\u7ED3\u675F\u6837\u5F0F",
        addAnimation: "\u6DFB\u52A0\u52A8\u753B",
        upload: "\u4E0A\u4F20",
        imageLoadError: "\u56FE\u7247\u52A0\u8F7D\u5931\u8D25",
        recentColor: "\u6700\u8FD1\u4F7F\u7528",
        colorVariable: "\u989C\u8272\u53D8\u91CF",
        colorVarImportTip: "\u5DF2\u5F15\u5165\u65B0\u7684\u989C\u8272\u53D8\u91CF",
        fontFaceImportTip: "\u5DF2\u5F15\u5165\u65B0\u7684\u5B57\u4F53",
        saveVariable: "\u4FDD\u5B58\u53D8\u91CF",
        pageTitlePlaceholder: "\u5C55\u793A\u5728\u6807\u7B7E\u7684\u7F51\u7AD9\u6807\u9898",
        pageDescriptionPlaceholder: "\u7B80\u77ED\u7684\u63CF\u8FF0\u6709\u5229\u4E8E\u641C\u7D22\u5F15\u64CE\u4F18\u5316",
        pageFavicon: "\u5FBD\u6807",
        rootFontSize: "\u57FA\u51C6\u5B57\u53F7",
        fontFaceName: "Name",
        fontFaceSrc: "Source",
        fontFaceStyle: "Style",
        fontFaceWeight: "Weight",
        fontFaceLink: "\u5B57\u4F53\u8D44\u6E90\u8DEF\u5F84",
        addFontFace: "\u6DFB\u52A0\u5B57\u4F53",
        colorVariableName: "\u53D8\u91CF",
        colorVariableColor: "\u989C\u8272",
        redirectLoading: "\u6B63\u5728\u91CD\u5B9A\u5411\u4E2D...",
        pageNotFound: "\u9875\u9762\u4E0D\u5B58\u5728",
        backToHome: "\u8FD4\u56DE\u9996\u9875",
        createTemplateTip: "\u662F\u5426\u4F7F\u7528\u8BE5\u6A21\u677F\u521B\u5EFA\u65B0\u9879\u76EE",
        newProject: "\u65B0\u5EFA\u9879\u76EE",
        emptyProject: "\u7A7A\u9879\u76EE",
        notSaveDataTip: "\u4F60\u6709\u4E0A\u6B21\u7F16\u8F91\u4ECD\u672A\u4FDD\u5B58\u7684\u6570\u636E\uFF0C\u662F\u5426\u6062\u590D\uFF1F",
        pageGlobalSetting: "\u9875\u9762\u8BBE\u7F6E",
        fontSetting: "\u5B57\u4F53\u8BBE\u7F6E",
        shortcut: "\u5FEB\u6377\u952E",
        material: "\u7D20\u6750",
        materialExistTip: "\u662F\u5426\u8986\u76D6\u539F\u6709\u7D20\u6750\uFF1F",
        materialExistTipMsg: "\u82E5\u786E\u5B9A\uFF0C\u539F\u6709\u7D20\u6750 \u300C{0}\u300D \u5C06\u88AB\u8986\u76D6",
        newMaterial: "\u65B0\u5EFA\u7D20\u6750",
        uploadTip: "\u4F7F\u7528\u7B2C\u4E09\u65B9\u56FE\u5C42\uFF0C\u4E0D\u4FDD\u8BC1\u7A33\u5B9A\u6027\u3002",
        addTag: "\u6DFB\u52A0\u6807\u7B7E",
        advancedOptions: "\u9AD8\u7EA7\u8BBE\u7F6E",
        hideAdvancedOptions: "\u9690\u85CF\u9AD8\u7EA7\u8BBE\u7F6E",
        autoCreateCover: "\u751F\u6210\u5C01\u9762",
        saveToTemplate: "\u4FDD\u5B58\u4E3A\u6A21\u677F",
        setting: "\u8BBE\u7F6E",
        switchToZH: "\u5207\u6362\u81F3\u4E2D\u6587",
        switchToEN: "Switch To English",
        switchLangTip: "\u5207\u6362\u8BED\u8A00\u9700\u8981\u5237\u65B0\u9875\u9762\uFF0C\u662F\u5426\u7EE7\u7EED\uFF1F",
        configMobile: "\u79FB\u52A8\u7AEF",
        configBoth: "\u53CC\u7AEF",
        configMobileTip: "\u53EA\u5E94\u7528\u4E8E\u79FB\u52A8\u7AEF",
        configBothTip: "\u4E0D\u533A\u5206\u79FB\u52A8\u7AEF",
        supportDevice: "\u652F\u6301\u8BBE\u5907",
        pageTitle: "\u7F51\u7AD9\u6807\u9898",
        pageDescription: "\u63CF\u8FF0",
        question: "\u5E38\u89C1\u95EE\u9898",
        question1: "\u{1F4A1} \u5982\u4F55\u7406\u89E3\u9875\u9762\u7ED3\u6784\uFF1F",
        answer1: "\u4E00\u4E2A\u9875\u9762\u662F\u7531\u591A\u4E2A\u7AE0\u8282\u5806\u53E0\u7EC4\u6210\u7684\uFF0C\u7AE0\u8282\u4E2D\u53EF\u4EE5\u6DFB\u52A0\u4EFB\u610F\u6570\u91CF\u7684\u7EC4\u4EF6\u3002",
        question2: "\u{1F4A1} \u5E94\u8BE5\u4F7F\u7528\u54EA\u79CD\u5355\u4F4D\uFF1F",
        answer2: `
<li>px: \u7EDD\u5BF9\u5355\u4F4D\uFF0C\u8868\u793A\u50CF\u7D20\uFF0C\u53EF\u4EE5\u7406\u89E3\u4E3A\u50CF\u7D20\u503C</li>
<small>1px \u7B49\u4E8E\u4E00\u4E2A\u50CF\u7D20\u503C\uFF0C\u5982\u679C\u4F60\u4E0D\u9700\u8981\u517C\u5BB9\u592A\u591A\u573A\u666F\uFF0C\u53EF\u4EE5\u76F4\u63A5\u4F7F\u7528 px \u5355\u4F4D\u3002</small>
<li>rem: \u76F8\u5BF9\u5355\u4F4D\uFF0C\u8868\u793A\u76F8\u5BF9\u4E8E\u57FA\u51C6\u5B57\u53F7\u7684\u50CF\u7D20\u503C</li>
<small>1rem \u7B49\u4E8E\u57FA\u51C6\u5B57\u53F7\u5927\u5C0F\uFF0C\u9ED8\u8BA4\u60C5\u51B5\u4E0B\u7B49\u4E8E\u300C\u57FA\u51C6\u5B57\u53F7\u300D\u3002<br/>
\u53EF\u4EE5\u901A\u8FC7\u5728\u300C\u6A21\u62DF\u5668\u300D\u4E2D\u8BBE\u7F6E\u300C\u81EA\u9002\u5E94\u57FA\u51C6\u5B57\u53F7\u300D\u53BB\u7CBE\u7EC6\u5316\u63A7\u5236\u5404\u79CD\u8BBE\u5907\u5BBD\u5EA6\u4E0B\u7684\u57FA\u51C6\u503C\u3002</small>
<li>vw: \u767E\u5206\u6BD4\u5355\u4F4D\uFF0C\u8868\u793A\u76F8\u5BF9\u4E8E\u89C6\u53E3\u5BBD\u5EA6\u7684\u767E\u5206\u6BD4</li>
<small>1vw \u7B49\u4E8E\u89C6\u53E3\u5BBD\u5EA6\u7684\u767E\u5206\u4E4B\u4E00\u3002\u4E3A\u684C\u9762\u7AEF\u548C\u79FB\u52A8\u7AEF\u5206\u522B\u8BBE\u7F6E\u8BE5\u503C\uFF0C\u5373\u53EF\u65B9\u4FBF\u517C\u5BB9\u5927\u90E8\u5206\u573A\u666F\u3002</small>
<li>%\uFF1A\u767E\u5206\u6BD4\u5355\u4F4D\uFF0C\u8868\u793A\u76F8\u5BF9\u4E8E\u7236\u5143\u7D20\u7684\u767E\u5206\u6BD4</li>
<small>1% \u7B49\u4E8E\u7236\u5143\u7D20\u7684\u767E\u5206\u4E4B\u4E00\u3002\u4E00\u822C\u7528\u4E8E\u8BBE\u7F6E\u5BB9\u5668\u7684\u5BBD\u9AD8\u7B49\u3002</small>
    `,
        question3: "\u{1F4A1} \u5982\u4F55\u65B0\u589E\u5B57\u4F53\uFF1F",
        answer3: `
\u53EF\u4EE5\u901A\u8FC7\u300C\u5B57\u4F53\u8BBE\u7F6E\u300D\u6765\u65B0\u589E\u5B57\u4F53\uFF0C\u76EE\u524D\u53EA\u652F\u6301\u901A\u8FC7\u5F15\u5165\u5B57\u4F53\u8D44\u6E90\u8DEF\u5F84\u7684\u65B9\u5F0F\u6765\u65B0\u589E\u5B57\u4F53\u3002<br/>
\u6700\u7B80\u5355\u7684\u65B9\u5F0F\u5C31\u662F\u5728 Google Fonts \u4E2D\u9009\u62E9\u4E00\u4E2A\u5B57\u4F53\uFF0C\u7136\u540E\u5C06\u5B57\u4F53\u8D44\u6E90\u8DEF\u5F84\u590D\u5236\u5230\u300C\u5B57\u4F53\u8BBE\u7F6E\u300D\u4E2D\u3002
\u5E76\u5728\u300C\u5B57\u4F53\u8BBE\u7F6E\u300D\u4E2D\u6DFB\u52A0\u5230\u300C\u5B57\u4F53\u300D\u4E2D\u6216\u5728\u6587\u672C\u7EC4\u4EF6\u4E2D\u7684\u5355\u72EC\u8BBE\u7F6E\u3002
`,
        question4: "\u{1F4EE} \u610F\u89C1\u53CD\u9988",
        answer4: `\u6B22\u8FCE\u53D1\u9001\u90AE\u4EF6 \u2192 <a target="_blank" href="mailto:nightcat@hzfe.org">nightcat@hzfe.org</a>`
      },
      en: {
        loading: "Loading...",
        downloadLoading: "Downloading...",
        unknownError: "Unknown Error",
        projectSetting: "Project Setting",
        download: "Download",
        imageError: "Image Upload Failure",
        SwitchDisplayMode: "Switch Display Mode",
        SwitchMaterialPanel: "Collapse Material Panel",
        SwitchConfigPanel: "Collapse Config Panel",
        location: "Location",
        undo: "Undo",
        redo: "Redo",
        delete: "Delete",
        sync: "Sync",
        copyComponent: "Copy Component",
        cut: "Cut to Clipboard",
        copyToClipboard: "Copy to Clipboard",
        paste: "Paste",
        pasteToInside: "Paste to inside",
        saveProject: "Save Project",
        saveMaterial: "Save as Material",
        switchDevice: "Switch Device",
        collapseAll: "Collapse All",
        switchSection: "Switch Section",
        nextSection: "Next Section",
        prevSection: "Prev Section",
        nextComponent: "Next Node",
        prevComponent: "Prev Node",
        parentComponent: "Parent Node",
        childrenComponent: "Children Node",
        switchShortcut: "Shortcut",
        noSectionTip: "Section needs to be added before using Component",
        deleteConfirm: "Sure to delete {0}?",
        deleteSuccess: "Deleted successfully",
        notGroup: "Not Grouped",
        project: "Project",
        template: "Template",
        section: "Section",
        component: "Component",
        templateTip: "Select your favourite template",
        templateStart: "Start creating your website",
        edit: "Edit",
        noDataPlaceholder: 'Click on the "+" sign to add Section',
        prevNode: "Prev Node",
        nextNode: "Next Node",
        parentNode: "Parent Node",
        childrenNode: "Children Node",
        nameValidTip: "No special characters in the name",
        nameExistTip: "Name already exists",
        layers: "Layers",
        ungroup: "Ungroup",
        ungroupTip: "Ungroup is irreversible, and undo can be reverted.",
        ungroupNotify: "If you need to add or modify in it, please click the \u201CUngroup\u201D button above first",
        hidden: "Hidden",
        visible: "Visible",
        save: "Save",
        copy: "Copy",
        cutSuccess: "Cut components",
        copySuccess: "Copied components",
        pasteSuccess: "Paste component successfully",
        brokenLink: "Unlink",
        linkTip: "Whether to link to origin component",
        linkTipMsg: 'After link, the configuration of the component will be updated simultaneously. \nBut you can click the "Unlink" button to unlink single or all configurations.',
        unlink: "Unlink with",
        unlinkSelf: "Self-Unlink",
        unlinkAll: "Includes Children",
        saveOf: "Save as",
        signOutTip: "Data may be lost after sign out",
        signOutTipTitle: "Sure to log out?",
        routerDataTip: "Your data is still not saved, sure to leave this page?",
        headerWidth: "Width",
        headerHeight: "Height",
        desktop: "Desktop",
        mobile: "Mobile",
        bothClient: "Desktop & Mobile",
        editMode: "Edit",
        dragMode: "Drag",
        previewMode: "Preview",
        simulator: "Simulator",
        zoom: "Zoom",
        mediaFontSize: "Media Font Size",
        mediaFontSizeTip: "When the browser width is greater than or equal to the width of the current simulated device, the font size is automatically adjusted to the set font size. Valid when units use rem",
        profile: "Profile",
        signOut: "Sign Out",
        signIn: "Sign In",
        layout: "Layout",
        size: "Size",
        spacing: "Spacing",
        border: "Border",
        font: "Font",
        background: "Background",
        container: "Container",
        basic: "Basic",
        position: "Position",
        event: "Event",
        animation: "Animation",
        effect: "Effect",
        custom: "Custom",
        notCover: "Not Cover",
        nameRequired: "Name cannot be empty",
        saveSuccess: "Saved successfully",
        name: "Name",
        nameEn: "Name(En)",
        category: "Category",
        categoryEn: "Category(En)",
        moduleSwitch: "Module",
        projectNameRequired: "Project name cannot be empty",
        cover: "Cover",
        ok: "OK",
        cancel: "Cancel",
        margin: "Margin",
        padding: "Padding",
        width: "Width",
        height: "Height",
        minWidth: "Min Width",
        maxWidth: "Max Width",
        minHeight: "Min Height",
        maxHeight: "Max Height",
        static: "Static",
        absolute: "Absolute",
        fixed: "Fixed",
        direction: "Direction",
        fixedTip: "When using Fixed, make sure your component is in the topmost section",
        alwaysCenter: "Always Center",
        all: "All",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom",
        lock: "Lock",
        zIndex: "Z-Index",
        justifyStart: "Start",
        justifyCenter: "Center",
        justifyEnd: "End",
        justifySpaceAround: "Space Around",
        justifySpaceBetween: "Space Between",
        justifySpaceEvenly: "Space Evenly",
        alignStart: "Start",
        alignCenter: "Center",
        alignEnd: "End",
        alignStretch: "Stretch",
        alignBaseline: "Baseline",
        row: "Row",
        column: "Column",
        mainAxisAlign: "Main-Axis Align",
        crossAxisAlign: "Cross-Axis Align",
        wrap: "Wrap",
        reverse: "Reverse",
        unitCircle: "Circle",
        unitRefined: "Refined",
        unitAuto: "Adaptive",
        unitNone: "Unlimited",
        unitStretch: "Stretch",
        fontSize: "Font Size",
        fontColor: "Color",
        lineHeight: "Line Height",
        fontWeight: "Font Weight",
        textShadow: "Text Shadow",
        fontFamily: "Font Family",
        eventTriggerType: "Trigger Type",
        eventTap: "Tap",
        eventMouseDown: "Mouse Down",
        eventTouchStart: "Touch Start",
        link: "Link",
        function: "Function",
        functionTip: "The node data modified will take effect immediately. If you want to trigger an event, need to click the unlock button.",
        scrollTo: "Scroll To",
        componentName: "Component Name",
        scrollToPlaceholder: "Component Name or Distance to Top",
        linkPlaceholder: "Enter a link here",
        functionPlaceholder: "`event`: current event\n`data`: node data\n`getByName`: get element by name\n`getByTag`: get element list by tag",
        stopPropagation: "Stop Propagation",
        openNewTab: "Open in New Tab",
        hover: "Hover",
        active: "Active",
        ease: "Ease",
        easeIn: "Ease In",
        easeOut: "Ease Out",
        easeInOut: "Ease In Out",
        linear: "Linear",
        chooseAStyle: "Choose a style",
        target: "Target",
        style: "Style",
        duration: "Duration",
        timing: "Timing",
        timingCode: "Timing Code",
        action: "Action",
        addEffect: "Add Effect",
        opacity: "Opacity",
        filterBlur: "Blur",
        filterCode: "Filter Code",
        overflow: "Overflow",
        scroll: "Scroll",
        auto: "Auto",
        cursor: "Cursor",
        inherit: "Inherit",
        default: "Default",
        pointer: "Pointer",
        move: "Move",
        text: "Text",
        wait: "Wait",
        help: "Help",
        notAllowed: "Not Allowed",
        shadow: "Shadow",
        customShadow: "Custom Shadow",
        borderWidth: "Border Width",
        borderColor: "Border Color",
        borderStyle: "Border Style",
        cornerRadius: "Corner Radius",
        preview: "Preview",
        textEmptyTip: "Text nodes will be automatically removed when empty.",
        imgSrc: "Image Source",
        whiteSpace: "White Space",
        whiteSpaceNormal: "Normal",
        whiteSpaceNowrap: "Nowrap",
        whiteSpacePre: "Pre",
        whiteSpacePreWrap: "Pre-Wrap",
        whiteSpacePreLine: "Pre-Line",
        objectFit: "Object Fit",
        objectFitContain: "Contain",
        objectFitCover: "Cover",
        objectFitFill: "Fill",
        objectFitNone: "None",
        objectFitScaleDown: "Scale Down",
        iconTip: 'Icons are loaded by default using a third party CDN. The default icon is FontAwesome, for more icons see.\uFF1A<a href="https://fontawesome.com/v4/icons/" target="_blank">https://fontawesome.com/v4/icons/</a>',
        iconName: "Name",
        iconSize: "Size",
        iconColor: "Color",
        prefixClass: "Prefix Class",
        extraClass: "Extra Class",
        cssLink: "CSS Link",
        backgroundTypeNone: "None",
        backgroundTypeColor: "Color",
        backgroundTypeImage: "Image",
        backgroundTypeGradient: "Gradient",
        backgroundColor: "Background Color",
        backgroundLink: "Image Source",
        backgroundSize: "Background Size",
        backgroundSizeCover: "Cover",
        backgroundSizeContain: "Contain",
        backgroundSizeAuto: "Auto",
        backgroundPosition: "Background Position",
        backgroundRepeat: "Background Repeat",
        backgroundRepeatRepeat: "Repeat",
        backgroundRepeatRepeatX: "Repeat-X",
        backgroundRepeatRepeatY: "Repeat-Y",
        backgroundRepeatNoRepeat: "None",
        fixedBackground: "Fixed Background",
        angle: "Angle",
        colorIndex: "Color {0}",
        addColor: "Add Color",
        fade: "Fade",
        slideUp: "Slide Up",
        slideDown: "Slide Down",
        slideLeft: "Slide Left",
        slideRight: "Slide Right",
        zoomIn: "Zoom In",
        zoomOut: "Zoom Out",
        rotateX: "Rotate X",
        rotateY: "Rotate Y",
        animationTriggerHover: "Hover",
        animationTriggerClick: "Click",
        animationTriggerScrollIntoView: "Scroll Into View",
        animationTriggerAlways: "Always",
        animationFillModeForwards: "Forwards",
        animationFillModeBackwards: "Backwards",
        animationFillModeBoth: "Both",
        animationFillModeNone: "None",
        animationDirectionNormal: "Normal",
        animationDirectionReverse: "Reverse",
        animationDirectionAlternate: "Alternate",
        animationDirectionAlternateReverse: "Alternate Reverse",
        animationTip: "Animations can only be previewed in Preview Mode",
        animationOffset: "Offset(%)",
        delay: "Delay",
        fillMode: "Fill Mode",
        addAnimation: "Add Animation",
        upload: "Upload",
        imageLoadError: "Image failed to load",
        recentColor: "Recent Color",
        colorVariable: "Variable",
        colorVarImportTip: "New color variable introduced",
        fontFaceImportTip: "New FontFace introduced",
        saveVariable: "Save Variable",
        pageTitlePlaceholder: "Display the title on the Tab",
        pageDescriptionPlaceholder: "Description are good for SEO",
        pageFavicon: "Favicon",
        rootFontSize: "Base Font Size",
        fontFaceName: "Name",
        fontFaceSrc: "Source",
        fontFaceStyle: "Style",
        fontFaceWeight: "Weight",
        fontFaceLink: "Link",
        addFontFace: "Add FontFace",
        colorVariableName: "Name",
        colorVariableColor: "Color",
        redirectLoading: "Redirection in progress...",
        pageNotFound: "Page Not Found",
        backToHome: "Back to Home",
        createTemplateTip: "Whether to use this template to create a new project",
        newProject: "New Project",
        emptyProject: "Empty Project",
        notSaveDataTip: "Do you have data that is still unsaved from the last edit and are you restoring it?",
        pageGlobalSetting: "Page Setting",
        fontSetting: "Font Setting",
        shortcut: "Shortcut",
        material: "Material",
        materialExistTip: "Does it cover the original material?",
        materialExistTipMsg: "If OK, the original material \u201C{0}\u201D will be overwritten",
        newMaterial: "Create a new",
        uploadTip: "The use of third-party image hosting web site does not guarantee stability.",
        addTag: "Add Tag",
        advancedOptions: "Advanced Options",
        hideAdvancedOptions: "Hide Advanced Options",
        autoCreateCover: "Generate Cover",
        saveToTemplate: "Save as Template",
        setting: "Setting",
        switchToZH: "Switch To Chinese",
        switchToEN: "Switch To English",
        switchLangTip: "Switching languages requires a page refresh, does it continue?",
        configMobile: "Mobile",
        configBoth: "Both",
        configMobileTip: "Mobile-Only",
        configBothTip: "Both Desktop & Mobile",
        supportDevice: "Support Device",
        pageTitle: "Title",
        pageDescription: "Desc.",
        question: "FAQ",
        question1: "\u{1F4A1} How to understand the page structure?",
        answer1: "A page is made up of multiple sections stacked on top of each other, and any number of components can be added to the sections.",
        question2: "\u{1F4A1} Which unit should I use?",
        answer2: `
<li>px: Absolute units, expressed in pixels, can be understood as pixel values.</li>
<small>1px equals 1 pixel, if you don't need to be compatible with too many scenes, you can just use the px unit.</small>
<li>rem: Relative units, indicating the pixel value relative to the base font size</li>
<small>1rem is equal to the [base font size].<br/>
Can finely control the base font size for device by setting [Media Font Size] in the [Simulator].</small>
<li>vw: Percentage units, indicating the percentage relative to the viewport width.</li>
<small>1vw is equal to one hundredth of the viewport width. Setting this value separately for desktop and mobile makes it easy to be compatible with most scenarios.</small>
<li>%: Percentage unit, indicating the percentage relative to the parent element</li>
<small>1% is equal to one percent of the parent element. Generally used to set the height and width of the container.</small>
    `,
        question3: "\u{1F4A1} How do I add a new font?",
        answer3: `
You can add fonts through [Font Settings]. Currently, you can only add fonts by introducing font resource paths.<br/>
The easiest way is to select a font in Google Fonts and copy the font resource path to [Font Settings].
and add it to [Font] in [Font Settings] or in a separate setting in the Text component.
`,
        question4: "\u{1F4EE} Feedback",
        answer4: `Welcome to send email \u2192 <a target="_blank" href="mailto:nightcat@hzfe.org">nightcat@hzfe.org</a>`
      }
    };
    const lang = location.search.indexOf("lang=en") > -1 ? "en" : location.search.indexOf("lang=zh") > -1 ? "zh" : ["en", "zh"].includes(localStorage.getItem("lang") || "") ? localStorage.getItem("lang") : navigator.language.toLowerCase().startsWith("zh") ? "zh" : "en";
    setLang(lang);
    const $t = (key, ...args) => {
      const str = i18nText[lang][key];
      if (args.length) {
        return str.replace(/\{(\d+)\}/g, (_, index2) => args[index2]);
      }
      return str;
    };
    const getMaterialName = (item) => lang === "en" && item.enName || item.name;
    const getMaterialCategory = (item) => lang === "en" && item.categoryEn || item.category;
    const pinia = createPinia();
    const saveStoragePageState = (id) => {
      try {
        const pageStore = pinia.state.value["page"];
        sessionStorage.setItem("__page_store_state_id__", id);
        sessionStorage.setItem("__page_store_state__", JSON.stringify({
          allPageData: pageStore.allPageData,
          project: pageStore.project,
          colorVars: pageStore.colorVars,
          font: pageStore.font,
          setting: pageStore.setting
        }));
      } catch (e) {
        console.error("Cache Error", e);
      }
    };
    const getStoragePageState = (id, state) => {
      var _a;
      let initState = null;
      const route = useRoute();
      const paramId = ((_a = route == null ? void 0 : route.params) == null ? void 0 : _a.id) || id;
      try {
        const stateId = sessionStorage.getItem("__page_store_state_id__") || "";
        if (stateId === paramId && sessionStorage.getItem("__page_store_state__")) {
          initState = JSON.parse(sessionStorage.getItem("__page_store_state__"));
        }
        if (initState)
          return Object.assign(state, initState);
      } catch (e) {
        console.error("Cache Error", e);
      }
      return state;
    };
    const haveStoragePageState = (id) => {
      return !!sessionStorage.getItem("__page_store_state_id__");
    };
    const clearStoragePageState = () => {
      sessionStorage.removeItem("__page_store_state_id__");
      sessionStorage.removeItem("__page_store_state__");
    };
    var __defProp2 = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    var isFunction$3 = (value) => typeof value === "function";
    var isString$2 = (value) => typeof value === "string";
    var isNonEmptyString = (value) => isString$2(value) && value.trim().length > 0;
    var isNumber$2 = (value) => typeof value === "number";
    var isUndefined$1 = (value) => typeof value === "undefined";
    var isObject$3 = (value) => typeof value === "object" && value !== null;
    var isJSX = (obj) => hasProp(obj, "tag") && isNonEmptyString(obj.tag);
    var isTouchEvent = (event) => window.TouchEvent && event instanceof TouchEvent;
    var isToastComponent = (obj) => hasProp(obj, "component") && isToastContent(obj.component);
    var isVueComponent = (c) => isFunction$3(c) || isObject$3(c);
    var isToastContent = (obj) => !isUndefined$1(obj) && (isString$2(obj) || isVueComponent(obj) || isToastComponent(obj));
    var isDOMRect = (obj) => isObject$3(obj) && ["height", "width", "right", "left", "top", "bottom"].every((p2) => isNumber$2(obj[p2]));
    var hasProp = (obj, propKey) => (isObject$3(obj) || isFunction$3(obj)) && propKey in obj;
    var getId$1 = ((i2) => () => i2++)(0);
    function getX(event) {
      return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
    }
    function getY(event) {
      return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
    }
    var removeElement = (el) => {
      if (!isUndefined$1(el.remove)) {
        el.remove();
      } else if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    };
    var getVueComponentFromObj = (obj) => {
      if (isToastComponent(obj)) {
        return getVueComponentFromObj(obj.component);
      }
      if (isJSX(obj)) {
        return defineComponent({
          render() {
            return obj;
          }
        });
      }
      return typeof obj === "string" ? obj : toRaw(unref$1(obj));
    };
    var normalizeToastComponent = (obj) => {
      if (typeof obj === "string") {
        return obj;
      }
      const props = hasProp(obj, "props") && isObject$3(obj.props) ? obj.props : {};
      const listeners = hasProp(obj, "listeners") && isObject$3(obj.listeners) ? obj.listeners : {};
      return { component: getVueComponentFromObj(obj), props, listeners };
    };
    var isBrowser$1 = () => typeof window !== "undefined";
    var EventBus = class {
      constructor() {
        this.allHandlers = {};
      }
      getHandlers(eventType) {
        return this.allHandlers[eventType] || [];
      }
      on(eventType, handler) {
        const handlers = this.getHandlers(eventType);
        handlers.push(handler);
        this.allHandlers[eventType] = handlers;
      }
      off(eventType, handler) {
        const handlers = this.getHandlers(eventType);
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
      emit(eventType, event) {
        const handlers = this.getHandlers(eventType);
        handlers.forEach((handler) => handler(event));
      }
    };
    var isEventBusInterface = (e) => ["on", "off", "emit"].every((f) => hasProp(e, f) && isFunction$3(e[f]));
    var TYPE;
    (function(TYPE2) {
      TYPE2["SUCCESS"] = "success";
      TYPE2["ERROR"] = "error";
      TYPE2["WARNING"] = "warning";
      TYPE2["INFO"] = "info";
      TYPE2["DEFAULT"] = "default";
    })(TYPE || (TYPE = {}));
    var POSITION;
    (function(POSITION2) {
      POSITION2["TOP_LEFT"] = "top-left";
      POSITION2["TOP_CENTER"] = "top-center";
      POSITION2["TOP_RIGHT"] = "top-right";
      POSITION2["BOTTOM_LEFT"] = "bottom-left";
      POSITION2["BOTTOM_CENTER"] = "bottom-center";
      POSITION2["BOTTOM_RIGHT"] = "bottom-right";
    })(POSITION || (POSITION = {}));
    var EVENTS;
    (function(EVENTS2) {
      EVENTS2["ADD"] = "add";
      EVENTS2["DISMISS"] = "dismiss";
      EVENTS2["UPDATE"] = "update";
      EVENTS2["CLEAR"] = "clear";
      EVENTS2["UPDATE_DEFAULTS"] = "update_defaults";
    })(EVENTS || (EVENTS = {}));
    var VT_NAMESPACE = "Vue-Toastification";
    var COMMON = {
      type: {
        type: String,
        default: TYPE.DEFAULT
      },
      classNames: {
        type: [String, Array],
        default: () => []
      },
      trueBoolean: {
        type: Boolean,
        default: true
      }
    };
    var ICON = {
      type: COMMON.type,
      customIcon: {
        type: [String, Boolean, Object, Function],
        default: true
      }
    };
    var CLOSE_BUTTON = {
      component: {
        type: [String, Object, Function, Boolean],
        default: "button"
      },
      classNames: COMMON.classNames,
      showOnHover: {
        type: Boolean,
        default: false
      },
      ariaLabel: {
        type: String,
        default: "close"
      }
    };
    var PROGRESS_BAR = {
      timeout: {
        type: [Number, Boolean],
        default: 5e3
      },
      hideProgressBar: {
        type: Boolean,
        default: false
      },
      isRunning: {
        type: Boolean,
        default: false
      }
    };
    var TRANSITION = {
      transition: {
        type: [Object, String],
        default: `${VT_NAMESPACE}__bounce`
      }
    };
    var CORE_TOAST = {
      position: {
        type: String,
        default: POSITION.TOP_RIGHT
      },
      draggable: COMMON.trueBoolean,
      draggablePercent: {
        type: Number,
        default: 0.6
      },
      pauseOnFocusLoss: COMMON.trueBoolean,
      pauseOnHover: COMMON.trueBoolean,
      closeOnClick: COMMON.trueBoolean,
      timeout: PROGRESS_BAR.timeout,
      hideProgressBar: PROGRESS_BAR.hideProgressBar,
      toastClassName: COMMON.classNames,
      bodyClassName: COMMON.classNames,
      icon: ICON.customIcon,
      closeButton: CLOSE_BUTTON.component,
      closeButtonClassName: CLOSE_BUTTON.classNames,
      showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
      accessibility: {
        type: Object,
        default: () => ({
          toastRole: "alert",
          closeButtonLabel: "close"
        })
      },
      rtl: {
        type: Boolean,
        default: false
      },
      eventBus: {
        type: Object,
        required: false,
        default: () => new EventBus()
      }
    };
    var TOAST = {
      id: {
        type: [String, Number],
        required: true,
        default: 0
      },
      type: COMMON.type,
      content: {
        type: [String, Object, Function],
        required: true,
        default: ""
      },
      onClick: {
        type: Function,
        default: void 0
      },
      onClose: {
        type: Function,
        default: void 0
      }
    };
    var CONTAINER = {
      container: {
        type: [
          Object,
          Function
        ],
        default: () => document.body
      },
      newestOnTop: COMMON.trueBoolean,
      maxToasts: {
        type: Number,
        default: 20
      },
      transition: TRANSITION.transition,
      toastDefaults: Object,
      filterBeforeCreate: {
        type: Function,
        default: (toast2) => toast2
      },
      filterToasts: {
        type: Function,
        default: (toasts) => toasts
      },
      containerClassName: COMMON.classNames,
      onMounted: Function,
      shareAppContext: [Boolean, Object]
    };
    var propValidators_default = {
      CORE_TOAST,
      TOAST,
      CONTAINER,
      PROGRESS_BAR,
      ICON,
      TRANSITION,
      CLOSE_BUTTON
    };
    var VtProgressBar_default = defineComponent({
      name: "VtProgressBar",
      props: propValidators_default.PROGRESS_BAR,
      data() {
        return {
          hasClass: true
        };
      },
      computed: {
        style() {
          return {
            animationDuration: `${this.timeout}ms`,
            animationPlayState: this.isRunning ? "running" : "paused",
            opacity: this.hideProgressBar ? 0 : 1
          };
        },
        cpClass() {
          return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
        }
      },
      watch: {
        timeout() {
          this.hasClass = false;
          this.$nextTick(() => this.hasClass = true);
        }
      },
      mounted() {
        this.$el.addEventListener("animationend", this.animationEnded);
      },
      beforeUnmount() {
        this.$el.removeEventListener("animationend", this.animationEnded);
      },
      methods: {
        animationEnded() {
          this.$emit("close-toast");
        }
      }
    });
    function render$1k(_ctx, _cache) {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(_ctx.style),
        class: normalizeClass(_ctx.cpClass)
      }, null, 6);
    }
    VtProgressBar_default.render = render$1k;
    var VtProgressBar_default2 = VtProgressBar_default;
    var VtCloseButton_default = defineComponent({
      name: "VtCloseButton",
      props: propValidators_default.CLOSE_BUTTON,
      computed: {
        buttonComponent() {
          if (this.component !== false) {
            return getVueComponentFromObj(this.component);
          }
          return "button";
        },
        classes() {
          const classes = [`${VT_NAMESPACE}__close-button`];
          if (this.showOnHover) {
            classes.push("show-on-hover");
          }
          return classes.concat(this.classNames);
        }
      }
    });
    var _hoisted_1$2c = /* @__PURE__ */ createTextVNode(" \xD7 ");
    function render2(_ctx, _cache) {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
        "aria-label": _ctx.ariaLabel,
        class: _ctx.classes
      }, _ctx.$attrs), {
        default: withCtx(() => [
          _hoisted_1$2c
        ]),
        _: 1
      }, 16, ["aria-label", "class"]);
    }
    VtCloseButton_default.render = render2;
    var VtCloseButton_default2 = VtCloseButton_default;
    var VtSuccessIcon_default = {};
    var _hoisted_12$4 = {
      "aria-hidden": "true",
      focusable: "false",
      "data-prefix": "fas",
      "data-icon": "check-circle",
      class: "svg-inline--fa fa-check-circle fa-w-16",
      role: "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    };
    var _hoisted_2$1U = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
    }, null, -1);
    var _hoisted_3$1K = [
      _hoisted_2$1U
    ];
    function render3(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_12$4, _hoisted_3$1K);
    }
    VtSuccessIcon_default.render = render3;
    var VtSuccessIcon_default2 = VtSuccessIcon_default;
    var VtInfoIcon_default = {};
    var _hoisted_13$4 = {
      "aria-hidden": "true",
      focusable: "false",
      "data-prefix": "fas",
      "data-icon": "info-circle",
      class: "svg-inline--fa fa-info-circle fa-w-16",
      role: "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    };
    var _hoisted_22$2 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
    }, null, -1);
    var _hoisted_32 = [
      _hoisted_22$2
    ];
    function render4(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_13$4, _hoisted_32);
    }
    VtInfoIcon_default.render = render4;
    var VtInfoIcon_default2 = VtInfoIcon_default;
    var VtWarningIcon_default = {};
    var _hoisted_14$4 = {
      "aria-hidden": "true",
      focusable: "false",
      "data-prefix": "fas",
      "data-icon": "exclamation-circle",
      class: "svg-inline--fa fa-exclamation-circle fa-w-16",
      role: "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    };
    var _hoisted_23$2 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
    }, null, -1);
    var _hoisted_33 = [
      _hoisted_23$2
    ];
    function render5(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_14$4, _hoisted_33);
    }
    VtWarningIcon_default.render = render5;
    var VtWarningIcon_default2 = VtWarningIcon_default;
    var VtErrorIcon_default = {};
    var _hoisted_15$3 = {
      "aria-hidden": "true",
      focusable: "false",
      "data-prefix": "fas",
      "data-icon": "exclamation-triangle",
      class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
      role: "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 576 512"
    };
    var _hoisted_24$1 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
    }, null, -1);
    var _hoisted_34 = [
      _hoisted_24$1
    ];
    function render6(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_15$3, _hoisted_34);
    }
    VtErrorIcon_default.render = render6;
    var VtErrorIcon_default2 = VtErrorIcon_default;
    var VtIcon_default = defineComponent({
      name: "VtIcon",
      props: propValidators_default.ICON,
      computed: {
        customIconChildren() {
          return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
        },
        customIconClass() {
          if (isString$2(this.customIcon)) {
            return this.trimValue(this.customIcon);
          } else if (hasProp(this.customIcon, "iconClass")) {
            return this.trimValue(this.customIcon.iconClass);
          }
          return "";
        },
        customIconTag() {
          if (hasProp(this.customIcon, "iconTag")) {
            return this.trimValue(this.customIcon.iconTag, "i");
          }
          return "i";
        },
        hasCustomIcon() {
          return this.customIconClass.length > 0;
        },
        component() {
          if (this.hasCustomIcon) {
            return this.customIconTag;
          }
          if (isToastContent(this.customIcon)) {
            return getVueComponentFromObj(this.customIcon);
          }
          return this.iconTypeComponent;
        },
        iconTypeComponent() {
          const types2 = {
            [TYPE.DEFAULT]: VtInfoIcon_default2,
            [TYPE.INFO]: VtInfoIcon_default2,
            [TYPE.SUCCESS]: VtSuccessIcon_default2,
            [TYPE.ERROR]: VtErrorIcon_default2,
            [TYPE.WARNING]: VtWarningIcon_default2
          };
          return types2[this.type];
        },
        iconClasses() {
          const classes = [`${VT_NAMESPACE}__icon`];
          if (this.hasCustomIcon) {
            return classes.concat(this.customIconClass);
          }
          return classes;
        }
      },
      methods: {
        trimValue(value, empty = "") {
          return isNonEmptyString(value) ? value.trim() : empty;
        }
      }
    });
    function render7(_ctx, _cache) {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
        class: normalizeClass(_ctx.iconClasses)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.customIconChildren), 1)
        ]),
        _: 1
      }, 8, ["class"]);
    }
    VtIcon_default.render = render7;
    var VtIcon_default2 = VtIcon_default;
    var VtToast_default = defineComponent({
      name: "VtToast",
      components: { ProgressBar: VtProgressBar_default2, CloseButton: VtCloseButton_default2, Icon: VtIcon_default2 },
      inheritAttrs: false,
      props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.TOAST),
      data() {
        const data2 = {
          isRunning: true,
          disableTransitions: false,
          beingDragged: false,
          dragStart: 0,
          dragPos: { x: 0, y: 0 },
          dragRect: {}
        };
        return data2;
      },
      computed: {
        classes() {
          const classes = [
            `${VT_NAMESPACE}__toast`,
            `${VT_NAMESPACE}__toast--${this.type}`,
            `${this.position}`
          ].concat(this.toastClassName);
          if (this.disableTransitions) {
            classes.push("disable-transition");
          }
          if (this.rtl) {
            classes.push(`${VT_NAMESPACE}__toast--rtl`);
          }
          return classes;
        },
        bodyClasses() {
          const classes = [
            `${VT_NAMESPACE}__toast-${isString$2(this.content) ? "body" : "component-body"}`
          ].concat(this.bodyClassName);
          return classes;
        },
        draggableStyle() {
          if (this.dragStart === this.dragPos.x) {
            return {};
          } else if (this.beingDragged) {
            return {
              transform: `translateX(${this.dragDelta}px)`,
              opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
            };
          } else {
            return {
              transition: "transform 0.2s, opacity 0.2s",
              transform: "translateX(0)",
              opacity: 1
            };
          }
        },
        dragDelta() {
          return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
        },
        removalDistance() {
          if (isDOMRect(this.dragRect)) {
            return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
          }
          return 0;
        }
      },
      mounted() {
        if (this.draggable) {
          this.draggableSetup();
        }
        if (this.pauseOnFocusLoss) {
          this.focusSetup();
        }
      },
      beforeUnmount() {
        if (this.draggable) {
          this.draggableCleanup();
        }
        if (this.pauseOnFocusLoss) {
          this.focusCleanup();
        }
      },
      methods: {
        hasProp,
        getVueComponentFromObj,
        closeToast() {
          this.eventBus.emit(EVENTS.DISMISS, this.id);
        },
        clickHandler() {
          if (this.onClick) {
            this.onClick(this.closeToast);
          }
          if (this.closeOnClick) {
            if (!this.beingDragged || this.dragStart === this.dragPos.x) {
              this.closeToast();
            }
          }
        },
        timeoutHandler() {
          this.closeToast();
        },
        hoverPause() {
          if (this.pauseOnHover) {
            this.isRunning = false;
          }
        },
        hoverPlay() {
          if (this.pauseOnHover) {
            this.isRunning = true;
          }
        },
        focusPause() {
          this.isRunning = false;
        },
        focusPlay() {
          this.isRunning = true;
        },
        focusSetup() {
          addEventListener("blur", this.focusPause);
          addEventListener("focus", this.focusPlay);
        },
        focusCleanup() {
          removeEventListener("blur", this.focusPause);
          removeEventListener("focus", this.focusPlay);
        },
        draggableSetup() {
          const element = this.$el;
          element.addEventListener("touchstart", this.onDragStart, {
            passive: true
          });
          element.addEventListener("mousedown", this.onDragStart);
          addEventListener("touchmove", this.onDragMove, { passive: false });
          addEventListener("mousemove", this.onDragMove);
          addEventListener("touchend", this.onDragEnd);
          addEventListener("mouseup", this.onDragEnd);
        },
        draggableCleanup() {
          const element = this.$el;
          element.removeEventListener("touchstart", this.onDragStart);
          element.removeEventListener("mousedown", this.onDragStart);
          removeEventListener("touchmove", this.onDragMove);
          removeEventListener("mousemove", this.onDragMove);
          removeEventListener("touchend", this.onDragEnd);
          removeEventListener("mouseup", this.onDragEnd);
        },
        onDragStart(event) {
          this.beingDragged = true;
          this.dragPos = { x: getX(event), y: getY(event) };
          this.dragStart = getX(event);
          this.dragRect = this.$el.getBoundingClientRect();
        },
        onDragMove(event) {
          if (this.beingDragged) {
            event.preventDefault();
            if (this.isRunning) {
              this.isRunning = false;
            }
            this.dragPos = { x: getX(event), y: getY(event) };
          }
        },
        onDragEnd() {
          if (this.beingDragged) {
            if (Math.abs(this.dragDelta) >= this.removalDistance) {
              this.disableTransitions = true;
              this.$nextTick(() => this.closeToast());
            } else {
              setTimeout(() => {
                this.beingDragged = false;
                if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
                  this.isRunning = false;
                } else {
                  this.isRunning = true;
                }
              });
            }
          }
        }
      }
    });
    var _hoisted_16$2 = ["role"];
    function render8(_ctx, _cache) {
      const _component_Icon = resolveComponent("Icon");
      const _component_CloseButton = resolveComponent("CloseButton");
      const _component_ProgressBar = resolveComponent("ProgressBar");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle(_ctx.draggableStyle),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args)),
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.hoverPause && _ctx.hoverPause(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.hoverPlay && _ctx.hoverPlay(...args))
      }, [
        _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
          key: 0,
          "custom-icon": _ctx.icon,
          type: _ctx.type
        }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          role: _ctx.accessibility.toastRole || "alert",
          class: normalizeClass(_ctx.bodyClasses)
        }, [
          typeof _ctx.content === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.content), 1)
          ], 2112)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
            key: 1,
            "toast-id": _ctx.id
          }, _ctx.hasProp(_ctx.content, "props") ? _ctx.content.props : {}, toHandlers(_ctx.hasProp(_ctx.content, "listeners") ? _ctx.content.listeners : {}), { onCloseToast: _ctx.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
        ], 10, _hoisted_16$2),
        !!_ctx.closeButton ? (openBlock(), createBlock(_component_CloseButton, {
          key: 1,
          component: _ctx.closeButton,
          "class-names": _ctx.closeButtonClassName,
          "show-on-hover": _ctx.showCloseButtonOnHover,
          "aria-label": _ctx.accessibility.closeButtonLabel,
          onClick: withModifiers(_ctx.closeToast, ["stop"])
        }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
        _ctx.timeout ? (openBlock(), createBlock(_component_ProgressBar, {
          key: 2,
          "is-running": _ctx.isRunning,
          "hide-progress-bar": _ctx.hideProgressBar,
          timeout: _ctx.timeout,
          onCloseToast: _ctx.timeoutHandler
        }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
      ], 38);
    }
    VtToast_default.render = render8;
    var VtToast_default2 = VtToast_default;
    var VtTransition_default = defineComponent({
      name: "VtTransition",
      props: propValidators_default.TRANSITION,
      emits: ["leave"],
      methods: {
        hasProp,
        leave(el) {
          if (el instanceof HTMLElement) {
            el.style.left = el.offsetLeft + "px";
            el.style.top = el.offsetTop + "px";
            el.style.width = getComputedStyle(el).width;
            el.style.position = "absolute";
          }
        }
      }
    });
    function render9(_ctx, _cache) {
      return openBlock(), createBlock(TransitionGroup, {
        tag: "div",
        "enter-active-class": _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`,
        "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
        "leave-active-class": _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`,
        onLeave: _ctx.leave
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
    }
    VtTransition_default.render = render9;
    var VtTransition_default2 = VtTransition_default;
    var VtToastContainer_default = defineComponent({
      name: "VueToastification",
      devtools: {
        hide: true
      },
      components: { Toast: VtToast_default2, VtTransition: VtTransition_default2 },
      props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.CONTAINER, propValidators_default.TRANSITION),
      data() {
        const data2 = {
          count: 0,
          positions: Object.values(POSITION),
          toasts: {},
          defaults: {}
        };
        return data2;
      },
      computed: {
        toastArray() {
          return Object.values(this.toasts);
        },
        filteredToasts() {
          return this.defaults.filterToasts(this.toastArray);
        }
      },
      beforeMount() {
        const events = this.eventBus;
        events.on(EVENTS.ADD, this.addToast);
        events.on(EVENTS.CLEAR, this.clearToasts);
        events.on(EVENTS.DISMISS, this.dismissToast);
        events.on(EVENTS.UPDATE, this.updateToast);
        events.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
        this.defaults = this.$props;
      },
      mounted() {
        this.setup(this.container);
      },
      methods: {
        async setup(container) {
          if (isFunction$3(container)) {
            container = await container();
          }
          removeElement(this.$el);
          container.appendChild(this.$el);
        },
        setToast(props) {
          if (!isUndefined$1(props.id)) {
            this.toasts[props.id] = props;
          }
        },
        addToast(params) {
          params.content = normalizeToastComponent(params.content);
          const props = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
          const toast2 = this.defaults.filterBeforeCreate(props, this.toastArray);
          toast2 && this.setToast(toast2);
        },
        dismissToast(id) {
          const toast2 = this.toasts[id];
          if (!isUndefined$1(toast2) && !isUndefined$1(toast2.onClose)) {
            toast2.onClose();
          }
          delete this.toasts[id];
        },
        clearToasts() {
          Object.keys(this.toasts).forEach((id) => {
            this.dismissToast(id);
          });
        },
        getPositionToasts(position) {
          const toasts = this.filteredToasts.filter((toast2) => toast2.position === position).slice(0, this.defaults.maxToasts);
          return this.defaults.newestOnTop ? toasts.reverse() : toasts;
        },
        updateDefaults(update) {
          if (!isUndefined$1(update.container)) {
            this.setup(update.container);
          }
          this.defaults = Object.assign({}, this.defaults, update);
        },
        updateToast({
          id,
          options,
          create: create2
        }) {
          if (this.toasts[id]) {
            if (options.timeout && options.timeout === this.toasts[id].timeout) {
              options.timeout++;
            }
            this.setToast(Object.assign({}, this.toasts[id], options));
          } else if (create2) {
            this.addToast(Object.assign({}, { id }, options));
          }
        },
        getClasses(position) {
          const classes = [`${VT_NAMESPACE}__container`, position];
          return classes.concat(this.defaults.containerClassName);
        }
      }
    });
    function render10(_ctx, _cache) {
      const _component_Toast = resolveComponent("Toast");
      const _component_VtTransition = resolveComponent("VtTransition");
      return openBlock(), createElementBlock("div", null, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.positions, (pos) => {
          return openBlock(), createElementBlock("div", { key: pos }, [
            createVNode(_component_VtTransition, {
              transition: _ctx.defaults.transition,
              class: normalizeClass(_ctx.getClasses(pos))
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getPositionToasts(pos), (toast2) => {
                  return openBlock(), createBlock(_component_Toast, mergeProps({
                    key: toast2.id
                  }, toast2), null, 16);
                }), 128))
              ]),
              _: 2
            }, 1032, ["transition", "class"])
          ]);
        }), 128))
      ]);
    }
    VtToastContainer_default.render = render10;
    var VtToastContainer_default2 = VtToastContainer_default;
    var buildInterface = (globalOptions = {}, mountContainer = true) => {
      const events = globalOptions.eventBus = globalOptions.eventBus || new EventBus();
      if (mountContainer) {
        nextTick$1(() => {
          const app2 = createApp(VtToastContainer_default2, __spreadValues({}, globalOptions));
          const component = app2.mount(document.createElement("div"));
          const onMounted2 = globalOptions.onMounted;
          if (!isUndefined$1(onMounted2)) {
            onMounted2(component, app2);
          }
          if (globalOptions.shareAppContext) {
            const baseApp = globalOptions.shareAppContext;
            if (baseApp === true) {
              console.warn(`[${VT_NAMESPACE}] App to share context with was not provided.`);
            } else {
              app2._context.components = baseApp._context.components;
              app2._context.directives = baseApp._context.directives;
              app2._context.mixins = baseApp._context.mixins;
              app2._context.provides = baseApp._context.provides;
              app2.config.globalProperties = baseApp.config.globalProperties;
            }
          }
        });
      }
      const toast2 = (content, options) => {
        const props = Object.assign({}, { id: getId$1(), type: TYPE.DEFAULT }, options, {
          content
        });
        events.emit(EVENTS.ADD, props);
        return props.id;
      };
      toast2.clear = () => events.emit(EVENTS.CLEAR, void 0);
      toast2.updateDefaults = (update) => {
        events.emit(EVENTS.UPDATE_DEFAULTS, update);
      };
      toast2.dismiss = (id) => {
        events.emit(EVENTS.DISMISS, id);
      };
      function updateToast(id, { content, options }, create2 = false) {
        const opt = Object.assign({}, options, { content });
        events.emit(EVENTS.UPDATE, {
          id,
          options: opt,
          create: create2
        });
      }
      toast2.update = updateToast;
      toast2.success = (content, options) => toast2(content, Object.assign({}, options, { type: TYPE.SUCCESS }));
      toast2.info = (content, options) => toast2(content, Object.assign({}, options, { type: TYPE.INFO }));
      toast2.error = (content, options) => toast2(content, Object.assign({}, options, { type: TYPE.ERROR }));
      toast2.warning = (content, options) => toast2(content, Object.assign({}, options, { type: TYPE.WARNING }));
      return toast2;
    };
    var createMockToastInterface = () => {
      const toast2 = () => console.warn(`[${VT_NAMESPACE}] This plugin does not support SSR!`);
      return new Proxy(toast2, {
        get() {
          return toast2;
        }
      });
    };
    function createToastInterface(optionsOrEventBus) {
      if (!isBrowser$1()) {
        return createMockToastInterface();
      }
      if (isEventBusInterface(optionsOrEventBus)) {
        return buildInterface({ eventBus: optionsOrEventBus }, false);
      }
      return buildInterface(optionsOrEventBus, true);
    }
    var toastInjectionKey = Symbol("VueToastification");
    var globalEventBus = new EventBus();
    var VueToastificationPlugin = (App2, options) => {
      if ((options == null ? void 0 : options.shareAppContext) === true) {
        options.shareAppContext = App2;
      }
      const inter = createToastInterface(__spreadValues({
        eventBus: globalEventBus
      }, options));
      App2.provide(toastInjectionKey, inter);
    };
    var useToast = (eventBus) => {
      if (eventBus) {
        return createToastInterface(eventBus);
      }
      const toast2 = getCurrentInstance() ? inject(toastInjectionKey, void 0) : void 0;
      return toast2 ? toast2 : createToastInterface(globalEventBus);
    };
    var src_default = VueToastificationPlugin;
    const toast = useToast();
    const Alert = (msg) => toast(msg, { type: TYPE.INFO });
    const AlertError = (msg) => toast(msg, { type: TYPE.ERROR });
    const _hoisted_1$2b = {
      width: "865",
      height: "866",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_2$1T = /* @__PURE__ */ createStaticVNode('<g filter="url(#a)"><rect x="30" y="40" width="785" height="785" rx="146" fill="url(#b)"></rect><path d="M215 825.545V363c0-106.039 85.961-192 192-192h29.165c51.349 0 88.474 6.509 121.074 25.045 32.812 18.324 56.233 39.679 72 71 15.767 31.321 23.5 72.492 23.5 111.057 0 38.566-6.733 74.909-22.5 106.443-15.554 31.535-34.912 55.383-67.512 74.133-32.599 18.537-74.361 27.805-125.284 27.805H278.92V516.17h155.966c35.157 0 63.388-6.072 84.695-18.217 21.307-12.145 36.754-28.551 46.342-49.219 9.801-20.88 14.702-44.424 14.702-70.632 0-26.207-6.923-47.309-16.724-67.977-9.589-20.668-25.142-36.861-46.662-48.58-21.52-11.931-48.049-20.233-83.631-20.233-76.959 0-139.347 62.388-139.347 139.347v444.886H215Z" fill="#fff"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M294.3 586.483h142.705c50.923 0 92.684-9.269 125.284-27.805 32.599-18.75 51.957-42.598 67.511-74.133 11.688-23.375 18.411-49.393 21.108-77h-72.957c-2.332 14.721-6.487 28.451-12.466 41.189-9.588 20.668-25.036 37.074-46.343 49.219-21.306 12.145-49.538 18.217-84.694 18.217H294.3v70.313Z" fill="url(#c)"></path></g><defs><linearGradient id="b" x1="422.5" y1="40" x2="422.5" y2="825" gradientUnits="userSpaceOnUse"><stop stop-color="#2C40F5"></stop><stop offset="1" stop-color="#41F4FF"></stop></linearGradient><linearGradient id="c" x1="294.3" y1="554.045" x2="712.8" y2="554.045" gradientUnits="userSpaceOnUse"><stop stop-color="#82D9F4"></stop><stop offset=".104" stop-color="#D0F4FF" stop-opacity=".901"></stop><stop offset="1" stop-color="#fff" stop-opacity="0"></stop></linearGradient><filter id="a" x="0" y="0" width="865" height="865.545" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dx="10"></feOffset><feGaussianBlur stdDeviation="20"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"></feColorMatrix><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_37_13"></feBlend><feBlend in="SourceGraphic" in2="effect1_dropShadow_37_13" result="shape"></feBlend></filter></defs>', 2);
    const _hoisted_4$x = [
      _hoisted_2$1T
    ];
    function render$1j(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$2b, _hoisted_4$x);
    }
    const LogoIcon = { render: render$1j };
    const _hoisted_1$2a = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1S = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512.007 1020.59c-280.887 0-508.594-227.738-508.594-508.587S231.12 3.41 512.007 3.41s508.58 227.707 508.58 508.593c0 280.894-227.731 508.587-508.58 508.587zm278.279-537.378a19.139 19.139 0 0 0-19.135-19.135H559.988V252.914a19.135 19.135 0 0 0-19.135-19.135h-57.627a19.135 19.135 0 0 0-19.139 19.135v211.118h-211.17a19.135 19.135 0 0 0-19.134 19.139v57.58a19.135 19.135 0 0 0 19.135 19.135h211.121v211.2a19.135 19.135 0 0 0 19.135 19.138h57.58a19.139 19.139 0 0 0 19.138-19.138V559.985h211.2a19.135 19.135 0 0 0 19.132-19.139l.062-57.634z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1J = [
      _hoisted_2$1S
    ];
    function render$1i(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$2a, _hoisted_3$1J);
    }
    const AddIcon = { render: render$1i };
    const _hoisted_1$29 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1R = /* @__PURE__ */ createBaseVNode("path", {
      d: "m554.667 42.667.042 130.645a341.504 341.504 0 0 1 295.979 296.021h130.645v85.334l-130.645.042a341.504 341.504 0 0 1-295.979 295.979l-.042 130.645h-85.334V850.688a341.504 341.504 0 0 1-296.021-295.979l-130.645-.042v-85.334h130.645a341.504 341.504 0 0 1 296.021-296.021V42.667h85.334zM512 256a256 256 0 1 0 0 512 256 256 0 0 0 0-512zm0 170.667a85.333 85.333 0 1 1 0 170.666 85.333 85.333 0 0 1 0-170.666z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1I = [
      _hoisted_2$1R
    ];
    function render$1h(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$29, _hoisted_3$1I);
    }
    const FocusIcon = { render: render$1h };
    const _hoisted_1$28 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1Q = /* @__PURE__ */ createBaseVNode("path", {
      d: "M853.333 682.667H896V768H128v-85.333h42.667V256h682.666v426.667zM256 341.333V640h512V341.333H256z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1H = [
      _hoisted_2$1Q
    ];
    function render$1g(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$28, _hoisted_3$1H);
    }
    const DeviceSmIcon = { render: render$1g };
    const _hoisted_1$27 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1P = /* @__PURE__ */ createBaseVNode("path", {
      d: "M554.667 682.667v42.666H640v85.334H384v-85.334h85.333v-42.666H170.667V213.333h682.666v469.334H554.667zm0-85.334H768V298.667H256v298.666h298.667z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1G = [
      _hoisted_2$1P
    ];
    function render$1f(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$27, _hoisted_3$1G);
    }
    const DeviceMdIcon = { render: render$1f };
    const _hoisted_1$26 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1O = /* @__PURE__ */ createBaseVNode("path", {
      d: "M691.2 778.667H322.133c-1.173 0-2.133 2.4-2.133 5.333v64c0 2.933.96 5.333 2.133 5.333H691.2c1.173 0 2.133-2.4 2.133-5.333v-64c0-2.933-.96-5.333-2.133-5.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1F = /* @__PURE__ */ createBaseVNode("path", {
      d: "M543.573 711.093H469.76a17.92 17.92 0 0 0-.427 5.334v64a17.92 17.92 0 0 0 .427 5.333h73.813a17.92 17.92 0 0 0 .427-5.333v-64a17.92 17.92 0 0 0-.427-5.334z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$w = /* @__PURE__ */ createBaseVNode("path", {
      d: "M96 736h821.333a5.333 5.333 0 0 0 5.334-5.333V176a5.333 5.333 0 0 0-5.334-5.333H96A5.333 5.333 0 0 0 90.667 176v554.667A5.333 5.333 0 0 0 96 736zm69.333-485.333a5.333 5.333 0 0 1 5.334-5.334h672a5.333 5.333 0 0 1 5.333 5.334V656a5.333 5.333 0 0 1-5.333 5.333h-672a5.333 5.333 0 0 1-5.334-5.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_5$i = /* @__PURE__ */ createBaseVNode("path", {
      d: "M480 624.107a26.667 26.667 0 1 0 53.333 0 26.667 26.667 0 1 0-53.333 0Z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_6$c = [
      _hoisted_2$1O,
      _hoisted_3$1F,
      _hoisted_4$w,
      _hoisted_5$i
    ];
    function render$1e(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$26, _hoisted_6$c);
    }
    const DeviceLgIcon = { render: render$1e };
    const _hoisted_1$25 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1N = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 1024A512 512 0 1 1 512 0a512 512 0 0 1 0 1024zm-64-418.88L277.312 442.176 192 523.648 448 768l384-366.528L746.688 320 448 605.12z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1E = [
      _hoisted_2$1N
    ];
    function render$1d(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$25, _hoisted_3$1E);
    }
    const CheckIcon = { render: render$1d };
    const _hoisted_1$24 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1M = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 610.88 930.88 192l93.12 93.12-512 512-512-512L93.12 192z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1D = [
      _hoisted_2$1M
    ];
    function render$1c(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$24, _hoisted_3$1D);
    }
    const DownIcon = { render: render$1c };
    const _hoisted_1$23 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1L = /* @__PURE__ */ createBaseVNode("path", {
      d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1C = [
      _hoisted_2$1L
    ];
    function render$1b(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$23, _hoisted_3$1C);
    }
    const CaretDownIcon = { render: render$1b };
    const _hoisted_1$22 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1K = /* @__PURE__ */ createBaseVNode("path", {
      d: "m909.653 407.467-80.64-26.88 37.974-75.947A42.667 42.667 0 0 0 858.88 256L768 165.12a42.667 42.667 0 0 0-49.067-8.107l-75.946 37.974-26.88-80.64A42.667 42.667 0 0 0 576 85.333H448a42.667 42.667 0 0 0-40.533 29.014l-26.88 80.64-75.947-37.974A42.667 42.667 0 0 0 256 165.12L165.12 256a42.667 42.667 0 0 0-8.107 49.067l37.974 75.946-80.64 26.88A42.667 42.667 0 0 0 85.333 448v128a42.667 42.667 0 0 0 29.014 40.533l80.64 26.88-37.974 75.947A42.667 42.667 0 0 0 165.12 768L256 858.88a42.667 42.667 0 0 0 49.067 8.107l75.946-37.974 26.88 80.64a42.667 42.667 0 0 0 40.534 29.014h128a42.667 42.667 0 0 0 40.533-29.014l26.88-80.64 75.947 37.974A42.667 42.667 0 0 0 768 858.88L858.88 768a42.667 42.667 0 0 0 8.107-49.067l-37.974-75.946 80.64-26.88A42.667 42.667 0 0 0 938.667 576V448a42.667 42.667 0 0 0-29.014-40.533zm-56.32 137.813-51.2 17.067a85.333 85.333 0 0 0-49.493 120.32l24.32 48.64-46.933 46.933-47.36-25.6a85.333 85.333 0 0 0-119.04 49.493l-17.067 51.2h-67.84l-17.067-51.2a85.333 85.333 0 0 0-120.32-49.493l-48.64 24.32-46.933-46.933 25.6-47.36a85.333 85.333 0 0 0-49.493-120.32l-51.2-17.067v-66.56l51.2-17.067a85.333 85.333 0 0 0 49.493-120.32l-24.32-47.36 46.933-46.933 47.36 24.32a85.333 85.333 0 0 0 120.32-49.493l17.067-51.2h66.56l17.067 51.2a85.333 85.333 0 0 0 120.32 49.493l48.64-24.32 46.933 46.933-25.6 47.36a85.333 85.333 0 0 0 49.493 119.04l51.2 17.067zM512 341.333A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333zm0 256A85.333 85.333 0 1 1 597.333 512 85.333 85.333 0 0 1 512 597.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1B = [
      _hoisted_2$1K
    ];
    function render$1a(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$22, _hoisted_3$1B);
    }
    const AdvancedIcon = { render: render$1a };
    const _hoisted_1$21 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1J = /* @__PURE__ */ createBaseVNode("path", {
      d: "M467.2 624c12.8 12.8 30.4 20.8 46.4 20.8 17.6 0 33.6-8 46.4-20.8l449.6-424c17.6-17.6 17.6-43.2 0-59.2s-43.2-17.6-59.2 0l-432 416L73.6 139.2c-17.6-17.6-43.2-17.6-59.2 0s-17.6 43.2 0 59.2L467.2 624z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1A = /* @__PURE__ */ createBaseVNode("path", {
      d: "M955.2 392 513.6 808 72 392c-17.6-17.6-43.2-17.6-59.2 0s-17.6 43.2 0 59.2l454.4 424C480 888 497.6 896 513.6 896c17.6 0 33.6-8 46.4-20.8l449.6-424c17.6-17.6 17.6-43.2 0-59.2-11.2-17.6-36.8-17.6-54.4 0z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$v = [
      _hoisted_2$1J,
      _hoisted_3$1A
    ];
    function render$19(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$21, _hoisted_4$v);
    }
    const MoreIcon = { render: render$19 };
    const _hoisted_1$20 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1I = /* @__PURE__ */ createBaseVNode("path", {
      d: "M896 196.923H649.846v-78.77c0-43.322-35.446-78.768-78.77-78.768H452.924c-43.323 0-78.77 35.446-78.77 78.769v78.77H128c-15.754 0-29.538 13.784-29.538 29.538v59.076c0 15.754 13.784 29.539 29.538 29.539h768c15.754 0 29.538-13.785 29.538-29.539v-59.076c0-15.754-13.784-29.539-29.538-29.539zm-443.077-59.077c0-11.815 7.877-19.692 19.692-19.692h78.77c11.815 0 19.692 7.877 19.692 19.692v59.077H452.923v-59.077zm364.308 256H206.769c-15.754 0-29.538 13.785-29.538 29.539v462.769c0 55.138 43.323 98.461 98.461 98.461h472.616c55.138 0 98.461-43.323 98.461-98.461v-462.77c0-15.753-13.784-29.538-29.538-29.538zm-364.308 433.23c0 11.816-7.877 19.693-19.692 19.693h-39.385c-11.815 0-19.692-7.877-19.692-19.692V551.385c0-11.816 7.877-19.693 19.692-19.693h39.385c11.815 0 19.692 7.877 19.692 19.693v275.692zm196.923 0c0 11.816-7.877 19.693-19.692 19.693h-39.385c-11.815 0-19.692-7.877-19.692-19.692V551.385c0-11.816 7.877-19.693 19.692-19.693h39.385c11.815 0 19.692 7.877 19.692 19.693v275.692z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1z = [
      _hoisted_2$1I
    ];
    function render$18(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$20, _hoisted_3$1z);
    }
    const DeleteIcon = { render: render$18 };
    const _hoisted_1$1$ = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1H = /* @__PURE__ */ createBaseVNode("path", {
      d: "M980.8 555.2H43.2C17.6 555.2 0 537.6 0 512s17.6-43.2 43.2-43.2h939.2c25.6 0 43.2 17.6 43.2 43.2-1.6 25.6-19.2 43.2-44.8 43.2z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1y = [
      _hoisted_2$1H
    ];
    function render$17(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1$, _hoisted_3$1y);
    }
    const LineIcon = { render: render$17 };
    const _hoisted_1$1_ = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1G = /* @__PURE__ */ createBaseVNode("path", {
      d: "M212.8 468.8H43.2C17.6 468.8 0 486.4 0 512s17.6 43.2 43.2 43.2h171.2c25.6 0 43.2-17.6 43.2-43.2-1.6-25.6-19.2-43.2-44.8-43.2zm768 0H811.2c-25.6 0-43.2 17.6-43.2 43.2s17.6 43.2 43.2 43.2h171.2c25.6 0 43.2-17.6 43.2-43.2-1.6-25.6-19.2-43.2-44.8-43.2zm-384 0H427.2c-25.6 0-43.2 17.6-43.2 43.2s17.6 43.2 43.2 43.2h171.2c25.6 0 43.2-17.6 43.2-43.2-1.6-25.6-19.2-43.2-44.8-43.2z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1x = [
      _hoisted_2$1G
    ];
    function render$16(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1_, _hoisted_3$1x);
    }
    const DashedIcon = { render: render$16 };
    const _hoisted_1$1Z = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1F = /* @__PURE__ */ createBaseVNode("path", {
      d: "M84.8 468.8H43.2C17.6 468.8 0 486.4 0 512s17.6 43.2 43.2 43.2h43.2c24 0 41.6-17.6 41.6-43.2s-17.6-43.2-43.2-43.2zm299.2 0h-43.2c-25.6 0-43.2 17.6-43.2 43.2s17.6 43.2 43.2 43.2H384c25.6 0 43.2-17.6 43.2-43.2s-17.6-43.2-43.2-43.2zm299.2 0H640c-25.6 0-43.2 17.6-43.2 43.2s17.6 43.2 43.2 43.2h43.2c25.6 0 43.2-17.6 43.2-43.2-1.6-25.6-17.6-43.2-43.2-43.2zm297.6 0h-43.2c-25.6 0-43.2 17.6-43.2 43.2s17.6 43.2 43.2 43.2h43.2c25.6 0 43.2-17.6 43.2-43.2s-17.6-43.2-43.2-43.2z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1w = [
      _hoisted_2$1F
    ];
    function render$15(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1Z, _hoisted_3$1w);
    }
    const DottedIcon = { render: render$15 };
    const _hoisted_1$1Y = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1E = /* @__PURE__ */ createBaseVNode("path", {
      d: "M43.2 384h939.2c25.6 0 43.2-17.6 43.2-43.2s-17.6-43.2-43.2-43.2H43.2C17.6 297.6 0 315.2 0 340.8S17.6 384 43.2 384zm937.6 256H43.2C17.6 640 0 657.6 0 683.2s17.6 43.2 43.2 43.2h939.2c25.6 0 43.2-17.6 43.2-43.2-1.6-25.6-19.2-43.2-44.8-43.2z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1v = [
      _hoisted_2$1E
    ];
    function render$14(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1Y, _hoisted_3$1v);
    }
    const LineDoubleIcon = { render: render$14 };
    const _hoisted_1$1X = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1D = /* @__PURE__ */ createBaseVNode("path", {
      d: "M874.667 405.333h-320v213.334h320V405.333zm0-85.333V149.333h-320V320h320zm0 384h-320v170.667h320V704zM469.333 149.333h-320v725.334h320V149.333zM960 64v896H64V64h896z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1u = [
      _hoisted_2$1D
    ];
    function render$13(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1X, _hoisted_3$1u);
    }
    const LayoutIcon = { render: render$13 };
    const _hoisted_1$1W = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1C = /* @__PURE__ */ createBaseVNode("path", {
      d: "M725.333 213.333H298.667v85.334h-85.334v426.666h85.334v85.334h426.666v-85.334h85.334V298.667h-85.334v-85.334zm0-85.333V64H960v234.667h-64v426.666h64V960H725.333v-64H298.667v64H64V725.333h64V298.667H64V64h234.667v64h426.666zm-576 85.333h64v-64h-64v64zm0 661.334h64v-64h-64v64zm661.334 0h64v-64h-64v64zm0-725.334v64h64v-64h-64z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1t = [
      _hoisted_2$1C
    ];
    function render$12(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1W, _hoisted_3$1t);
    }
    const SizeIcon = { render: render$12 };
    const _hoisted_1$1V = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1B = /* @__PURE__ */ createBaseVNode("path", {
      d: "M682.667 256H341.333c-25.6 0-42.666-17.067-42.666-42.667s17.066-42.666 42.666-42.666h341.334c25.6 0 42.666 17.066 42.666 42.666S708.267 256 682.667 256zM682.667 853.333H341.333c-25.6 0-42.666-17.066-42.666-42.666S315.733 768 341.333 768h341.334c25.6 0 42.666 17.067 42.666 42.667s-17.066 42.666-42.666 42.666zM810.667 725.333c-25.6 0-42.667-17.066-42.667-42.666V341.333c0-25.6 17.067-42.666 42.667-42.666s42.666 17.066 42.666 42.666v341.334c0 25.6-17.066 42.666-42.666 42.666zM213.333 725.333c-25.6 0-42.666-17.066-42.666-42.666V341.333c0-25.6 17.066-42.666 42.666-42.666S256 315.733 256 341.333v341.334c0 25.6-17.067 42.666-42.667 42.666z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1s = /* @__PURE__ */ createBaseVNode("path", {
      d: "M981.333 1024H42.667C17.067 1024 0 1006.933 0 981.333V42.667C0 17.067 17.067 0 42.667 0h938.666c25.6 0 42.667 17.067 42.667 42.667v938.666c0 25.6-17.067 42.667-42.667 42.667zm-896-85.333h853.334V85.333H85.333v853.334z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$u = [
      _hoisted_2$1B,
      _hoisted_3$1s
    ];
    function render$11(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1V, _hoisted_4$u);
    }
    const SpacingIcon = { render: render$11 };
    const _hoisted_1$1U = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1A = /* @__PURE__ */ createBaseVNode("path", {
      d: "M775.68 896H205.653a120.277 120.277 0 0 1-120.32-120.32V205.653a120.32 120.32 0 0 1 120.32-120.32H777.26a120.277 120.277 0 0 1 120.32 120.32V777.26A122.368 122.368 0 0 1 775.68 896zM205.653 180.352a25.003 25.003 0 0 0-25.301 25.301V777.26c0 14.25 11.093 25.344 25.301 25.344H777.26c14.25 0 25.344-11.094 25.344-25.344V205.653a25.003 25.003 0 0 0-25.344-25.301H205.653z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1r = [
      _hoisted_2$1A
    ];
    function render$10(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1U, _hoisted_3$1r);
    }
    const BorderIcon = { render: render$10 };
    const _hoisted_1$1T = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1z = /* @__PURE__ */ createBaseVNode("path", {
      d: "M484.053 789.333 429.035 629.76H199.893l-55.445 159.573H48.64l217.067-601.258h100.416L583.21 789.333h-99.179zM311.125 297.26l-87.509 254.165h181.675l-87.083-254.165h-7.083zm466.923 424.149c67.499 0 117.504-42.901 117.504-99.157v-37.91l-110.848 7.083c-62.507 4.16-90.837 25.408-90.837 65.408 0 40.832 35.413 64.576 84.181 64.576zm-22.933 75.435c-87.488 0-151.254-52.907-151.254-135.851 0-81.664 60.843-128.747 168.747-135.403l122.944-7.082v-39.168c0-47.915-31.68-75.008-92.928-75.008-50.005 0-84.587 18.346-94.592 50.41h-86.656c9.173-77.909 82.496-127.914 185.408-127.914 113.75 0 177.92 56.682 177.92 152.512v309.994h-86.25V725.59h-7.083c-27.094 45.419-76.672 71.254-136.256 71.254z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1q = [
      _hoisted_2$1z
    ];
    function render$$(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1T, _hoisted_3$1q);
    }
    const FontIcon = { render: render$$ };
    const _hoisted_1$1S = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1y = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 981.333c-21.333 0-42.667-4.266-64-17.066L149.333 793.6c-38.4-21.333-64-64-64-110.933V341.333c0-46.933 25.6-89.6 64-110.933L448 59.733c38.4-21.333 89.6-21.333 128 0L874.667 230.4c38.4 21.333 64 64 64 110.933v341.334c0 46.933-25.6 89.6-64 110.933L576 964.267c-21.333 12.8-42.667 17.066-64 17.066zM512 128c-8.533 0-12.8 0-21.333 4.267L192 302.933c-12.8 8.534-21.333 21.334-21.333 38.4v341.334c0 17.066 8.533 29.866 21.333 38.4l298.667 170.666c12.8 8.534 29.866 8.534 42.666 0L832 721.067c12.8-8.534 21.333-21.334 21.333-38.4V341.333c0-17.066-8.533-29.866-21.333-38.4L533.333 132.267C524.8 128 520.533 128 512 128zm384 554.667z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1p = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 554.667c-8.533 0-12.8 0-21.333-4.267l-371.2-213.333C98.133 320 89.6 294.4 102.4 277.333c12.8-21.333 38.4-29.866 59.733-17.066L512 465.067l349.867-204.8C883.2 247.467 908.8 256 921.6 277.333c12.8 21.334 4.267 46.934-17.067 59.734L533.333 550.4c-8.533 4.267-12.8 4.267-21.333 4.267z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$t = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 985.6c-25.6 0-42.667-17.067-42.667-42.667V512c0-25.6 17.067-42.667 42.667-42.667S554.667 486.4 554.667 512v430.933c0 21.334-17.067 42.667-42.667 42.667z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_5$h = [
      _hoisted_2$1y,
      _hoisted_3$1p,
      _hoisted_4$t
    ];
    function render$_(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1S, _hoisted_5$h);
    }
    const ContainerIcon = { render: render$_ };
    const _hoisted_1$1R = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1x = /* @__PURE__ */ createBaseVNode("path", {
      d: "M853.333 938.667H170.667c-46.934 0-85.334-38.4-85.334-85.334V170.667c0-46.934 38.4-85.334 85.334-85.334h682.666c46.934 0 85.334 38.4 85.334 85.334v682.666c0 46.934-38.4 85.334-85.334 85.334zM844.8 742.4c-12.8 0-21.333 4.267-29.867 12.8L755.2 814.933c-17.067 17.067-17.067 42.667 0 59.734 8.533 8.533 17.067 12.8 29.867 12.8s21.333-4.267 29.866-12.8l59.734-59.734c8.533-8.533 12.8-17.066 12.8-29.866s-4.267-21.334-12.8-29.867c-8.534-8.533-21.334-12.8-29.867-12.8zm0-302.933c-12.8 0-21.333 4.266-29.867 12.8L452.267 814.933c-17.067 17.067-17.067 42.667 0 59.734 8.533 8.533 17.066 12.8 29.866 12.8s21.334-4.267 29.867-12.8L874.667 512c8.533-8.533 12.8-17.067 12.8-29.867s-4.267-21.333-12.8-29.866c-8.534-8.534-21.334-12.8-29.867-12.8zM814.933 166.4c-12.8 0-21.333 4.267-29.866 12.8L179.2 785.067c-8.533 8.533-12.8 17.066-12.8 29.866s4.267 21.334 12.8 29.867c8.533 8.533 17.067 12.8 29.867 12.8s21.333-4.267 29.866-12.8L844.8 238.933c8.533-8.533 12.8-17.066 12.8-29.866s-4.267-21.334-12.8-29.867c-8.533-8.533-21.333-12.8-29.867-12.8zm-273.066-29.867c-12.8 0-21.334 4.267-29.867 12.8L149.333 512c-8.533 8.533-12.8 17.067-12.8 29.867s4.267 21.333 12.8 29.866c8.534 8.534 17.067 12.8 29.867 12.8s21.333-4.266 29.867-12.8l362.666-362.666c8.534-8.534 12.8-17.067 12.8-29.867s-4.266-21.333-12.8-29.867c-8.533-8.533-17.066-12.8-29.866-12.8zm-302.934 0c-12.8 0-21.333 4.267-29.866 12.8l-59.734 59.734c-8.533 8.533-12.8 21.333-12.8 29.866 0 12.8 4.267 21.334 12.8 29.867 8.534 8.533 21.334 12.8 29.867 12.8 12.8 0 21.333-4.267 29.867-12.8l59.733-59.733c8.533-8.534 12.8-17.067 12.8-29.867s-4.267-21.333-12.8-29.867c-4.267-8.533-17.067-12.8-29.867-12.8z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1o = [
      _hoisted_2$1x
    ];
    function render$Z(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1R, _hoisted_3$1o);
    }
    const BackgroundIcon = { render: render$Z };
    const _hoisted_1$1Q = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1w = /* @__PURE__ */ createBaseVNode("path", {
      d: "M866.462 39.385h-512c-43.324 0-78.77 35.446-78.77 78.769v39.384h472.616c43.323 0 78.769 35.447 78.769 78.77v551.384h39.385c43.323 0 78.769-35.446 78.769-78.769v-590.77c0-43.322-35.446-78.768-78.77-78.768zM748.308 315.077c0-43.323-35.446-78.77-78.77-78.77h-512c-43.323 0-78.769 35.447-78.769 78.77v590.77c0 43.322 35.446 78.768 78.77 78.768h512c43.323 0 78.769-35.446 78.769-78.769v-590.77zM393.846 452.923c0 11.815-7.877 19.692-19.692 19.692H216.615c-11.815 0-19.692-7.877-19.692-19.692v-39.385c0-11.815 7.877-19.692 19.692-19.692h157.539c11.815 0 19.692 7.877 19.692 19.692v39.385zM551.385 768c0 11.815-7.877 19.692-19.693 19.692H216.615c-11.815 0-19.692-7.877-19.692-19.692v-39.385c0-11.815 7.877-19.692 19.692-19.692h315.077c11.816 0 19.693 7.877 19.693 19.692V768zm78.769-157.538c0 11.815-7.877 19.692-19.692 19.692H216.615c-11.815 0-19.692-7.877-19.692-19.692v-39.385c0-11.815 7.877-19.692 19.692-19.692h393.847c11.815 0 19.692 7.877 19.692 19.692v39.385z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1n = [
      _hoisted_2$1w
    ];
    function render$Y(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1Q, _hoisted_3$1n);
    }
    const CopyIcon = { render: render$Y };
    const _hoisted_1$1P = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1v = /* @__PURE__ */ createBaseVNode("path", {
      d: "m603.733 181.333-217.6 219.734c-6.4 6.4-10.666 14.933-12.8 25.6l-51.2 211.2c-8.533 38.4 23.467 74.666 61.867 64l200.533-53.334c8.534-2.133 17.067-6.4 23.467-14.933l234.667-236.8v456.533c0 40.534-32 72.534-70.4 74.667h-601.6C130.133 928 96 893.867 96 853.333V256c0-40.533 34.133-74.667 74.667-74.667h433.066z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1m = /* @__PURE__ */ createBaseVNode("path", {
      d: "M738.133 147.2 435.2 448c-4.267 4.267-6.4 8.533-8.533 14.933l-32 125.867c-6.4 23.467 14.933 44.8 38.4 38.4l128-29.867c6.4-2.133 10.666-4.266 14.933-8.533l300.8-302.933c38.4-38.4 38.4-102.4 0-140.8s-100.267-38.4-138.667 2.133z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$s = [
      _hoisted_2$1v,
      _hoisted_3$1m
    ];
    function render$X(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1P, _hoisted_4$s);
    }
    const BasicIcon = { render: render$X };
    const _hoisted_1$1O = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1u = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 708c-22.1 0-40-17.9-40-40s17.9-40 40-40 40 17.9 40 40-17.9 40-40 40zm62.9-219.5c-18.5 7.1-30.9 25.1-30.9 44.8V620c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8v-21.5c0-23.1 6.7-45.9 19.9-64.9 12.9-18.6 30.9-32.8 52.1-40.9 34-13.1 56-41.6 56-72.7 0-44.1-43.1-80-96-80s-96 35.9-96 80v7.6c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V420c0-39.3 17.2-76 48.4-103.3C430.4 290.4 470 276 512 276s81.6 14.5 111.6 40.7C654.8 344 672 380.7 672 420c0 57.8-38.1 109.8-97.1 132.5z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1l = [
      _hoisted_2$1u
    ];
    function render$W(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1O, _hoisted_3$1l);
    }
    const QuestionIcon = { render: render$W };
    const _hoisted_1$1N = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1t = /* @__PURE__ */ createBaseVNode("path", {
      d: "m219.465 949.687 9.728-48.567q3.438-1.17 46.592-12.288t63.708-21.43q16.018-19.969 23.405-57.71.585-4.023 35.401-165.157t65.17-310.565 29.697-169.399V150.31q-13.678-7.461-31.16-10.606t-39.716-4.535-33.133-3.145l10.825-58.88q18.87 1.17 68.535 3.73t85.43 4.023 68.828 1.463q27.428 0 56.32-1.463t69.12-4.023 56.32-3.73q-2.853 22.308-10.825 50.834-17.116 5.705-58.003 16.311t-62.025 19.163q-4.535 10.826-7.972 24.284t-5.12 22.82-4.316 25.966-3.73 23.991q-15.433 84.553-50.03 239.69t-44.251 203.117q-1.17 5.12-7.46 33.134t-11.411 51.419-9.143 47.69-3.438 32.84l.586 10.313q9.728 2.268 105.691 17.701-1.682 25.161-9.143 56.54-6.29 0-18.578.877t-18.578.878q-16.604 0-49.738-5.705T487.9 939.3q-78.848-1.17-117.686-1.17-29.111 0-81.701 5.12t-69.12 6.29z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1k = [
      _hoisted_2$1t
    ];
    function render$V(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1N, _hoisted_3$1k);
    }
    const ItalicIcon = { render: render$V };
    const _hoisted_1$1M = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1s = /* @__PURE__ */ createBaseVNode("path", {
      d: "M426.862 869.157q42.276 18.285 80.018 18.285 214.82 0 214.82-191.415 0-65.17-23.405-102.838-15.433-25.162-35.109-42.277t-38.546-26.55-46.007-14.264-47.982-5.997-53.979-1.17q-41.691 0-57.71 5.704 0 30.282-.292 90.844t-.293 90.258q0 4.535-.585 38.546t-.293 55.15 2.56 47.69 6.876 38.034zm-7.973-426.277q23.991 4.023 62.318 4.023 46.884 0 81.7-7.46t62.83-25.454 42.57-51.127 14.555-81.116q0-40.009-16.604-69.997t-45.129-46.885-61.732-24.869-70.876-7.972q-28.599 0-74.313 7.46 0 28.6 2.267 86.309t2.268 86.82q0 15.434-.293 45.715t-.292 45.129q0 26.258.585 39.424zM109.714 950.857l1.17-53.687q8.558-2.267 48.567-9.143t60.563-15.433q4.023-6.875 7.168-15.433t4.827-19.163 3.145-18.579 1.683-21.43.292-19.456v-37.45q0-561.152-12.58-585.728-2.268-4.534-12.581-8.265t-25.454-6.29-28.306-4.023-27.721-2.56-17.408-1.682l-2.268-47.397q56.028-1.17 194.268-6.583t213.138-5.412q13.166 0 39.132.292t38.546.293q40.009 0 77.97 7.46t73.436 23.991 61.732 40.595 42.277 59.684 16.018 78.556q0 29.696-9.435 54.564t-22.309 41.18-36.864 32.84-41.691 25.747-47.982 22.82q87.99 19.969 146.578 76.581t58.588 141.678q0 57.125-19.968 102.546t-53.395 74.606-78.848 48.86-93.403 27.72-100.572 7.973q-25.16 0-75.41-1.682t-75.41-1.682q-60.562 0-175.397 6.29t-132.023 6.875z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1j = [
      _hoisted_2$1s
    ];
    function render$U(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1M, _hoisted_3$1j);
    }
    const BoldIcon = { render: render$U };
    const _hoisted_1$1L = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1r = /* @__PURE__ */ createBaseVNode("path", {
      d: "M100.499 127.415q-21.138-1.17-25.746-2.268L73.07 74.825q7.46-.585 22.82-.585 34.305 0 64 2.267 75.411 4.023 94.867 4.023 49.152 0 96.037-1.682 66.267-2.267 83.456-2.853 32.036 0 49.152-1.17l-.585 7.973 1.17 36.571v5.12q-34.304 5.12-70.876 5.12-34.304 0-45.129 14.263-7.46 7.973-7.46 75.41 0 7.46.292 18.579t.293 14.555l.585 130.853 7.973 160.036q3.437 70.876 29.11 115.42 19.968 33.718 54.858 52.59 50.322 26.843 101.156 26.843 59.465 0 109.13-16.019 32.036-10.313 56.539-29.11 27.428-20.554 37.156-36.572 20.553-32.036 30.281-65.17 11.996-41.692 11.996-130.853 0-45.129-1.975-73.143t-6.29-69.997-7.68-91.136l-2.268-33.72q-2.852-38.253-13.677-50.321-19.456-19.968-44.032-19.456l-57.125 1.17-7.973-1.682 1.17-49.152h47.982l117.175 5.705q43.447 1.682 111.982-5.705l10.313 1.17q3.438 21.723 3.438 29.11 0 4.024-2.268 17.701-25.746 6.876-47.981 7.46-41.692 6.291-45.13 9.729-8.557 8.558-8.557 23.406 0 4.022.878 15.433t.877 17.7q4.535 10.825 12.58 226.304 3.439 111.397-8.557 173.715-8.558 43.446-23.406 69.705-21.723 37.156-64 70.29-42.861 32.549-104.009 50.834-62.317 18.871-145.7 18.871-95.452 0-162.304-26.258-68.023-26.844-102.254-69.705-34.89-43.447-47.397-111.397-9.142-45.714-9.142-135.46V271.287q0-107.447-9.728-121.71-14.263-20.553-83.968-22.308zM950.785 932.57V896q0-7.973-5.12-13.166t-13.166-5.12H91.356q-7.973 0-13.166 5.12T73.07 896v36.571q0 7.973 5.12 13.166t13.166 5.12h841.143q7.972 0 13.166-5.12t5.12-13.166z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1i = [
      _hoisted_2$1r
    ];
    function render$T(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1L, _hoisted_3$1i);
    }
    const UnderlineIcon = { render: render$T };
    const _hoisted_1$1K = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1q = /* @__PURE__ */ createBaseVNode("path", {
      d: "M1005.715 512q7.973 0 13.166 5.12t5.12 13.166v36.571q0 7.973-5.12 13.166t-13.166 5.12H18.287q-7.973 0-13.166-5.12t-5.12-13.166v-36.571q0-7.973 5.12-13.166T18.287 512h987.428zM275.97 475.429q-16.018-19.968-29.11-45.715-27.43-55.442-27.43-107.447 0-103.424 76.581-176.566 75.996-72.558 224.549-72.558 28.599 0 95.451 10.825 37.742 6.875 101.157 27.429 5.705 21.723 11.995 67.437 7.973 70.29 7.973 104.595 0 10.313-2.853 25.746l-6.875 1.682-47.982-3.438-7.973-1.17q-28.598-85.138-58.88-117.175-50.322-52.004-120.027-52.004-65.17 0-104.01 33.719-38.253 33.133-38.253 83.456 0 41.691 37.742 80.018t159.451 73.728q39.424 11.41 98.89 37.742 33.133 16.018 54.271 29.696H276.042zm289.719 146.285H800.55q4.022 22.309 4.022 52.59 0 63.415-23.405 121.125Q768 826.88 740.572 854.894q-21.138 19.968-62.317 46.3-45.715 27.428-87.406 37.74-45.714 11.996-116.005 11.996-65.17 0-111.396-13.165l-80.018-22.821q-32.549-9.143-41.18-16.018-4.535-4.535-4.535-12.58v-7.461q0-61.733-1.17-89.162-.585-17.115 0-38.838l1.17-21.139v-25.16l58.295-1.171q8.558 19.456 17.116 40.594t12.873 32.037 7.168 15.433q19.968 32.548 45.714 53.687 24.576 20.553 59.977 32.548 33.719 12.58 75.41 12.58 36.572 0 79.434-15.432 44.032-14.848 69.705-49.152 26.843-34.89 26.843-73.728 0-47.982-46.3-89.747-19.455-16.603-78.262-40.594z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1h = [
      _hoisted_2$1q
    ];
    function render$S(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1K, _hoisted_3$1h);
    }
    const LineThroughIcon = { render: render$S };
    const _hoisted_1$1J = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1p = /* @__PURE__ */ createBaseVNode("path", {
      d: "M1024 768v73.143q0 14.848-10.825 25.746t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 841.143V768q0-14.848 10.826-25.746t25.746-10.825h950.857q14.848 0 25.746 10.825T1024 768zM804.572 548.571v73.143q0 14.848-10.825 25.747T768 658.286H36.572q-14.848 0-25.746-10.825T0 621.714v-73.143q0-14.848 10.826-25.746T36.572 512H768q14.848 0 25.747 10.825t10.825 25.746zm146.286-219.428v73.143q0 14.848-10.826 25.746t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 402.286v-73.143q0-14.848 10.826-25.746t25.746-10.826h877.714q14.848 0 25.746 10.826t10.826 25.746zM731.429 109.714v73.143q0 14.848-10.825 25.746t-25.746 10.826H36.572q-14.848 0-25.746-10.826T0 182.857v-73.143q0-14.848 10.826-25.746t25.746-10.825h658.286q14.848 0 25.746 10.825t10.825 25.746z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1g = [
      _hoisted_2$1p
    ];
    function render$R(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1J, _hoisted_3$1g);
    }
    const AlignLeftIcon = { render: render$R };
    const _hoisted_1$1I = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1o = /* @__PURE__ */ createBaseVNode("path", {
      d: "M1024 768v73.143q0 14.848-10.825 25.746t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 841.143V768q0-14.848 10.826-25.746t25.746-10.825h950.857q14.848 0 25.746 10.825T1024 768zM804.572 548.571v73.143q0 14.848-10.825 25.747T768 658.286H256q-14.848 0-25.746-10.825t-10.825-25.747v-73.143q0-14.848 10.825-25.746T256 512h512q14.848 0 25.747 10.825t10.825 25.746zm146.286-219.428v73.143q0 14.848-10.826 25.746t-25.746 10.825H109.715q-14.848 0-25.747-10.825t-10.825-25.746v-73.143q0-14.848 10.825-25.746t25.747-10.826h804.571q14.848 0 25.746 10.826t10.826 25.746zM731.429 109.714v73.143q0 14.848-10.825 25.746t-25.746 10.826H329.143q-14.848 0-25.746-10.826t-10.825-25.746v-73.143q0-14.848 10.825-25.746t25.746-10.825h365.715q14.848 0 25.746 10.825t10.825 25.746z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1f = [
      _hoisted_2$1o
    ];
    function render$Q(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1I, _hoisted_3$1f);
    }
    const AlignCenterIcon = { render: render$Q };
    const _hoisted_1$1H = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1n = /* @__PURE__ */ createBaseVNode("path", {
      d: "M1024 768v73.143q0 14.848-10.825 25.746t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 841.143V768q0-14.848 10.826-25.746t25.746-10.825h950.857q14.848 0 25.746 10.825T1024 768zm0-219.429v73.143q0 14.848-10.825 25.747t-25.746 10.825H256q-14.848 0-25.746-10.825t-10.825-25.747v-73.143q0-14.848 10.825-25.746T256 512h731.43q14.847 0 25.745 10.825T1024 548.571zm0-219.428v73.143q0 14.848-10.825 25.746t-25.746 10.825H109.715q-14.848 0-25.747-10.825t-10.825-25.746v-73.143q0-14.848 10.825-25.746t25.747-10.826h877.714q14.848 0 25.746 10.826T1024 329.143zm0-219.429v73.143q0 14.848-10.825 25.746T987.43 219.43H329.143q-14.848 0-25.746-10.826t-10.825-25.746v-73.143q0-14.848 10.825-25.746t25.746-10.825H987.43q14.848 0 25.746 10.825T1024 109.714z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1e = [
      _hoisted_2$1n
    ];
    function render$P(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1H, _hoisted_3$1e);
    }
    const AlignRightIcon = { render: render$P };
    const _hoisted_1$1G = {
      class: "icon",
      viewBox: "0 0 1025 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1m = /* @__PURE__ */ createBaseVNode("path", {
      d: "M1024 768v73.143q0 14.848-10.825 25.746t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 841.143V768q0-14.848 10.826-25.746t25.746-10.825h950.857q14.848 0 25.746 10.825T1024 768zm0-219.429v73.143q0 14.848-10.825 25.747t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 621.714v-73.143q0-14.848 10.826-25.746T36.572 512h950.857q14.848 0 25.746 10.825T1024 548.571zm0-219.428v73.143q0 14.848-10.825 25.746t-25.746 10.825H36.572q-14.848 0-25.746-10.825T0 402.286v-73.143q0-14.848 10.826-25.746t25.746-10.826h950.857q14.848 0 25.746 10.826T1024 329.143zm0-219.429v73.143q0 14.848-10.825 25.746T987.43 219.43H36.572q-14.848 0-25.746-10.826T0 182.857v-73.143q0-14.848 10.826-25.746t25.746-10.825h950.857q14.848 0 25.746 10.825T1024 109.714z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1d = [
      _hoisted_2$1m
    ];
    function render$O(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1G, _hoisted_3$1d);
    }
    const AlignJustifyIcon = { render: render$O };
    const _hoisted_1$1F = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1l = /* @__PURE__ */ createBaseVNode("path", {
      d: "M874.098 149.902a512 512 0 1 0 0 724.196 512 512 0 0 0 0-724.196zm-69.974 526.222a51.2 51.2 0 0 1-72.533 0L512 455.111 292.124 674.987a51.2 51.2 0 1 1-72.533-72.25l256-256a51.2 51.2 0 0 1 72.533 0l256 256a51.2 51.2 0 0 1 0 73.387z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1c = [
      _hoisted_2$1l
    ];
    function render$N(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1F, _hoisted_3$1c);
    }
    const TopCircleIcon = { render: render$N };
    const _hoisted_1$1E = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1k = /* @__PURE__ */ createBaseVNode("path", {
      d: "M672 893.344V800a32 32 0 0 1 64 0v93.344A192.16 192.16 0 0 0 893.344 736H800a32 32 0 0 1 0-64h93.344A192.16 192.16 0 0 0 736 514.656V608a32 32 0 0 1-64 0v-93.344A192.16 192.16 0 0 0 514.656 672H608a32 32 0 0 1 0 64h-93.344A192.16 192.16 0 0 0 672 893.344zm224-445.376a319.712 319.712 0 0 0-64-37.344V224a32 32 0 0 0-32-32H160a32 32 0 0 0-32 32v512a32 32 0 0 0 32 32h230.4c4.512 22.272 11.36 43.68 20.224 64H128a64 64 0 0 1-64-64V192a64 64 0 0 1 64-64h704a64 64 0 0 1 64 64v256zM704 960a256 256 0 1 1 0-512 256 256 0 0 1 0 512z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1b = [
      _hoisted_2$1k
    ];
    function render$M(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1E, _hoisted_3$1b);
    }
    const AbsoluteIcon = { render: render$M };
    const _hoisted_1$1D = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1j = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 0C229.23 0 0 229.23 0 512s229.23 512 512 512 512-229.23 512-512S794.77 0 512 0zm80 768a80 80 0 0 1-160 0v-32a80 80 0 0 1 160 0v32zm0-256a80 80 0 0 1-160 0V256a80 80 0 0 1 160 0v256z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$1a = [
      _hoisted_2$1j
    ];
    function render$L(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1D, _hoisted_3$1a);
    }
    const WarningIcon = { render: render$L };
    const _hoisted_1$1C = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1i = /* @__PURE__ */ createBaseVNode("path", {
      d: "M864 448h-48V304C816 136.4 679.6 0 512 0S208 136.4 208 304v144h-48c-53 0-96 43-96 96v384c0 53 43 96 96 96h704c53 0 96-43 96-96V544c0-53-43-96-96-96zm-208 0H368V304c0-79.4 64.6-144 144-144s144 64.6 144 144v144z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$19 = [
      _hoisted_2$1i
    ];
    function render$K(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1C, _hoisted_3$19);
    }
    const LockIcon = { render: render$K };
    const _hoisted_1$1B = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1h = /* @__PURE__ */ createBaseVNode("path", {
      d: "M863.998 512.001H368v-206.2c0-79.2 63.4-145 142.6-145.8 80-.8 145.4 64.2 145.4 144v32c0 26.6 21.4 48 48 48h64c26.6 0 48-21.4 48-48v-32c0-168-137-304.599-305-303.999-168 .6-303 139-303 307V512h-48c-53 0-95.999 43-95.999 96v320c0 53 43 95.999 96 95.999h703.998c53 0 96-43 96-96V608c0-53-43-95.999-96-95.999z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$18 = [
      _hoisted_2$1h
    ];
    function render$J(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1B, _hoisted_3$18);
    }
    const UnlockIcon = { render: render$J };
    const _hoisted_1$1A = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1g = /* @__PURE__ */ createBaseVNode("path", {
      d: "M788.928 705.984a44.992 44.992 0 0 1-32.896-14.08c-18.752-18.752-18.752-48.512 0-65.728l112.64-112.64-112.64-112.64c-18.752-18.752-18.752-48.448 0-65.664 18.816-18.816 48.512-18.816 65.728 0L968.832 482.24c9.344 9.408 14.08 20.352 14.08 32.896a42.624 42.624 0 0 1-14.08 32.832L821.76 695.04a63.36 63.36 0 0 1-32.832 10.944zm-552.256 0a44.992 44.992 0 0 1-32.896-14.08L56.768 544.832A42.624 42.624 0 0 1 42.688 512c0-12.544 4.672-25.024 14.08-32.832l147.008-147.072c18.816-18.752 48.512-18.752 65.728 0 18.752 18.752 18.752 48.512 0 65.728L155.328 512l112.64 112.64c18.752 18.752 18.752 48.512 0 65.728a38.464 38.464 0 0 1-31.36 15.616z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$17 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M934.4 558.912H89.6A46.08 46.08 0 0 1 42.688 512 46.08 46.08 0 0 1 89.6 465.088h844.8A46.08 46.08 0 0 1 981.312 512a46.08 46.08 0 0 1-46.912 46.912zM659.072 283.584a45.056 45.056 0 0 1-32.896-14.08L512 155.328l-112.64 112.64c-18.752 18.752-48.512 18.752-65.728 0-18.752-18.816-18.752-48.512 0-65.728L480.704 55.168c18.752-18.752 48.512-18.752 65.728 0L693.44 202.24c18.816 18.752 18.816 48.512 0 65.728-10.88 10.88-21.888 15.616-34.368 15.616zM512 981.312a44.992 44.992 0 0 1-32.832-14.08L332.096 820.224c-18.752-18.816-18.752-48.512 0-65.728 18.752-18.752 48.512-18.752 65.728 0l112.64 112.64 112.64-112.64c18.752-18.752 48.448-18.752 65.664 0 18.752 18.752 18.752 48.512 0 65.728L541.696 967.232c-4.672 10.944-17.152 14.08-29.696 14.08z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$r = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 981.312a46.08 46.08 0 0 1-46.912-46.912V89.6A46.08 46.08 0 0 1 512 42.688 46.08 46.08 0 0 1 558.912 89.6v844.8A46.08 46.08 0 0 1 512 981.312z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_5$g = [
      _hoisted_2$1g,
      _hoisted_3$17,
      _hoisted_4$r
    ];
    function render$I(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1A, _hoisted_5$g);
    }
    const DragIcon = { render: render$I };
    const _hoisted_1$1z = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1f = /* @__PURE__ */ createBaseVNode("path", {
      d: "M934.4 981.312H89.6a46.08 46.08 0 0 1-46.912-46.848V156.672A46.08 46.08 0 0 1 89.6 109.824h367.616a46.08 46.08 0 0 1 46.976 46.848 46.08 46.08 0 0 1-46.976 46.848h-320.64v684.16h750.912V515.904a46.08 46.08 0 0 1 46.912-46.848 46.08 46.08 0 0 1 46.912 46.848v418.56a47.04 47.04 0 0 1-46.912 46.848z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$16 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M330.496 739.2a42.624 42.624 0 0 1-32.832-14.016 44.928 44.928 0 0 1-14.08-32.768V504.96c0-12.48 4.672-24.96 14.08-32.768L713.792 56.704a42.624 42.624 0 0 1 32.896-14.08c12.48 0 24.96 4.736 32.832 14.08L967.232 244.16c18.816 18.752 18.816 48.384 0 65.6L551.104 725.12a45.056 45.056 0 0 1-32.832 14.08H330.496zm46.976-215.488v120.32H497.92l369.216-367.104-120.448-121.792-369.28 368.576z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$q = [
      _hoisted_2$1f,
      _hoisted_3$16
    ];
    function render$H(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1z, _hoisted_4$q);
    }
    const EditIcon = { render: render$H };
    const _hoisted_1$1y = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1e = /* @__PURE__ */ createBaseVNode("path", {
      d: "M934.464 517.44c-14.08 0-29.696-6.4-39.04-20.864-120.32-177.92-253.056-272.448-384.192-272.448-131.2 0-262.4 94.592-382.72 272.448-14.016 22.4-43.712 27.264-65.536 12.8-21.888-14.4-26.56-44.8-12.544-67.264C192.64 233.792 347.2 128 511.232 128 675.2 128 831.36 233.792 971.968 442.112c14.08 22.4 9.344 51.2-12.544 67.264a42.432 42.432 0 0 1-24.96 8.064z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$15 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M511.232 810.688c-164.032 0-318.656-105.792-460.8-314.112a49.664 49.664 0 0 1 12.544-67.328 46.848 46.848 0 0 1 65.6 12.8c120.256 177.92 252.992 272.448 384.192 272.448 131.2 0 262.4-94.528 384.192-272.384 14.08-22.4 43.776-27.264 65.6-12.8 21.888 14.4 26.56 44.8 12.544 67.264-143.68 208.32-298.304 314.112-463.872 314.112z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$p = /* @__PURE__ */ createBaseVNode("path", {
      d: "M511.232 668.032c-106.24 0-193.664-89.728-193.664-198.72 0-108.928 87.424-198.656 193.664-198.656 106.24 0 193.664 89.728 193.664 198.656 0 108.992-85.888 198.72-193.664 198.72zm0-301.248c-54.656 0-99.968 46.464-99.968 102.528 0 56.128 45.312 102.592 99.968 102.592 54.656 0 99.968-46.464 99.968-102.592 0-56.064-43.776-102.528-99.968-102.528z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_5$f = [
      _hoisted_2$1e,
      _hoisted_3$15,
      _hoisted_4$p
    ];
    function render$G(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1y, _hoisted_5$f);
    }
    const PreviewIcon = { render: render$G };
    const _hoisted_1$1x = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1d = /* @__PURE__ */ createBaseVNode("path", {
      d: "M480.768 151.04h59.008c3.456 0 10.432-3.456 10.432-10.368V43.456c0-3.456-3.52-10.368-10.432-10.368h-59.008c-3.456 0-6.976 3.456-10.432 6.912v100.672c3.456 6.912 6.976 10.368 10.432 10.368zM196.16 286.4h6.976l41.6-41.6c3.52-3.52 3.52-3.52 3.52-6.976s0-3.456-3.52-6.912l-69.376-69.44c0-3.456-3.456-3.456-6.976-3.456 0 0-3.456 0-3.456 3.456l-45.12 41.6v7.04c0 3.392 0 3.392 3.456 6.912l69.44 69.376h3.456zm704.576-83.264-41.664-41.664c0-3.456-3.456-3.456-6.976-3.456-3.456 0-3.456 0-6.912 3.456l-69.44 69.44c-3.456 3.456-3.456 3.456-3.456 6.912s0 3.456 3.456 6.976l41.664 41.6h6.976c3.456 0 3.456 0 6.912-3.456l69.44-69.44c3.456-3.456 3.456-3.456 3.456-6.912l-3.456-3.456zM147.584 890.24h728.832v69.44H147.584v-69.44zm34.688-100.608c0 17.28 13.888 31.232 31.232 31.232h121.472V557.12h65.92v263.808h409.6a31.104 31.104 0 0 0 31.232-31.232V546.752A329.6 329.6 0 0 0 512 216.96c-180.48 0-329.728 149.248-329.728 329.728v242.944z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$14 = [
      _hoisted_2$1d
    ];
    function render$F(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1x, _hoisted_3$14);
    }
    const EventIcon = { render: render$F };
    const _hoisted_1$1w = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1c = /* @__PURE__ */ createBaseVNode("path", {
      d: "M170.667 85.333a85.038 85.038 0 0 0-85.334 85.334v426.666h85.334V170.667h426.666V85.333H170.667M341.333 256A85.038 85.038 0 0 0 256 341.333V768h85.333V341.333H768V256H341.333M512 426.667A85.038 85.038 0 0 0 426.667 512v341.333A85.038 85.038 0 0 0 512 938.667h341.333a85.038 85.038 0 0 0 85.334-85.334V512a85.038 85.038 0 0 0-85.334-85.333H512z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$13 = [
      _hoisted_2$1c
    ];
    function render$E(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1w, _hoisted_3$13);
    }
    const AnimationIcon = { render: render$E };
    const _hoisted_1$1v = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1b = /* @__PURE__ */ createBaseVNode("path", {
      d: "M720.32 768a45.76 45.76 0 0 1-33.408-14.336l-416.64-416.576c-19.072-19.072-19.072-49.28 0-66.752 19.136-19.136 49.28-19.136 66.816 0l416.64 414.976c19.072 19.072 19.072 49.28 0 66.816A44.288 44.288 0 0 1 720.32 768z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$12 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M303.68 768a45.76 45.76 0 0 1-33.344-14.336c-19.136-19.072-19.136-49.28 0-66.752l414.976-416.64c19.072-19.072 49.28-19.072 66.816 0 19.072 19.136 19.072 49.28 0 66.816l-415.04 416.64A45.76 45.76 0 0 1 303.68 768z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$o = [
      _hoisted_2$1b,
      _hoisted_3$12
    ];
    function render$D(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1v, _hoisted_4$o);
    }
    const CloseIcon = { render: render$D };
    const _hoisted_1$1u = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$1a = /* @__PURE__ */ createBaseVNode("path", {
      d: "M823.467 512H578.133V324.267c0-66.134-53.333-119.467-117.333-119.467s-117.333 53.333-117.333 119.467V620.8l-21.334-21.333c-46.933-46.934-121.6-46.934-168.533-2.134s-44.8 121.6 2.133 168.534L330.667 940.8c6.4 6.4 14.933 8.533 23.466 8.533 8.534 0 17.067-2.133 23.467-8.533 12.8-12.8 12.8-32 0-44.8L202.667 721.067c-21.334-21.334-23.467-57.6-2.134-76.8 21.334-21.334 55.467-19.2 76.8 2.133L352 721.067c12.8 12.8 32 12.8 44.8 0 6.4-6.4 8.533-14.934 8.533-23.467V326.4c0-29.867 23.467-55.467 53.334-55.467S512 296.533 512 326.4v219.733c0 17.067 14.933 32 32 32h277.333c6.4 0 10.667 6.4 10.667 12.8v326.4c0 17.067 14.933 32 32 32s32-14.933 32-32V586.667C898.133 546.133 864 512 823.467 512z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$11 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M266.667 330.667c17.066 0 32-14.934 32-32 0-87.467 72.533-160 160-160s160 72.533 160 160c0 17.066 14.933 32 32 32s32-14.934 32-32c0-123.734-100.267-224-224-224s-224 100.266-224 224c0 17.066 14.933 32 32 32z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$n = [
      _hoisted_2$1a,
      _hoisted_3$11
    ];
    function render$C(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1u, _hoisted_4$n);
    }
    const EffectIcon = { render: render$C };
    const _hoisted_1$1t = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$19 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M802.752 583.936H178.56a49.728 49.728 0 0 1-50.56-50.56c0-28.736 21.952-50.624 50.56-50.624h624.192c28.672 0 50.56 21.888 50.56 50.56s-21.888 50.624-50.56 50.624z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$10 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M490.688 896a49.728 49.728 0 0 1-50.624-50.56V221.184c0-28.672 21.952-50.56 50.56-50.56 28.736 0 50.624 21.888 50.624 50.56v624.128c0 28.672-21.888 50.624-50.56 50.624z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$m = [
      _hoisted_2$19,
      _hoisted_3$10
    ];
    function render$B(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1t, _hoisted_4$m);
    }
    const PlusIcon = { render: render$B };
    const _hoisted_1$1s = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$18 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M384 464c0 26.4-21.6 48-48 48h-96c-26.4 0-48-21.6-48-48v-96c0-26.4 21.6-48 48-48h96c26.4 0 48 21.6 48 48v96zm320 0c0 26.4-21.6 48-48 48h-96c-26.4 0-48-21.6-48-48v-96c0-26.4 21.6-48 48-48h96c26.4 0 48 21.6 48 48v96zM384 784c0 26.4-21.6 48-48 48h-96c-26.4 0-48-21.6-48-48v-96c0-26.4 21.6-48 48-48h96c26.4 0 48 21.6 48 48v96zm320 0c0 26.4-21.6 48-48 48h-96c-26.4 0-48-21.6-48-48v-96c0-26.4 21.6-48 48-48h96c26.4 0 48 21.6 48 48v96zm208.096-624L1024 48.096V0h-48.096L864 111.904 752.096 0H704v48.096L815.904 160 704 271.904V320h48.096L864 208.096 975.904 320H1024v-48.096zM0 768h64v128H0V768zm0-192h64v128H0V576zm832-128h64v128h-64V448zm0 384h64v128h-64V832zm0-192h64v128h-64V640zM0 384h64v128H0V384zm0-192h64v128H0V192zm512-64h128v64H512v-64zm-192 0h128v64H320v-64zm-192 0h128v64H128v-64zm320 832h128v64H448v-64zm192 0h128v64H640v-64zm-384 0h128v64H256v-64zm-192 0h128v64H64v-64z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$$ = [
      _hoisted_2$18
    ];
    function render$A(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1s, _hoisted_3$$);
    }
    const SeparateIcon = { render: render$A };
    const _hoisted_1$1r = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$17 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M689.439 675.84v122.88c0 90.48-74.978 163.84-167.465 163.84C267.612 962.56 61.44 760.832 61.44 512S267.633 61.44 521.974 61.44c169.37 0 319.815 88.064 397.414 222.74 33.157 57.57 47.207 113.03 42.189 166.38 0 56.545-46.879 102.4-104.673 102.4h-41.882c-69.366 0-125.583 55.01-125.583 122.88zM491.52 860.16a81.92 81.92 0 1 0 0-163.84 81.92 81.92 0 0 0 0 163.84zm-204.8-163.84a81.92 81.92 0 1 0 0-163.84 81.92 81.92 0 0 0 0 163.84zm-20.48-245.76a81.92 81.92 0 1 0 0-163.84 81.92 81.92 0 0 0 0 163.84zm204.8-122.88a81.92 81.92 0 1 0 0-163.84 81.92 81.92 0 0 0 0 163.84zm225.28 61.44a81.92 81.92 0 1 0 0-163.84 81.92 81.92 0 0 0 0 163.84z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$_ = [
      _hoisted_2$17
    ];
    function render$z(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1r, _hoisted_3$_);
    }
    const ColorIcon = { render: render$z };
    const _hoisted_1$1q = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$16 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M810.667 170.667H213.333a128 128 0 0 0-128 128v426.666a128 128 0 0 0 128 128h597.334a128 128 0 0 0 128-128V298.667a128 128 0 0 0-128-128zM213.333 768a42.667 42.667 0 0 1-42.666-42.667V622.08l140.8-140.373a42.667 42.667 0 0 1 59.733 0L657.493 768zm640-42.667A42.667 42.667 0 0 1 810.667 768h-32.854l-162.56-163.413L652.8 567.04a42.667 42.667 0 0 1 59.733 0l140.8 140.373zm0-138.24-80.213-79.786a130.56 130.56 0 0 0-180.907 0l-37.546 37.546-122.88-122.88a130.56 130.56 0 0 0-180.907 0l-80.213 79.787V298.667A42.667 42.667 0 0 1 213.333 256h597.334a42.667 42.667 0 0 1 42.666 42.667z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$Z = [
      _hoisted_2$16
    ];
    function render$y(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1q, _hoisted_3$Z);
    }
    const ImageIcon = { render: render$y };
    const _hoisted_1$1p = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$15 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M725.333 256H298.667a42.667 42.667 0 0 0 0 85.333h170.666v384a42.667 42.667 0 0 0 85.334 0v-384h170.666a42.667 42.667 0 0 0 0-85.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$Y = [
      _hoisted_2$15
    ];
    function render$x(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1p, _hoisted_3$Y);
    }
    const TextIcon = { render: render$x };
    const _hoisted_1$1o = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$14 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M853.333 690.347V333.653a128 128 0 1 0-162.986-162.986H333.653a128 128 0 1 0-162.986 162.986v356.694a128 128 0 1 0 162.986 162.986h356.694a128 128 0 1 0 162.986-162.986zm-42.666-519.68A42.667 42.667 0 1 1 768 213.333a42.667 42.667 0 0 1 42.667-42.666zm-597.334 0a42.667 42.667 0 1 1-42.666 42.666 42.667 42.667 0 0 1 42.666-42.666zm0 682.666A42.667 42.667 0 1 1 256 810.667a42.667 42.667 0 0 1-42.667 42.666zM690.347 768H333.653A128 128 0 0 0 256 690.347V333.653A128 128 0 0 0 333.653 256h356.694A128 128 0 0 0 768 333.653v356.694A128 128 0 0 0 690.347 768zm120.32 85.333a42.667 42.667 0 1 1 42.666-42.666 42.667 42.667 0 0 1-42.666 42.666z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$X = [
      _hoisted_2$14
    ];
    function render$w(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1o, _hoisted_3$X);
    }
    const BlockIcon = { render: render$w };
    const _hoisted_1$1n = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$13 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M128 384a42.667 42.667 0 0 0 42.667-42.667v-128a42.667 42.667 0 0 1 42.666-42.666h128a42.667 42.667 0 0 0 0-85.334h-128a128 128 0 0 0-128 128v128A42.667 42.667 0 0 0 128 384zm213.333 469.333h-128a42.667 42.667 0 0 1-42.666-42.666v-128a42.667 42.667 0 0 0-85.334 0v128a128 128 0 0 0 128 128h128a42.667 42.667 0 0 0 0-85.334zm170.667-512A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333zm0 256A85.333 85.333 0 1 1 597.333 512 85.333 85.333 0 0 1 512 597.333zm298.667-512h-128a42.667 42.667 0 0 0 0 85.334h128a42.667 42.667 0 0 1 42.666 42.666v128a42.667 42.667 0 0 0 85.334 0v-128a128 128 0 0 0-128-128zM896 640a42.667 42.667 0 0 0-42.667 42.667v128a42.667 42.667 0 0 1-42.666 42.666h-128a42.667 42.667 0 0 0 0 85.334h128a128 128 0 0 0 128-128v-128A42.667 42.667 0 0 0 896 640z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$W = [
      _hoisted_2$13
    ];
    function render$v(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1n, _hoisted_3$W);
    }
    const CircleIcon = { render: render$v };
    const _hoisted_1$1m = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$12 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M554.667 298.667h-128A42.667 42.667 0 0 0 384 341.333v341.334a42.667 42.667 0 0 0 85.333 0v-85.334h85.334a128 128 0 0 0 128-128v-42.666a128 128 0 0 0-128-128zm42.666 170.666A42.667 42.667 0 0 1 554.667 512h-85.334V384h85.334a42.667 42.667 0 0 1 42.666 42.667zM512 85.333A426.667 426.667 0 1 0 938.667 512 426.667 426.667 0 0 0 512 85.333zm0 768A341.333 341.333 0 1 1 853.333 512 341.333 341.333 0 0 1 512 853.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$V = [
      _hoisted_2$12
    ];
    function render$u(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1m, _hoisted_3$V);
    }
    const SymbolIcon = { render: render$u };
    const _hoisted_1$1l = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$11 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M426.667 85.333A42.667 42.667 0 0 1 469.333 128v170.667a42.667 42.667 0 0 1-42.666 42.666h-85.334v85.334h213.334V384a42.667 42.667 0 0 1 42.666-42.667h256A42.667 42.667 0 0 1 896 384v170.667a42.667 42.667 0 0 1-42.667 42.666h-256a42.667 42.667 0 0 1-42.666-42.666V512H341.333v256h213.334v-42.667a42.667 42.667 0 0 1 42.666-42.666h256A42.667 42.667 0 0 1 896 725.333V896a42.667 42.667 0 0 1-42.667 42.667h-256A42.667 42.667 0 0 1 554.667 896v-42.667h-256A42.667 42.667 0 0 1 256 810.667V341.333h-85.333A42.667 42.667 0 0 1 128 298.667V128a42.667 42.667 0 0 1 42.667-42.667h256zm384 682.667H640v85.333h170.667V768zm0-341.333H640V512h170.667v-85.333zM384 170.667H213.333V256H384v-85.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$U = [
      _hoisted_2$11
    ];
    function render$t(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1l, _hoisted_3$U);
    }
    const LayersIcon = { render: render$t };
    const _hoisted_1$1k = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$10 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M400 573.03s56 6.3 56 55.28v276.41S447.827 960 400 960H120s-55.998-9.785-55.998-55.28V628.293c.063-1.084 3.444-55.265 55.999-55.265zm504.003 0s55.999 6.3 55.999 55.28v276.41s-6.384 55.28-56 55.28h-280s-55.998-2.872-55.998-55.28V628.31s11.646-55.28 55.999-55.28zM400 75.49c51.355 0 55.999 55.281 55.999 55.281v276.41c0 43.784-56 55.28-56 55.28H120s-55.998-9.784-55.998-55.28V130.77c0-50.692 55.999-55.28 55.999-55.28zM785.549 64c11.232 0 20.379 9.03 20.379 20.118l12.272 43.59a154.233 154.233 0 0 1 25.698 14.656l44.485-11.305c9.753-5.515 22.19-2.217 27.832 7.41l30.572 52.302c5.586 9.63 2.246 21.902-7.506 27.476l-32.159 32.34c.494 4.868.713 9.68.713 14.66 0 4.974-.22 9.892-.713 14.655l32.213 32.34c9.753 5.571 13.04 17.904 7.452 27.583l-30.572 52.298c-5.641 9.627-18.08 12.978-27.832 7.41l-44.43-11.305c-8 5.625-16.6 10.6-25.698 14.655l-12.272 43.702c0 11.089-9.148 20.118-20.38 20.118h-61.197c-11.232 0-20.38-9.03-20.38-20.118l-12.272-43.702a153.813 153.813 0 0 1-25.696-14.655l-44.486 11.305c-9.752 5.514-22.19 2.217-27.831-7.41l-30.571-52.298c-5.592-9.628-2.246-21.906 7.505-27.476l32.16-32.342c-.494-4.869-.714-9.734-.714-14.656 0-4.975.22-9.897.713-14.656l-32.159-32.343c-9.751-5.572-13.15-17.847-7.505-27.474l30.459-52.298c5.645-9.626 18.08-12.982 27.831-7.41l44.49 11.302c7.999-5.622 16.599-10.596 25.692-14.656l12.272-43.698c0-11.088 9.152-20.118 20.38-20.118zm-30.57 130.77c-39.39 0-71.387 31.586-71.387 70.472 0 38.885 31.997 70.472 71.387 70.472 39.391 0 71.277-31.529 71.39-70.472 0-38.886-31.998-70.472-71.39-70.472z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$T = [
      _hoisted_2$10
    ];
    function render$s(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1k, _hoisted_3$T);
    }
    const LayersSlashIcon = { render: render$s };
    const _hoisted_1$1j = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$$ = /* @__PURE__ */ createBaseVNode("path", {
      d: "M682.667 426.667h-85.334v-85.334a42.667 42.667 0 0 0-42.666-42.666H341.333a42.667 42.667 0 0 0-42.666 42.666v213.334a42.667 42.667 0 0 0 42.666 42.666h85.334v85.334a42.667 42.667 0 0 0 42.666 42.666h213.334a42.667 42.667 0 0 0 42.666-42.666V469.333a42.667 42.667 0 0 0-42.666-42.666zm-256 42.666V512H384V384h128v42.667h-42.667a42.667 42.667 0 0 0-42.666 42.666zM640 640H512V512h128zm256 139.947V244.053A85.333 85.333 0 1 0 779.947 128H244.053A85.333 85.333 0 1 0 128 244.053v535.894A85.333 85.333 0 1 0 244.053 896h535.894A85.333 85.333 0 1 0 896 779.947zm-85.333 0a81.493 81.493 0 0 0-30.72 30.72H244.053a81.493 81.493 0 0 0-30.72-30.72V244.053a81.493 81.493 0 0 0 30.72-30.72h535.894a81.493 81.493 0 0 0 30.72 30.72z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$S = [
      _hoisted_2$$
    ];
    function render$r(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1j, _hoisted_3$S);
    }
    const ModuleIcon = { render: render$r };
    const _hoisted_1$1i = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$_ = /* @__PURE__ */ createBaseVNode("path", {
      d: "M896 469.333A42.667 42.667 0 0 0 853.333 512a343.467 343.467 0 1 1-94.72-234.667h-102.4a42.667 42.667 0 0 0 0 85.334h193.28A42.667 42.667 0 0 0 892.16 320V128a42.667 42.667 0 0 0-85.333 0v75.52A426.667 426.667 0 1 0 938.667 512 42.667 42.667 0 0 0 896 469.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$R = [
      _hoisted_2$_
    ];
    function render$q(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1i, _hoisted_3$R);
    }
    const RedoIcon = { render: render$q };
    const _hoisted_1$1h = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$Z = /* @__PURE__ */ createBaseVNode("path", {
      d: "m371.627 328.96 97.706-98.133V640a42.667 42.667 0 0 0 85.334 0V230.827l97.706 98.133a42.667 42.667 0 0 0 60.587 0 42.667 42.667 0 0 0 0-60.587L542.293 97.707a42.667 42.667 0 0 0-14.08-8.96 42.667 42.667 0 0 0-32.426 0 42.667 42.667 0 0 0-14.08 8.96L311.04 268.373a42.667 42.667 0 1 0 60.587 60.587zM896 512a42.667 42.667 0 0 0-42.667 42.667v256a42.667 42.667 0 0 1-42.666 42.666H213.333a42.667 42.667 0 0 1-42.666-42.666v-256a42.667 42.667 0 0 0-85.334 0v256a128 128 0 0 0 128 128h597.334a128 128 0 0 0 128-128v-256A42.667 42.667 0 0 0 896 512z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$Q = [
      _hoisted_2$Z
    ];
    function render$p(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1h, _hoisted_3$Q);
    }
    const UploadIcon = { render: render$p };
    const _hoisted_1$1g = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$Y = /* @__PURE__ */ createBaseVNode("path", {
      d: "M846.77 78.77C846.77 35.445 811.322 0 768 0H256c-43.323 0-78.77 35.446-78.77 78.77v866.46c0 43.324 35.447 78.77 78.77 78.77h512c43.323 0 78.77-35.446 78.77-78.77V78.77zM512 984.614c-33.477 0-59.077-25.6-59.077-59.077s25.6-59.076 59.077-59.076 59.077 25.6 59.077 59.076-25.6 59.077-59.077 59.077zm216.615-187.077c0 15.754-13.784 29.539-29.538 29.539H324.923c-15.754 0-29.538-13.785-29.538-29.539V187.077c0-15.754 13.784-29.539 29.538-29.539h374.154c15.754 0 29.538 13.785 29.538 29.539v610.461z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$P = [
      _hoisted_2$Y
    ];
    function render$o(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1g, _hoisted_3$P);
    }
    const MobileIcon = { render: render$o };
    const _hoisted_1$1f = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$X = /* @__PURE__ */ createBaseVNode("path", {
      d: "M710.892 498.215v277.662c0 13.785-11.815 27.57-27.569 27.57H405.662L236.308 972.8c11.815 7.877 25.6 11.815 39.384 11.815h472.616c39.384 0 72.861-33.477 72.861-72.861V387.938L710.892 498.215zM512 947.2c-31.508 0-55.138-23.63-55.138-55.138s23.63-55.139 55.138-55.139 55.138 23.63 55.138 55.139S543.508 947.2 512 947.2zm-309.17-49.23 112.247-112.247v-1.97L712.862 385.97v1.97L821.169 279.63v-1.97l137.846-137.846C972.8 128 974.77 106.338 964.923 96.492l-39.385-37.415c-11.815-11.815-31.507-9.846-43.323 5.908L821.17 126.03v-13.785c0-39.384-33.477-72.861-72.861-72.861H275.692c-39.384 0-72.861 33.477-72.861 72.861V744.37L63.015 884.185C51.2 896 49.231 915.692 59.077 925.538l37.415 39.385c11.816 11.815 31.508 9.846 43.323-5.908l63.016-61.046zm108.308-685.293c0-13.785 11.816-27.57 27.57-27.57h344.615c13.785 0 27.57 11.816 27.57 27.57v23.63L311.137 634.093V212.677z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$O = [
      _hoisted_2$X
    ];
    function render$n(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1f, _hoisted_3$O);
    }
    const MobileSlashIcon = { render: render$n };
    const _hoisted_1$1e = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$W = /* @__PURE__ */ createBaseVNode("path", {
      d: "M917.333 573.867 829.867 486.4C864 454.4 896 418.133 921.6 377.6c8.533-14.933 4.267-34.133-10.667-44.8-14.933-8.533-34.133-4.267-44.8 10.667C789.333 469.333 657.067 544 509.867 544 364.8 544 230.4 469.333 155.733 345.6c-8.533-14.933-29.866-19.2-44.8-10.667-14.933 8.534-19.2 29.867-10.666 44.8 25.6 40.534 55.466 76.8 91.733 108.8l-85.333 85.334c-12.8 12.8-12.8 32 0 44.8 6.4 6.4 14.933 8.533 23.466 8.533s17.067-2.133 23.467-8.533l91.733-91.734c38.4 25.6 81.067 46.934 125.867 59.734L337.067 716.8c-4.267 17.067 6.4 34.133 23.466 38.4 2.134 0 6.4 2.133 8.534 2.133 14.933 0 27.733-8.533 29.866-23.466L435.2 601.6c25.6 4.267 51.2 6.4 78.933 6.4 27.734 0 55.467-2.133 83.2-6.4L633.6 733.867c4.267 14.933 17.067 23.466 29.867 23.466 2.133 0 6.4 0 8.533-2.133 17.067-4.267 27.733-21.333 23.467-38.4l-34.134-132.267c44.8-12.8 85.334-34.133 123.734-59.733l91.733 91.733c6.4 6.4 14.933 8.534 23.467 8.534s17.066-2.134 23.466-8.534c6.4-10.666 6.4-29.866-6.4-42.666z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$N = [
      _hoisted_2$W
    ];
    function render$m(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1e, _hoisted_3$N);
    }
    const HideIcon = { render: render$m };
    const _hoisted_1$1d = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$V = /* @__PURE__ */ createBaseVNode("path", {
      d: "M935.253 494.933C849.067 294.827 686.933 170.667 512 170.667S174.933 294.827 88.747 494.933a42.667 42.667 0 0 0 0 34.134C174.933 729.173 337.067 853.333 512 853.333s337.067-124.16 423.253-324.266a42.667 42.667 0 0 0 0-34.134zM512 768c-135.253 0-263.253-97.707-337.067-256C248.747 353.707 376.747 256 512 256s263.253 97.707 337.067 256C775.253 670.293 647.253 768 512 768zm0-426.667A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333zm0 256A85.333 85.333 0 1 1 597.333 512 85.333 85.333 0 0 1 512 597.333z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$M = [
      _hoisted_2$V
    ];
    function render$l(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1d, _hoisted_3$M);
    }
    const EyeIcon = { render: render$l };
    const _hoisted_1$1c = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$U = /* @__PURE__ */ createBaseVNode("path", {
      d: "M466.773 259.413A295.68 295.68 0 0 1 512 256c135.68 0 263.253 97.707 337.493 256a649.813 649.813 0 0 1-38.4 69.973 42.667 42.667 0 0 0-6.826 23.467 42.667 42.667 0 0 0 79.36 21.333 672.853 672.853 0 0 0 51.626-98.133 42.667 42.667 0 0 0 0-33.707C849.067 294.827 686.933 170.667 512 170.667a331.52 331.52 0 0 0-59.733 5.12 42.667 42.667 0 1 0 14.506 85.333zM158.293 97.707a42.667 42.667 0 0 0-60.586 60.586l132.266 131.84a623.787 623.787 0 0 0-141.226 204.8 42.667 42.667 0 0 0 0 34.134C174.933 729.173 337.067 853.333 512 853.333a395.093 395.093 0 0 0 215.467-65.706l138.24 138.666a42.667 42.667 0 0 0 60.586 0 42.667 42.667 0 0 0 0-60.586zm271.36 392.106 104.534 104.534A77.227 77.227 0 0 1 512 597.333 85.333 85.333 0 0 1 426.667 512a77.227 77.227 0 0 1 2.986-22.187zM512 768c-135.68 0-263.253-97.707-337.067-256a515.84 515.84 0 0 1 115.2-161.707l75.52 76.374a170.667 170.667 0 0 0 231.68 231.68l67.84 66.986A308.907 308.907 0 0 1 512 768z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$L = [
      _hoisted_2$U
    ];
    function render$k(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1c, _hoisted_3$L);
    }
    const EyeSlashIcon = { render: render$k };
    const _hoisted_1$1b = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$T = /* @__PURE__ */ createBaseVNode("path", {
      d: "M872.1 197.6 684.4 72.5c-5.3-3.5-12.4.3-12.4 6.7V160H384C207.3 160 64 303.3 64 480v64c0 45.9 9.7 89.6 27.1 129 2 4.6 7.6 6.2 11.8 3.5l95.4-63.6c3-2 4.3-5.7 3.2-9.2-6.2-19-9.4-39.1-9.4-59.7v-64c0-51.3 20-99.5 56.2-135.8C284.5 308 332.7 288 384 288h288v81.3c0 6.4 7.1 10.2 12.4 6.7L872 250.9c19.1-12.7 19.1-40.6.1-53.3zM151.2 833.3l187.6 125.1c5.3 3.5 12.4-.3 12.4-6.7v-80.8h288c176.7 0 320-143.3 320-320v-64c0-45.9-9.7-89.6-27.1-129-2-4.6-7.6-6.2-11.8-3.5L825 418c-3 2-4.3 5.7-3.2 9.2 6.2 19 9.4 39.1 9.4 59.7v64c0 51.3-20 99.5-56.2 135.8-36.3 36.3-84.5 56.2-135.8 56.2h-288v-81.3c0-6.4-7.1-10.2-12.4-6.7L151.2 780c-18.9 12.7-18.9 40.6 0 53.3z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$K = [
      _hoisted_2$T
    ];
    function render$j(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1b, _hoisted_3$K);
    }
    const SwitchIcon = { render: render$j };
    const _hoisted_1$1a = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$S = /* @__PURE__ */ createBaseVNode("path", {
      d: "M203.093 451.84a42.667 42.667 0 0 0 11.094-85.333l-75.094-18.774a42.667 42.667 0 1 0-22.186 82.347L192 450.133a33.28 33.28 0 0 0 11.093 1.707zm164.694-238.507a42.667 42.667 0 0 0 42.666 31.574 34.987 34.987 0 0 0 11.094 0 42.667 42.667 0 0 0 29.866-52.054L431.36 117.76a42.667 42.667 0 1 0-82.347 22.187zM573.867 640A42.667 42.667 0 0 0 512 640L362.667 791.893a94.293 94.293 0 0 1-130.56 0 91.733 91.733 0 0 1 0-130.56L384 512a42.667 42.667 0 1 0-60.16-60.16L170.667 600.747a177.92 177.92 0 1 0 252.586 252.586L573.867 702.72a42.667 42.667 0 0 0 0-62.72zM221.013 281.173a42.667 42.667 0 0 0 29.867 12.374 42.667 42.667 0 0 0 30.293-12.374 42.667 42.667 0 0 0 0-60.16l-55.04-55.04a42.667 42.667 0 0 0-60.16 60.16zm686.08 312.747L832 573.867a42.667 42.667 0 1 0-21.333 82.346l75.093 20.054h11.093a42.667 42.667 0 0 0 11.094-85.334zm-250.88 216.747a42.667 42.667 0 0 0-52.48-29.867 42.667 42.667 0 0 0-29.866 52.053l20.053 75.094a42.667 42.667 0 0 0 42.667 31.573 49.067 49.067 0 0 0 11.093 0 42.667 42.667 0 0 0 30.293-52.48zm146.774-66.987a42.667 42.667 0 0 0-60.16 60.16l55.04 55.04a42.667 42.667 0 0 0 60.16 0 42.667 42.667 0 0 0 0-60.16zm101.546-445.013a177.493 177.493 0 0 0-303.786-128L450.133 322.56A42.667 42.667 0 1 0 512 384l149.333-151.893a94.293 94.293 0 0 1 130.56 0 91.733 91.733 0 0 1 0 130.56L640 512a42.667 42.667 0 0 0 0 60.16 42.667 42.667 0 0 0 60.16 0l153.173-148.907a178.773 178.773 0 0 0 51.2-124.586z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$J = [
      _hoisted_2$S
    ];
    function render$i(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$1a, _hoisted_3$J);
    }
    const LinkBrokenIcon = { render: render$i };
    const _hoisted_1$19 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$R = /* @__PURE__ */ createBaseVNode("path", {
      d: "M516.693 656.64 351.147 822.187a107.52 107.52 0 0 1-149.334 0 105.387 105.387 0 0 1 0-149.334L367.36 507.307a42.667 42.667 0 1 0-60.587-60.587L141.227 612.693a191.147 191.147 0 0 0 270.08 270.08L577.28 717.227a42.667 42.667 0 0 0-60.587-60.587zm366.08-515.413a191.573 191.573 0 0 0-270.08 0L446.72 306.773a42.667 42.667 0 1 0 60.587 60.587l165.546-165.547a107.52 107.52 0 0 1 149.334 0 105.387 105.387 0 0 1 0 149.334L656.64 516.693a42.667 42.667 0 0 0 0 60.587 42.667 42.667 0 0 0 60.587 0l165.546-165.973a191.573 191.573 0 0 0 0-270.08zM376.747 647.253a42.667 42.667 0 0 0 30.293 12.374 42.667 42.667 0 0 0 30.293-12.374l209.92-209.92a42.667 42.667 0 1 0-60.586-60.586l-209.92 209.92a42.667 42.667 0 0 0 0 60.586z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$I = [
      _hoisted_2$R
    ];
    function render$h(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$19, _hoisted_3$I);
    }
    const LinkIcon = { render: render$h };
    const _hoisted_1$18 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$Q = /* @__PURE__ */ createBaseVNode("path", {
      d: "M931.882 259.882 764.118 92.118A96 96 0 0 0 696.236 64H160c-53.02 0-96 42.98-96 96v704c0 53.02 42.98 96 96 96h704c53.02 0 96-42.98 96-96V327.764a96 96 0 0 0-28.118-67.882zM512 832c-70.692 0-128-57.308-128-128 0-70.692 57.308-128 128-128s128 57.308 128 128c0 70.692-57.308 128-128 128zm192-609.04V424c0 13.254-10.746 24-24 24H216c-13.254 0-24-10.746-24-24V216c0-13.254 10.746-24 24-24h457.04c6.366 0 12.47 2.528 16.97 7.03l6.96 6.96a23.992 23.992 0 0 1 7.03 16.97z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$H = [
      _hoisted_2$Q
    ];
    function render$g(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$18, _hoisted_3$H);
    }
    const SaveIcon = { render: render$g };
    const _hoisted_1$17 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$P = /* @__PURE__ */ createBaseVNode("path", {
      d: "M832.285 66.152H161.683c-35.29 0-64 28.71-64 64v766.142c0 35.29 28.71 64 64 64h670.603c35.29 0 64-28.71 64-64V130.152c-.001-35.29-28.711-64-64.001-64zM469.486 837.38c0-23.48 19.034-42.514 42.514-42.514s42.514 19.034 42.514 42.514S535.48 879.895 512 879.895s-42.514-19.035-42.514-42.515zM161.683 720.889v-590.68a.446.446 0 0 1 .058-.057h670.545v590.737H161.683z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$G = [
      _hoisted_2$P
    ];
    function render$f(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$17, _hoisted_3$G);
    }
    const TabletIcon = { render: render$f };
    const _hoisted_1$16 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$O = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512.064 376.576c-74.752 0-135.424 60.608-135.424 135.424s60.672 135.36 135.424 135.36 135.36-60.608 135.36-135.36-60.544-135.424-135.36-135.424zM512 32C246.784 32 32 246.848 32 512s214.784 480 480 480c265.152 0 480-214.848 480-480S777.152 32 512 32zm324.992 534.208h-32.576c-14.784 0-30.656 11.648-35.136 25.792l-18.624 45.312c-6.976 13.184-4.16 32.64 6.336 43.072l23.104 22.976c10.496 10.624 10.496 27.904 0 38.4l-38.4 38.336c-10.56 10.56-27.776 10.56-38.4 0l-22.912-23.04c-10.496-10.496-29.952-13.376-43.072-6.272L592 769.344c-14.144 4.48-25.792 20.224-25.792 35.136v32.448c0 14.848-12.224 27.072-27.072 27.072h-54.208c-14.912 0-27.136-12.16-27.136-27.072V804.48c0-14.848-11.584-30.656-25.856-35.136L386.56 750.72c-13.12-7.104-32.448-4.224-42.88 6.272l-23.104 23.04c-10.496 10.56-27.776 10.56-38.272 0l-38.336-38.272c-10.496-10.496-10.496-27.776 0-38.4l23.04-22.976c10.56-10.432 13.376-29.888 6.4-43.072L254.656 592c-4.352-14.208-20.16-25.792-35.072-25.856h-32.448c-14.976 0-27.136-12.16-27.136-27.072v-54.144c0-14.912 12.16-27.072 27.136-27.072l32.448.064c14.912 0 30.72-11.648 35.072-25.856l18.688-45.376c7.04-13.12 4.16-32.448-6.4-43.008l-23.04-23.04c-10.496-10.56-10.496-27.776 0-38.272l38.336-38.336c10.496-10.496 27.776-10.496 38.272 0l23.104 23.04c10.56 10.56 29.824 13.376 42.944 6.4L432 254.656c14.272-4.352 25.856-20.16 25.856-35.136v-32.448C457.792 172.16 470.016 160 484.928 160h54.144c14.848 0 27.072 12.16 27.072 27.072v32.448c0 14.912 11.712 30.72 25.792 35.136l45.312 18.688c13.12 7.04 32.576 4.16 43.072-6.4l22.976-23.04c10.624-10.496 27.84-10.496 38.4 0l38.4 38.336c10.496 10.496 10.496 27.776 0 38.336l-23.104 22.976c-10.496 10.56-13.312 29.888-6.336 43.008l18.624 45.312c4.48 14.272 20.224 25.856 35.136 25.856h32.576c14.784 0 27.008 12.16 27.008 27.072v54.208c0 14.976-12.16 27.2-27.008 27.2z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$F = [
      _hoisted_2$O
    ];
    function render$e(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$16, _hoisted_3$F);
    }
    const ProjectSettingIcon = { render: render$e };
    const _hoisted_1$15 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$N = /* @__PURE__ */ createBaseVNode("path", {
      d: "M884.364 320.35a29.09 29.09 0 0 1-3.724-58.183l69.818-9.192a29.09 29.09 0 1 1 7.564 58.181l-69.818 9.193zm-30.371-145.805a29.09 29.09 0 0 1-20.597-49.687l55.739-55.04a29.09 29.09 0 0 1 41.192 41.193l-55.738 55.738a28.975 28.975 0 0 1-20.596 7.796zM708.77 144.407h-3.84a29.09 29.09 0 0 1-25.018-32.698l9.192-69.818a29.09 29.09 0 0 1 58.182 7.564l-9.192 69.818a29.09 29.09 0 0 1-29.324 25.134zM731.113 995.724H246.342A122.298 122.298 0 0 1 124.16 873.542V270.895a122.298 122.298 0 0 1 122.182-122.182h333.963l272.99 227.49v497.339a122.298 122.298 0 0 1-122.182 122.182zm-484.771-788.83a64.116 64.116 0 0 0-64 64v602.764a64.116 64.116 0 0 0 64 64h484.77a64.116 64.116 0 0 0 64-64V403.433L559.245 206.895z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$E = /* @__PURE__ */ createBaseVNode("path", {
      d: "M797.09 442.182H657.456A122.298 122.298 0 0 1 535.273 320V203.636a29.09 29.09 0 0 1 58.182 0V320a64.116 64.116 0 0 0 64 64H797.09a29.09 29.09 0 0 1 0 58.182z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$l = [
      _hoisted_2$N,
      _hoisted_3$E
    ];
    function render$d(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$15, _hoisted_4$l);
    }
    const EmptyIcon$1 = { render: render$d };
    const _hoisted_1$14 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "128",
      height: "128"
    };
    const _hoisted_2$M = /* @__PURE__ */ createBaseVNode("path", {
      d: "m747.8 322-195-10.2-.7 1.7-14 30.4-2.3 5 21.1 60.6-39.5 76.7 13.7 64.3 60.2-32.8c4.8-2.6 10.7-1 13.5 3.6l59.7 97.9c1.9 3.2 1.9 7.3 0 10.5s-5.5 5.1-9.2 4.9L515.9 627l-13.3 39.6-1.3 3.8 10.5 28.8 215.7 11.3c20.2 1.1 31-10.1 32.2-33.5l16.7-318.3c1.1-23.4-8.4-35.6-28.6-36.7zm-50.3 138.4c-1 19.9-18 35.2-37.9 34.2s-35.2-18-34.1-38c1-19.9 18-35.2 37.9-34.2 19.9 1.1 35.1 18.1 34.1 38zM483.7 668.6l9.1-40.7-123.1 6.5c-3.4.2-6.7-1.3-8.7-4.1-2-2.7-2.6-6.3-1.4-9.5l59.3-164.3c1.3-3.5 4.4-6 8.1-6.6 3.7-.5 7.4 1 9.6 4.1l58.2 79.5-15.7-48.1 30.6-78.6-27-57.4 1.8-5.3 11.3-33.4L277.4 322c-20.2 1.1-29.7 13.3-28.5 36.7L265.5 677c1.2 23.4 12 34.5 32.2 33.5L495 700.1l-12.6-25.8 1.3-5.7z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$D = [
      _hoisted_2$M
    ];
    function render$c(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$14, _hoisted_3$D);
    }
    const ImgErrorIcon = { render: render$c };
    const _hoisted_1$13 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$L = /* @__PURE__ */ createBaseVNode("path", {
      d: "M554.667 128a298.667 298.667 0 0 0 0 597.333 213.333 213.333 0 0 0 0-426.666 128 128 0 0 0 0 256 42.667 42.667 0 0 0 0-85.334 42.667 42.667 0 0 1 0-85.333 128 128 0 0 1 0 256 213.333 213.333 0 0 1 0-426.667 298.667 298.667 0 0 1 0 597.334 384 384 0 0 1-384-384 42.667 42.667 0 0 0-85.334 0A469.333 469.333 0 0 0 554.667 896a384 384 0 0 0 0-768z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$C = [
      _hoisted_2$L
    ];
    function render$b(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$13, _hoisted_3$C);
    }
    const SpinIcon = { render: render$b };
    const _hoisted_1$12 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$K = /* @__PURE__ */ createBaseVNode("path", {
      d: "M819.2 153.6H204.8c-84.48 0-153.6 71.68-153.6 158.72v399.36c0 87.04 69.12 158.72 153.6 158.72h614.4c84.48 0 153.6-71.68 153.6-158.72V312.32c0-87.04-69.12-158.72-153.6-158.72zm51.2 558.08c0 28.16-23.04 53.76-51.2 53.76H204.8c-28.16 0-51.2-23.04-51.2-53.76V312.32c0-28.16 23.04-53.76 51.2-53.76h614.4c28.16 0 51.2 23.04 51.2 53.76v399.36z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$B = /* @__PURE__ */ createBaseVNode("path", {
      d: "M704 614.4H320c-20.48 0-38.4 23.04-38.4 51.2s17.92 51.2 38.4 51.2h384c20.48 0 38.4-23.04 38.4-51.2s-17.92-51.2-38.4-51.2zM371.2 512c0-28.16-23.04-51.2-51.2-51.2h-64c-28.16 0-51.2 23.04-51.2 51.2s23.04 51.2 51.2 51.2h64c28.16 0 51.2-23.04 51.2-51.2zM256 409.6h64c28.16 0 51.2-23.04 51.2-51.2s-23.04-51.2-51.2-51.2h-64c-28.16 0-51.2 23.04-51.2 51.2s23.04 51.2 51.2 51.2zm217.6 153.6h76.8c28.16 0 51.2-23.04 51.2-51.2s-23.04-51.2-51.2-51.2h-76.8c-28.16 0-51.2 23.04-51.2 51.2s23.04 51.2 51.2 51.2zm0-153.6h76.8c28.16 0 51.2-23.04 51.2-51.2s-23.04-51.2-51.2-51.2h-76.8c-28.16 0-51.2 23.04-51.2 51.2s23.04 51.2 51.2 51.2zM768 460.8h-64c-28.16 0-51.2 23.04-51.2 51.2s23.04 51.2 51.2 51.2h64c28.16 0 51.2-23.04 51.2-51.2s-23.04-51.2-51.2-51.2zm0-153.6h-64c-28.16 0-51.2 23.04-51.2 51.2s23.04 51.2 51.2 51.2h64c28.16 0 51.2-23.04 51.2-51.2s-23.04-51.2-51.2-51.2z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_4$k = [
      _hoisted_2$K,
      _hoisted_3$B
    ];
    function render$a(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$12, _hoisted_4$k);
    }
    const KeyboardIcon = { render: render$a };
    const _hoisted_1$11 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$J = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 1024A512 512 0 1 1 512 0a512 512 0 0 1 0 1024zm3.008-92.992a416 416 0 1 0 0-832 416 416 0 0 0 0 832zM457.792 684.8h130.56v128.128h-130.56V684.8zM320 397.44c.576-29.952 5.696-57.408 15.36-82.368 9.728-24.96 23.296-46.592 40.832-64.896a183.68 183.68 0 0 1 63.168-42.88A213.76 213.76 0 0 1 522.24 192c39.36 0 72.256 5.376 98.56 16.192 26.368 10.88 47.616 24.32 63.68 40.384s27.584 33.408 34.56 52.032c6.912 18.56 10.368 35.84 10.368 51.968 0 26.624-3.456 48.512-10.432 65.728a162.048 162.048 0 0 1-59.904 75.328c-12.48 8.576-24.256 17.152-35.328 25.792a165.44 165.44 0 0 0-29.504 29.504c-8.64 11.072-14.08 24.96-16.256 41.6v31.616H465.6v-37.44c1.664-23.872 6.208-43.84 13.696-59.904 7.552-16.064 16.256-29.824 26.24-41.152 9.984-11.392 20.48-21.248 31.616-29.568 11.072-8.32 21.376-16.64 30.784-24.96 9.408-8.32 17.024-17.472 22.848-27.456 5.888-9.984 8.512-22.464 7.936-37.44 0-25.536-6.208-44.352-18.752-56.576-12.48-12.16-29.76-18.304-51.968-18.304-14.976 0-27.84 2.88-38.656 8.704a77.184 77.184 0 0 0-26.688 23.296 101.12 101.12 0 0 0-15.36 34.176 169.408 169.408 0 0 0-4.992 41.984H320z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$A = [
      _hoisted_2$J
    ];
    function render$9(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$11, _hoisted_3$A);
    }
    const QuestionCircleIcon = { render: render$9 };
    const _hoisted_1$10 = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$I = /* @__PURE__ */ createBaseVNode("path", {
      d: "M726.016 406.528c31.744 0 93.184-25.6 93.184-108.544s-59.392-87.04-77.824-87.04c-36.864 0-72.704 26.624-104.448 80.896-31.744 56.32-67.584 117.76-67.584 117.76h-1.024c-8.192-38.912-14.336-71.68-17.408-86.016-6.144-33.792-46.08-108.544-128-108.544S266.24 262.144 266.24 262.144c-14.336 9.216-23.552 24.576-23.552 41.984 0 27.648 22.528 50.176 50.176 50.176 8.192 0 15.36-2.048 21.504-5.12 0 0 62.464-34.816 75.776 0 4.096 10.24 7.168 22.528 11.264 34.816 16.384 53.248 30.72 116.736 43.008 174.08l-53.248 77.824s-60.416-21.504-92.16-21.504S204.8 640 204.8 722.944s59.392 87.04 77.824 87.04c36.864 0 72.704-26.624 104.448-80.896 31.744-56.32 67.584-117.76 67.584-117.76 10.24 51.2 19.456 92.16 24.576 108.544 20.48 58.368 67.584 93.184 130.048 93.184 0 0 64.512 0 140.288-43.008 18.432-7.168 31.744-25.6 31.744-46.08 0-27.648-22.528-50.176-50.176-50.176-8.192 0-15.36 2.048-21.504 5.12 0 0-54.272 30.72-72.704 6.144-13.312-25.6-24.576-58.368-32.768-99.328-8.192-36.864-17.408-79.872-25.6-121.856l54.272-78.848c1.024 0 61.44 21.504 93.184 21.504z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$z = [
      _hoisted_2$I
    ];
    function render$8(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$10, _hoisted_3$z);
    }
    const VariableIcon = { render: render$8 };
    const _hoisted_1$$ = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$H = /* @__PURE__ */ createBaseVNode("path", {
      d: "M745.92 605.12a251.52 251.52 0 0 1-412.16 85.12c-4.8-4.8-8.96-10.24-13.44-15.36 8.32 0 16.96 2.56 25.6 4.8A70.08 70.08 0 1 0 380.16 544a533.44 533.44 0 0 0-232.64 0A70.08 70.08 0 0 0 96 594.24a533.44 533.44 0 0 0 0 232.64 70.08 70.08 0 1 0 136.32-33.92s-2.56-11.84-5.12-29.44c5.12 5.76 10.24 11.84 15.68 17.28a379.2 379.2 0 0 0 640-184.64 566.72 566.72 0 0 1-136.96 8.96zm182.08-408a70.08 70.08 0 1 0-136.32 33.92s2.56 11.84 5.12 29.44c-5.12-5.76-10.24-11.84-15.68-17.28a379.2 379.2 0 0 0-640 184.64 566.4 566.4 0 0 1 136-9.28 251.52 251.52 0 0 1 412.16-85.12c4.8 4.8 8.96 10.24 13.44 15.36-8.32 0-16.96-2.56-25.6-4.8a70.08 70.08 0 1 0-33.28 136 533.44 533.44 0 0 0 232.64 0 70.08 70.08 0 0 0 51.2-51.2 533.44 533.44 0 0 0 .32-231.68z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$y = [
      _hoisted_2$H
    ];
    function render$7(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$$, _hoisted_3$y);
    }
    const SyncIcon = { render: render$7 };
    const _hoisted_1$_ = {
      class: "icon",
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32"
    };
    const _hoisted_2$G = /* @__PURE__ */ createBaseVNode("path", {
      d: "M512 1024C229.233 1024 0 794.767 0 512S229.233 0 512 0s512 229.233 512 512-229.233 512-512 512zm190.423-563.59L451.779 296.347c-66.407-44.585-62.659 0-62.659 0v420.413c0 62.136 62.659 10.25 62.659 10.25l250.644-164.065c78.326-52.654 0-102.533 0-102.533z",
      fill: "currentColor"
    }, null, -1);
    const _hoisted_3$x = [
      _hoisted_2$G
    ];
    function render$6(_ctx, _cache) {
      return openBlock(), createElementBlock("svg", _hoisted_1$_, _hoisted_3$x);
    }
    const StartIcon = { render: render$6 };
    const _sfc_main$12 = /* @__PURE__ */ defineComponent({
      __name: "Icon",
      props: {
        name: null,
        type: { default: "circle" },
        color: null,
        size: { default: 26 },
        active: { type: Boolean },
        loading: { type: Boolean }
      },
      setup(__props) {
        const iconMap = {
          logo: LogoIcon,
          add: AddIcon,
          focus: FocusIcon,
          "device-sm": DeviceSmIcon,
          "device-md": DeviceMdIcon,
          "device-lg": DeviceLgIcon,
          check: CheckIcon,
          down: DownIcon,
          advanced: AdvancedIcon,
          more: MoreIcon,
          delete: DeleteIcon,
          "caret-down": CaretDownIcon,
          line: LineIcon,
          dashed: DashedIcon,
          dotted: DottedIcon,
          "line-double": LineDoubleIcon,
          layout: LayoutIcon,
          size: SizeIcon,
          spacing: SpacingIcon,
          border: BorderIcon,
          font: FontIcon,
          container: ContainerIcon,
          copy: CopyIcon,
          basic: BasicIcon,
          question: QuestionIcon,
          background: BackgroundIcon,
          italic: ItalicIcon,
          bold: BoldIcon,
          underline: UnderlineIcon,
          "line-through": LineThroughIcon,
          "align-left": AlignLeftIcon,
          "align-center": AlignCenterIcon,
          "align-right": AlignRightIcon,
          "align-justify": AlignJustifyIcon,
          "top-circle": TopCircleIcon,
          absolute: AbsoluteIcon,
          warning: WarningIcon,
          lock: LockIcon,
          unlock: UnlockIcon,
          drag: DragIcon,
          edit: EditIcon,
          preview: PreviewIcon,
          event: EventIcon,
          animation: AnimationIcon,
          close: CloseIcon,
          effect: EffectIcon,
          plus: PlusIcon,
          separate: SeparateIcon,
          color: ColorIcon,
          image: ImageIcon,
          text: TextIcon,
          block: BlockIcon,
          circle: CircleIcon,
          symbol: SymbolIcon,
          layers: LayersIcon,
          "layers-slash": LayersSlashIcon,
          module: ModuleIcon,
          redo: RedoIcon,
          upload: UploadIcon,
          mobile: MobileIcon,
          "mobile-slash": MobileSlashIcon,
          hide: HideIcon,
          eye: EyeIcon,
          "eye-slash": EyeSlashIcon,
          switch: SwitchIcon,
          "link-broken": LinkBrokenIcon,
          link: LinkIcon,
          save: SaveIcon,
          tablet: TabletIcon,
          "project-setting": ProjectSettingIcon,
          empty: EmptyIcon$1,
          "img-error": ImgErrorIcon,
          spin: SpinIcon,
          keyboard: KeyboardIcon,
          "question-circle": QuestionCircleIcon,
          variable: VariableIcon,
          sync: SyncIcon,
          start: StartIcon
        };
        const style2 = ref({
          width: __props.size + "px",
          height: __props.size + "px"
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["icon", `icon-type-${__props.type}`, { active: __props.active, [`icon-color-${__props.color}`]: __props.color, loading: __props.loading }])
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(unref$1(iconMap)[__props.name]), {
              class: normalizeClass(["icon-inner", { active: __props.active }]),
              style: normalizeStyle(style2.value)
            }, null, 8, ["class", "style"]))
          ], 2);
        };
      }
    });
    const Icon_vue_vue_type_style_index_0_scoped_c1ad2f81_lang = "";
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const Icon$1 = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["__scopeId", "data-v-c1ad2f81"]]);
    const _hoisted_1$Z = {
      key: 1,
      class: "global-loading"
    };
    const _hoisted_2$F = { class: "global-loading-text" };
    const _sfc_main$11 = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        let isReady = ref(false);
        const route = useRoute();
        const userStore = useUserStore();
        const { fetchUserInfo, clearUserInfo } = userStore;
        let showGlobalLoading = ref(false);
        let globalLoadingText = ref("");
        onBeforeMount(async () => {
          var _a, _b;
          const { token } = await persistToken();
          isReady.value = true;
          if (["zh", "en"].includes((_a = route.query) == null ? void 0 : _a.lang)) {
            localStorage.setItem("lang", (_b = route.query) == null ? void 0 : _b.lang);
          }
          if (token) {
            try {
              fetchUserInfo();
            } catch (e) {
              clearUserInfo();
            }
          }
        });
        pinia.use(({ store }) => {
          store.$onAction(({ onError }) => {
            onError((error) => {
              var _a;
              AlertError(((_a = error == null ? void 0 : error.body) == null ? void 0 : _a.message) || (error == null ? void 0 : error.message) || (error == null ? void 0 : error.msg) || $t("unknownError"));
            });
          });
        });
        provide("globalLoading", {
          setGlobalLoading: (text) => {
            showGlobalLoading.value = true;
            globalLoadingText.value = text;
            return () => {
              showGlobalLoading.value = false;
              globalLoadingText.value = "";
            };
          }
        });
        return (_ctx, _cache) => {
          const _component_router_view = resolveComponent("router-view");
          return openBlock(), createElementBlock(Fragment, null, [
            isReady.value ? (openBlock(), createBlock(_component_router_view, { key: 0 })) : createCommentVNode("", true),
            showGlobalLoading.value ? (openBlock(), createElementBlock("div", _hoisted_1$Z, [
              createVNode(Icon$1, {
                name: "spin",
                size: 66,
                loading: ""
              }),
              createBaseVNode("div", _hoisted_2$F, toDisplayString(globalLoadingText.value), 1)
            ])) : createCommentVNode("", true)
          ], 64);
        };
      }
    });
    const App_vue_vue_type_style_index_0_lang = "";
    const App_vue_vue_type_style_index_1_scoped_b9e0d9cd_lang = "";
    const App = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["__scopeId", "data-v-b9e0d9cd"]]);
    var DataType = /* @__PURE__ */ ((DataType2) => {
      DataType2["Page"] = "page";
      DataType2["Resume"] = "resume";
      return DataType2;
    })(DataType || {});
    const ComponentPropsGroup = {
      Block: [
        "common",
        "layout",
        "size",
        "spacing",
        "border",
        "background",
        "container",
        "position",
        "event",
        "effect",
        "animation"
      ],
      Text: [
        "common",
        "basic",
        "font",
        "spacing",
        "border",
        "background",
        "container",
        "position",
        "event",
        "effect",
        "animation"
      ],
      Image: [
        "common",
        "basic",
        "size",
        "spacing",
        "border",
        "container",
        "position",
        "event",
        "effect",
        "animation"
      ],
      Icon: ["common", "basic", "spacing", "border", "event", "effect"]
    };
    var DataStatus = /* @__PURE__ */ ((DataStatus2) => {
      DataStatus2[DataStatus2["Normal"] = 1] = "Normal";
      DataStatus2[DataStatus2["Hidden"] = 2] = "Hidden";
      return DataStatus2;
    })(DataStatus || {});
    const isSomeBasicType = (name, compare, basic) => {
      return name === compare && !!basic;
    };
    const DefaultIconStyleLink = "https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css";
    const imgErrorFallback = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAC+9JREFUeF7tXX2MXFUVP+fNttROS0VCtAqIYviQxARBCEgMosYPCIIfRD40VhFBCNp23rm7beJ2NbLz7tvtliARrQL+gUAqfkBAIioSxK8CgUSFqPiBioSgCHRq6e57x5xxZjPdnenc97FzJ+/dm0xmZt85597fOb935n69uwiulNoDWGr0Djw4ApScBI4AjgAl90DJ4bsM4AhQcg+UHL7LAI4AJfdAyeG7DOAIUHIPlBy+ywCOACX3QMnhuwzgCFByD5QcvssAjgAl90DJ4bsM4AhQcg+UHL7LAI4AJfdAyeG7DOAIUHIPlBy+ywCOACX3QMnhuwzgCFByD5QcvssAjgAl90DJ4bsM4AhQcg+UHL7LAI4AJfdAyeG7DOAIUHIPlBy+ywCOACX3QMnhuwzgCFAOD4yPjy8/4IAD1iDiGgCQ1/NjY2N/LAf63iiHOgMwM27btm1NFEVrmLn5kuAh4oHtzwu+HwgA8hK5zvdlnS5g5juVUmd1c8vk5OQRlUplOyI2mHk3ADTk1f7seV7zexzHuyuVSvNdXp7n7WbmxsjIyO6XXnpp99q1axvr1q3bM+wEs06AqampNzLzZcz8BgA4WAIrAW4FcOVSODCO40tHR0e/2s221voGAPh4HvUiIneSCACEUG1SPcrMtyilfplHXWltWCXAzMzM2tnZ2XsA4Li0AJLqIeKuvXv3HrV58+Z/LtRt3f1/Tmozrby0JY7jC5VSt6e1kVXPKgGCINiCiONZQSTUv5mILuhx908CwGhCe1nFHyCi07IaSatvlQBhGP6amd+StvFp9Jj5XKXU93oQgNPYzKpDRNbiYK1icZrWehcAVLM6MKH+jUS0rptOEAS3IeIHEtrLLO4IkNmFyQxEUfS6sbGxvyzUCsPwAma+KZm1zNK7iWjQN8F8o61mgCAInkLEtZldmNxA1ywwPj6+olqt/je5uUwazxDRKzNZyKBslQBa68cB4OgM7U+t2isLaK3vBID3pTacXPEJIpIhsJVimwC/AoCTrCAH6JoFgiD4JCJ+fYBteoSIjh9gfftUZZsAMgfwTlvgu2WBmZmZl8/Ozj43wDbdT0RvG2B9w0MAW73uDg90zQJa6x8DwBkDCspdRHTmgOpaVI3VDBCG4fXM3HVINiCHjBFRfWFdeU4HG+C4lYg+YiC3JCJWCaC13gYAn10SZGZG1xLR052iKaeDnweAJwFgNQAcYVb1/6WY+RtKqYuT6OQpa5sAEwDw+TwBJbB1NxG9N+vdz8yfVkp9rW0nDMOTJaim6xvMvE0ptT5Bu3MVtUqAIAg2IuJUrogMjcVxfP7o6OgtWe5+Zl6vlJIstqhorR8FgDf1aw4zf1EpZesmsPtPo8Iw/BQzz989/ZyV4/U9RPSyjHf/TUR0Ua82TU1NnRDH8YP92szMpJQK+8kt1XWrGSAMw/OY+dacwf02iqIrKpWK9C3O6WH7OiK6LMvdDwDriOjG/bVda/1XADh8fzKyF0IpdV3OPjA2Z5UAWuv3AMAPjFvbXzCSmUUieiIIAumQPYyIi2bZmPmUhRsxkvb897eq2G6m1vpeADi9DwEuUkoNev1hvklWCVCv10/1PO+B/nE1lvguEc2v5oVheAYzy5i+szxORMdmvPtFXRGR7tWyq6666pCRkZFn+rUcEc/xff/7/eSW6rpVAmzduvW4ubm53+QIblFaDsNQMXPnWH/R2D/p3S/tZeaHlFIn9mp7EARXIOI1/bAh4jt83/9JP7mlum6VANPT04dFUSTj5zzK83Nzc0du2rTpXwuNaa2/DQAfbP19n7F/ynF/0xQiTvq+v2lhfa0O4M8AYEU/YJ7nnVSr1Xb2k1uq61YJUK/X13ie9588wDHzDUqpT3SzNT09fVQURbLuIB2y04ho/mdHa/0qAFi0PzBBm+T3+4Eoih6rVCqvB4CTAeASU33P846t1WqyKmqlWCWAINZa57INq1+nTGt9PgB8S6okItXp7TAMn2Tmw2xEYGRk5NANGzb8w0bdzSxmq+J2vVprmUaVbeBZyt937tx5xI4dO2QU0LNorWXS6SwiOqZTSGv9HQA4N0sD0uquWLFizZVXXvlCWv2sesNAgL8BwKEZgcwQ0YZ+NmRoiIi3e5734Vqt9mxbPggChYiLFoU67D2NiPcw80f71ZH0eqPRqExMTMRJ9fKSHwYCyCgg03MBiPh23/d/auKUycnJ0+W3moiu78hCbwaAh7roy/awa+I4vnZ0dPRJrbX0MWSeP6/SIKJVeRlLY2cYCPBzADglTeNbOovG9f1syRqEUmp6wc/Awr7IVzzP+3KtVvtdp1wYhrcxc147h58mIht7IuchWSdAEAR3I+K7+wVtP9fHiegLGfSbqlprCbRMEN0k43ff92W72qISBMFJiHg/ACzPWicA/IGIjsrBTmoT1gkQhuGtzHxeagQAxxPRI0n1ZWi4cePG37f1giC42vO8O3zf/1E/W1rrvJaxHyaiE/rVt5TXrRNAa70dANJuiHiQiAb6ZJEEY8uWLStXrlwpWUD6DlnKfUS037WCLMZNdK0TIAiCaUTs24PvBgYRN/q+v9UEaN4y9Xr9PM/zMq1k7u8x9bzb28uedQJorWUzhKTUxKXX3v7EhlIqaK2/CQAfS6ku6wnyeLhMUFkr1gkQhuHnmHkmhQfuJaJB7dzt2jw52yCOY/kpeEWK9gsBtiuljKeN09TRT8c6AdKOrRHxEt/3pf9gtWitCQCCNI1g5q1KqY1pdPPSGQYCyCqdrNYlKsuWLTto/fr1uSwkJaq4i3AYhvcxc+KHO5h5Qim1JWv9WfStEyAIgnch4g8TgriDiM5OqLNk4lpreZZQnilMVJi5tnBCKpGBHIStE6C1jTrpOTkXENHNOeDPzUQYhtcy82eSGETES33f73pWURI7WWStE2BqauqYOI4fSwLC5oEKvdpZr9cP9zxPNoEaF0S80Pd9WaK2VqwTIAiCVyNiovVwRDzV9/1fdPOarPgtX758VRzHq5l59ezs7OpKpSILLs3vrad3Vrd/e1vnFMlJJQ3P83ZFUSRHwslxbw05Km5ubq55qlccx409e/Y0JiYm9vaKVtK9DYh4tu/7d1iL/jDsBxgfH19VrVZfTOEEGX7NB7T1edFe/x52zySiu+Sa1lqWhQ9OUL/sOZCzApukaZ8hKKRMYKMpmmQVM6ltU3nrGaAVhDkAqJg2Oquc53mHyH4ArfVbAUD27lkpnuedWKvVui1DD6w9w0KAfwPAQQNC/SwRHdIiXqaZvKztrVQqR3cuSGW1l0Z/WAggBza9Ng2AFDrzz+NrrWcBYCSFjVxUmPk1SqmncjGW0siwEMDoQcqUGPdRa0++tHYGyZM71gozH6iUStP/ya3NQ0GAIAjuR8SBnJbJzBcrpZrbupL22nPzesvQMAxnh4IAaZ7MyRCM54iouXhj4USwzmb/iYiOzIAjF9WhIMCgzwxm5lGlVBAEwYcQcUcunkxuZAcRZdkJlbzGLhpDQYCc07FM4Mg++xfjOH5RTuRm5l3y3hqzNz8T0eZWvV9i5lWIKJNF1c7PACB/b/5NPgPAPv93IEsEhiH9S/uHhgDSGMkE8ng3IsowTTpHzUC2XxJYCap8bwe0UqnI8e8Nea9Wq7suv/xymZzJ5WmjhQGWrWDVarVJlCiKVrVmGKtxHK/yPE9mH5vX5HOLNFUhVvtzayPpC0T0/izkyVN3qAiQJzBny8wDjgBmfiqslCNAYUNrBswRwMxPhZVyBChsaM2AOQKY+amwUo4AhQ2tGTBHADM/FVbKEaCwoTUD5ghg5qfCSjkCFDa0ZsAcAcz8VFgpR4DChtYMmCOAmZ8KK+UIUNjQmgFzBDDzU2GlHAEKG1ozYI4AZn4qrJQjQGFDawbMEcDMT4WVcgQobGjNgDkCmPmpsFKOAIUNrRkwRwAzPxVWyhGgsKE1A+YIYOanwko5AhQ2tGbAHAHM/FRYKUeAwobWDJgjgJmfCivlCFDY0JoBcwQw81NhpRwBChtaM2COAGZ+KqyUI0BhQ2sGzBHAzE+FlXIEKGxozYA5Apj5qbBSjgCFDa0ZsP8B5U78rprm2nIAAAAASUVORK5CYII=";
    const DefaultColor = "#333333";
    const getUniqueName = (name) => `_name_${name}_`;
    const getTagClassName = (tag) => `_tag_${tag}_`;
    const getContext = () => inject("editContext");
    const getIsEditMode = () => {
      var _a;
      return !!((_a = inject("editContext")) == null ? void 0 : _a.isEditMode);
    };
    const getSetLoading = () => {
      var _a;
      return (_a = inject("globalLoading")) == null ? void 0 : _a.setGlobalLoading;
    };
    const getColorVarStylesheet = (colorVars) => {
      let stylesheet = ``;
      colorVars.forEach(({ name, color }) => {
        if (!name || name.length <= 1)
          return;
        stylesheet += `--${name.slice(1)}: ${color};`;
      });
      return `
    :root {${stylesheet}}
  `.trim();
    };
    const getFontStylesheet = (font, wrapper) => {
      let stylesheet = ``;
      if (font.fontFamily) {
        stylesheet += `${wrapper} { font-family: ${font.fontFamily}; }`;
      }
      if (font.fontSize) {
        stylesheet += `${wrapper} { font-size: ${font.fontSize}px; }`;
      }
      if (font.mediaFontSize && Object.keys(font.mediaFontSize).length > 0) {
        Object.entries(font.mediaFontSize).forEach(([width, size2]) => {
          stylesheet += `@media screen and (min-width: ${width}px) { ${wrapper} { font-size: ${size2}px; } }`;
        });
      }
      if (font.customFontFace) {
        font.customFontFace.forEach((item) => {
          if (typeof item === "object") {
            if (!item.fontFamily || !item.url)
              return;
            stylesheet += `
          @font-face {
            font-family: ${item.fontFamily};
            src: url(${item.url}) format('${item.url.split(".").pop()}');
            font-weight: ${item.fontWeight};
            font-style: ${item.fontStyle};
          }
        `.trim();
          } else if (item) {
            stylesheet = `
          @import url('${item}');
        `.trim() + stylesheet;
          }
        });
      }
      return stylesheet;
    };
    const variableColorSymbol = "$";
    let dynamicAnimationStyles$1 = null;
    const useColorVars = (colorVars) => {
      if (!dynamicAnimationStyles$1) {
        dynamicAnimationStyles$1 = document.createElement("style");
        document.head.appendChild(dynamicAnimationStyles$1);
      }
      let stylesheet = ``;
      colorVars.forEach(({ name, color }) => {
        if (!name || name.length <= 1)
          return;
        stylesheet += `--${name.slice(1)}: ${color};`;
      });
      dynamicAnimationStyles$1.innerHTML = getColorVarStylesheet(colorVars);
    };
    const getColor = (color) => {
      if ((color == null ? void 0 : color[0]) === "$") {
        return `var(--${color.slice(1)})`;
      }
      return color;
    };
    const effectName2PropertyMap = {
      color: "color",
      fontSize: "font-size",
      borderColor: "border-color",
      backgroundColor: "background-color",
      opacity: "opacity",
      hide: "display",
      blur: "filter"
    };
    const covertValue = (name, value) => {
      if (name === "blur") {
        return `blur(${value}px)`;
      }
      return value;
    };
    const useEffect = (propsRef) => {
      let dynamicAnimationStyles2 = ref(null);
      let removeListenerList = ref([]);
      const effect2 = computed(() => propsRef.effect);
      watch(() => effect2.value, () => {
        var _a, _b;
        if (!((_b = (_a = effect2.value) == null ? void 0 : _a.effectList) == null ? void 0 : _b.length)) {
          if (dynamicAnimationStyles2.value)
            dynamicAnimationStyles2.value.innerHTML = "";
          return;
        }
        const uName = getUniqueName(propsRef.componentName);
        if (!dynamicAnimationStyles2.value) {
          dynamicAnimationStyles2.value = document.createElement("style");
          document.head.appendChild(dynamicAnimationStyles2.value);
          removeListenerList.value.push(() => document.head.removeChild(dynamicAnimationStyles2.value));
        }
        const effectList = effect2.value.effectList;
        let styles = [];
        effectList.forEach((item) => {
          if (!Object.keys(item == null ? void 0 : item.styles).length)
            return;
          Object.entries(item == null ? void 0 : item.styles).forEach(([key, val]) => {
            let value = getColor(val);
            if (item.name === "hide") {
              if (value)
                value = "none";
              else
                value = "flex";
            }
            if ((item == null ? void 0 : item.targetType) === "self") {
              styles[key === "hover" ? "unshift" : "push"](`#${uName}:${key} { ${effectName2PropertyMap[item.name]}: ${covertValue(item.name, value)}!important; }`);
            }
            if ((item == null ? void 0 : item.targetType) === "name") {
              styles[key === "hover" ? "unshift" : "push"](`.${uName}:${key} .${getUniqueName(item.target)} { ${effectName2PropertyMap[item.name]}: ${covertValue(item.name, value)}!important; }`);
            }
            if ((item == null ? void 0 : item.targetType) === "tag") {
              styles[key === "hover" ? "unshift" : "push"](`.${uName}:${key} .${getTagClassName(item.target)} { ${effectName2PropertyMap[item.name]}: ${covertValue(item.name, value)}!important; }`);
            }
          });
        });
        dynamicAnimationStyles2.value.innerHTML = styles.join("\n");
      }, { immediate: true, deep: true });
      onBeforeUnmount(() => removeListenerList.value.forEach((fn) => fn()));
    };
    const covertSize$1 = (s, options) => {
      var _a;
      return { "VITE_LOGTO_HOST": "https://p-easy.net", "VITE_LOGTO_APPID": "c4319adTcyr9vXJ1XYU3m", "VITE_LOGTO_REDIRECT_URL": "https://p-easy.net/site/redirect", "VITE_LOGTO_SIGN_OUT_URL": "https://p-easy.net/site/", "VITE_LOGTO_RESOURCE": "https://api.logto.io", "VITE_BE_HOST": "", "VITE_BE_PREFIX": "/site", "VITE_URL_BASE": "/site/", "BASE_URL": "/site/", "MODE": "production", "DEV": false, "PROD": true }.VITE_IS_TEMPLATE === "true" ? s.slice(-1) === "%" && (options == null ? void 0 : options.isSection) ? `${s.slice(0, -1)}${(options == null ? void 0 : options.type) === "height" ? "vh" : "vw"}` : s : (_a = window == null ? void 0 : window.covertSize) == null ? void 0 : _a.call(window, s, options);
    };
    const useStyle = (styles) => {
      for (let key in styles) {
        if (!styles[key]) {
          delete styles[key];
        }
      }
      return styles;
    };
    const useTextBasicStyle = (basic) => {
      if (!basic)
        return {};
      return {
        whiteSpace: basic.whiteSpace
      };
    };
    const useImageBasicStyle = (basic) => {
      if (!basic)
        return {};
      return {
        objectFit: basic.objectFit
      };
    };
    const useIconBasicStyle = (basic) => {
      if (!basic)
        return {};
      return {
        color: getColor(basic.color),
        fontSize: covertSize$1(basic.size)
      };
    };
    const getPositionTransform = (position) => {
      const isAbsPosition = ["absolute", "fixed"].includes(position.position);
      let horizontal = {};
      let vertical = {};
      let transform2 = "";
      if (isAbsPosition) {
        horizontal = position.left === "auto" && position.right === "auto" ? { left: "50%", center: true } : position.left !== "auto" ? { left: position.left } : { right: position.right };
        vertical = position.top === "auto" && position.bottom === "auto" ? { top: "50%", center: true } : position.top !== "auto" ? { top: position.top } : { bottom: position.bottom };
        transform2 = horizontal.center && vertical.center ? "translate(-50%, -50%)" : horizontal.center ? "translateX(-50%)" : vertical.center ? "translateY(-50%)" : "";
      }
      return {
        horizontal,
        vertical,
        transform: transform2
      };
    };
    const usePositionStyle = (position) => {
      if (!position)
        return {};
      const isAbsPosition = computed(() => ["absolute", "fixed"].includes(position.position));
      const isEditMode = getIsEditMode();
      let { horizontal, vertical, transform: transform2 } = getPositionTransform(position);
      return {
        position: isAbsPosition.value ? isEditMode ? "absolute" : position.position : "relative",
        left: horizontal.left ? horizontal.left : "auto",
        right: horizontal.right ? horizontal.right : "auto",
        top: vertical.top ? vertical.top : "auto",
        bottom: vertical.bottom ? vertical.bottom : "auto",
        transform: transform2,
        zIndex: position.zIndex
      };
    };
    const useSizeStyle = (size2, direction) => {
      if (!size2)
        return {};
      const isSection = !direction;
      let width = covertSize$1(size2.width, { isSection, type: "width" });
      let height = covertSize$1(size2.height, { isSection, type: "height" });
      let minHeight = covertSize$1(size2.minHeight, { isSection, type: "height" });
      let maxHeight = covertSize$1(size2.maxHeight, { isSection, type: "height" });
      let flexStyles = { "flex-shrink": "0" };
      if (width === "stretch") {
        width = "";
        if (direction === "row") {
          flexStyles.flexGrow = 1;
          flexStyles["flex-shrink"] = "1";
          flexStyles["flex-basis"] = "0%";
        } else {
          flexStyles.alignSelf = "stretch";
        }
      }
      if (height === "stretch") {
        height = "";
        if (direction === "column") {
          flexStyles.flexGrow = 1;
          flexStyles["flex-shrink"] = "1";
          flexStyles["flex-basis"] = "0%";
        } else {
          flexStyles.alignSelf = "stretch";
        }
      }
      return {
        width,
        height,
        minWidth: size2.minWidth,
        minHeight,
        maxWidth: size2.maxWidth,
        maxHeight,
        ...flexStyles
      };
    };
    const useLayoutStyle = (layout) => {
      if (!layout)
        return {};
      return {
        display: "flex",
        flexDirection: layout.direction + (layout.reverse ? "-reverse" : ""),
        justifyContent: layout.justify,
        alignItems: layout.align,
        flexWrap: layout.wrap
      };
    };
    const useBorderStyle = (border) => {
      if (!border)
        return {};
      const getBorder = (data2, index2, isColor) => isColor ? Array.isArray(data2) ? getColor(data2[index2]) : getColor(data2) : Array.isArray(data2) ? data2[index2] : data2;
      const [borderTop, borderRight, borderBottom, borderLeft] = Array.from(new Array(4), (_, i2) => [
        getBorder(border.borderWidth, i2),
        getBorder(border.borderStyle, i2),
        getBorder(border.borderColor, i2, true)
      ].join(" "));
      const getBorderRadius = (radius) => radius === "circle" ? "50%" : radius;
      return {
        borderTop,
        borderRight,
        borderBottom,
        borderLeft,
        borderRadius: Array.isArray(border.borderRadius) ? border.borderRadius.map(getBorderRadius).join(" ") : getBorderRadius(border.borderRadius)
      };
    };
    const useFontStyle = (font) => {
      if (!font)
        return {};
      getIsEditMode();
      return {
        fontSize: covertSize$1(font.fontSize),
        lineHeight: covertSize$1(font.lineHeight),
        fontWeight: font.fontWeight,
        fontStyle: font.fontStyle,
        textDecoration: font.textDecoration,
        textAlign: font.textAlign,
        color: getColor(font.color),
        textShadow: font.textShadow,
        fontFamily: font.fontFamily
      };
    };
    const useSpacingStyle = (spacing) => {
      if (!spacing)
        return {};
      return {
        margin: spacing.margin.map((n) => `${n}px`).join(" "),
        padding: spacing.padding.map((n) => `${n}px`).join(" ")
      };
    };
    const useBackgroundStyle = (background) => {
      if (!background)
        return {};
      if (background.backgroundType === "color") {
        return {
          backgroundColor: getColor(background.backgroundColor)
        };
      } else if (background.backgroundType === "image") {
        return {
          backgroundImage: background.backgroundImage ? `url(${background.backgroundImage})` : "",
          backgroundPosition: background.backgroundPosition,
          backgroundRepeat: background.backgroundRepeat,
          backgroundSize: background.backgroundSize,
          backgroundAttachment: background.backgroundAttachment
        };
      } else if (background.backgroundType === "gradient") {
        return {
          backgroundImage: `linear-gradient(${background.backgroundGradientAngle}deg, ${background.backgroundGradient.map(({ color, percentage }) => `${getColor(color)} ${percentage}%`)})`
        };
      }
    };
    const useContainerStyle = (container) => {
      if (!container)
        return {};
      return {
        opacity: container.opacity,
        overflow: container.overflow,
        boxShadow: container.boxShadow,
        cursor: container.cursor,
        filter: container.filter
      };
    };
    const useAnimationStyle = (animationMap) => {
      if (!animationMap || !animationMap.size)
        return {};
      const animationList = [];
      animationMap.forEach((item, anim) => {
        if (item.disabled)
          return;
        const iteration = ["always", "hover"].includes(anim.trigger) ? "infinite" : 1;
        animationList.push(`${item.animationName} ${anim.duration}s ${anim.timingFunction} ${anim.delay}s ${iteration} ${anim.direction} ${anim.fillMode} running`);
      });
      return {
        animation: animationList.join(", ")
      };
    };
    const useEffectStyle = (effect2, name) => {
      if (!effect2)
        return {};
      return {
        transition: effect2.effectList.map((item) => item.name && item.targetType === "self" ? `${effectName2PropertyMap[item.name]} ${item.duration}s ${item.timingFunction}` : "").filter(Boolean).join(", ")
      };
    };
    const useIntersectionObserver = (target, setIsIntersection) => {
      const callback = function(entries, observer2) {
        if (entries[0].isIntersecting) {
          setIsIntersection(true);
        } else if (entries[0].boundingClientRect.top >= 0) {
          setIsIntersection(false);
        }
      };
      const observer = new IntersectionObserver(callback, {
        root: document.body,
        rootMargin: "0px",
        threshold: 0
      });
      observer.observe(target);
      return observer;
    };
    const useAnimation = (propsRef, el) => {
      const animation = computed(() => propsRef.animation);
      const position = computed(() => propsRef.position);
      let dynamicAnimationStyles2 = ref(null);
      let observer = ref(null);
      let removeListenerList = ref([]);
      let animationMap = reactive(/* @__PURE__ */ new Map());
      let isBindClick = ref(false);
      let isBindHover = ref(false);
      const onBindIntersectionObserver = (el2) => {
        if (observer.value)
          return;
        observer.value = useIntersectionObserver(el2, (isIntersecting) => {
          animationMap.forEach((item, anim) => {
            if (isIntersecting) {
              if (item.isAnimate)
                return;
              item.isAnimate = true;
              setTimeout(() => item.isAnimate = false, (anim.duration + anim.delay) * 1e3);
            }
            if (anim.trigger === "scrollIntoView") {
              item.disabled = !isIntersecting;
            }
          });
        });
        removeListenerList.value.push(() => {
          var _a;
          return (_a = observer.value) == null ? void 0 : _a.disconnect();
        });
      };
      const onBindClick = (el2) => {
        if (isBindClick.value)
          return;
        isBindClick.value = true;
        const clickHandler = (e) => {
          animationMap.forEach((item, anim) => {
            if (anim.trigger === "click" && item.disabled) {
              item.disabled = false;
              setTimeout(() => item.disabled = true, (anim.duration + anim.delay) * 1e3);
            }
          });
        };
        el2.addEventListener("click", clickHandler, true);
        removeListenerList.value.push(() => el2.removeEventListener("click", clickHandler));
      };
      const onBindHover = (el2) => {
        if (isBindHover.value)
          return;
        isBindHover.value = true;
        const hoverHandler = (e) => {
          animationMap.forEach((item, anim) => {
            if (anim.trigger === "hover" && item.disabled) {
              item.disabled = false;
            }
          });
        };
        const leaveHandler = (e) => {
          animationMap.forEach((item, anim) => {
            if (anim.trigger === "hover" && !item.disabled) {
              item.disabled = true;
            }
          });
        };
        el2.addEventListener("mouseenter", hoverHandler, true);
        el2.addEventListener("mouseleave", leaveHandler, true);
        removeListenerList.value.push(() => {
          el2.removeEventListener("mouseenter", hoverHandler);
          el2.removeEventListener("mouseleave", leaveHandler);
        });
      };
      watch(() => [animation.value, position.value, el], () => {
        var _a, _b, _c;
        if (!((_b = (_a = animation.value) == null ? void 0 : _a.animationList) == null ? void 0 : _b.length) || el.value === null) {
          animationMap.clear();
          return;
        }
        if (!dynamicAnimationStyles2.value) {
          dynamicAnimationStyles2.value = document.createElement("style");
          document.head.appendChild(dynamicAnimationStyles2.value);
          removeListenerList.value.push(() => document.head.removeChild(dynamicAnimationStyles2.value));
        }
        const animationList = (_c = animation.value) == null ? void 0 : _c.animationList;
        let stylesheet = "";
        let bindEvents = {};
        animationList.forEach((anim) => {
          bindEvents[anim.trigger] = true;
          const animName = getAnimateName(anim);
          const keyframeBody = getKeyframeBody(anim, position.value);
          const keyframe = getKeyframe(animName, keyframeBody);
          stylesheet += keyframe;
          animationMap.set(anim, { animationName: animName, disabled: anim.trigger !== "always", isAnimate: false });
        });
        dynamicAnimationStyles2.value.innerHTML = stylesheet;
        if (bindEvents["scrollIntoView"] && el.value) {
          onBindIntersectionObserver(el.value);
        }
        if (bindEvents["click"] && el.value) {
          onBindClick(el.value);
        }
        if (bindEvents["hover"] && el.value) {
          onBindHover(el.value);
        }
      }, { deep: true, immediate: true });
      onBeforeUnmount(() => removeListenerList.value.forEach((fn) => fn()));
      return {
        animationMap
      };
    };
    function getKeyframeBody(anim, position) {
      var _a, _b, _c, _d, _e, _f, _g;
      let setting;
      if (anim.name === "fade") {
        setting = anim.settings.fade;
        return `
      from {
        opacity: ${(_a = setting == null ? void 0 : setting.opacity) != null ? _a : 1};
      }
    `;
      }
      if (anim.name.startsWith("slide")) {
        setting = anim.settings.slide;
        const offset2 = (_b = setting == null ? void 0 : setting.offset) != null ? _b : 100;
        let x = anim.name === "slide-left" ? offset2 : anim.name === "slide-right" ? -offset2 : 0;
        let y = anim.name === "slide-up" ? offset2 : anim.name === "slide-down" ? -offset2 : 0;
        const { horizontal, vertical } = getPositionTransform(position);
        return `
      from {
        transform: translate(${x + ((horizontal == null ? void 0 : horizontal.center) ? -50 : 0)}%, ${y + ((vertical == null ? void 0 : vertical.center) ? -50 : 0)}%);
        opacity: ${(_c = setting == null ? void 0 : setting.opacity) != null ? _c : 1};
      }
    `;
      }
      if (anim.name.startsWith("zoom")) {
        setting = anim.settings.zoom;
        const zoom = (_d = setting == null ? void 0 : setting.zoom) != null ? _d : 1;
        const { transform: transform2 } = getPositionTransform(position);
        return `
      from {
        transform: scale(${anim.name === "zoom-in" ? 1 - zoom : 1 + zoom})${transform2 ? ` ${transform2}` : ""};
        opacity: ${(_e = setting == null ? void 0 : setting.opacity) != null ? _e : 1};
      }
    `;
      }
      if (anim.name.startsWith("rotate")) {
        setting = anim.settings.rotate;
        const angle = (_f = setting == null ? void 0 : setting.angle) != null ? _f : 0;
        const { transform: transform2 } = getPositionTransform(position);
        return `
      from {
        transform: rotate${anim.name === "rotate-x" ? "X" : "Y"}(${angle}deg)${transform2 ? ` ${transform2}` : ""};
        opacity: ${(_g = setting == null ? void 0 : setting.opacity) != null ? _g : 1};
      }
    `;
      }
      return "";
    }
    function getKeyframe(keyframeName, keyframeBody) {
      if (!keyframeBody || !keyframeName)
        return "";
      let keyframe = `@keyframes ${keyframeName} {
    ${keyframeBody}
  }`;
      return keyframe.replace(/\n/g, "").replace(/\s+/g, " ");
    }
    let uniqueId = 0;
    const uniqueMap = /* @__PURE__ */ new WeakMap();
    const getAnimateName = (anim) => {
      let id;
      if (uniqueMap.has(anim)) {
        id = uniqueMap.get(anim);
      } else {
        id = uniqueId++;
        uniqueMap.set(anim, id);
      }
      return `__${anim.name}-${id}__`;
    };
    const useEvent = (propsRef, el) => {
      let stop2 = ref(null);
      const event = computed(() => propsRef.event);
      const editContext = getContext();
      onMounted(() => {
        if (!el.value)
          return;
        stop2.value = eventHandler(event.value, el.value);
      });
      onBeforeMount(() => {
        var _a;
        return (_a = stop2.value) == null ? void 0 : _a.call(stop2);
      });
      watch(() => event.value, () => {
        var _a;
        (_a = stop2.value) == null ? void 0 : _a.call(stop2);
        if (!el.value)
          return;
        stop2.value = eventHandler(event.value, el.value);
      });
      const eventHandler = (event2, el2) => {
        if (!event2)
          return null;
        const handler = (e) => {
          if ((editContext == null ? void 0 : editContext.isEditMode) && ((editContext == null ? void 0 : editContext.lockScriptTrigger) || (editContext == null ? void 0 : editContext.displayMode) !== "preview"))
            return;
          if (event2.stopPropagation) {
            e.preventDefault();
          }
          if (event2.action === "link") {
            if (!event2.link)
              return;
            const a = document.createElement("a");
            a.href = event2.link;
            a.target = event2.openNewTab ? "_blank" : "_self";
            a.click();
            a.remove();
          } else if (event2.action === "func") {
            if (!event2.execFunction)
              return;
            const args = "...args";
            const fn = new Function(args, `var [event, data, getByName, getByTag] = args;${event2.execFunction}`);
            fn(e, propsRef, (name) => {
              var _a;
              return (_a = document.body.querySelector("." + getUniqueName(name))) == null ? void 0 : _a.__node__;
            }, (tagName) => Array.from(document.body.querySelectorAll("." + getTagClassName(tagName)) || []).map((el3) => el3.__node__));
          } else if (event2.action === "scrollTo") {
            if (event2.scrollTarget) {
              if (+event2.scrollTarget >= 0) {
                const wrap = (editContext == null ? void 0 : editContext.isEditMode) ? document.querySelector(".edit-wrapper") : document.querySelector("#app");
                wrap == null ? void 0 : wrap.scrollTo({
                  top: +event2.scrollTarget,
                  behavior: "smooth"
                });
              } else {
                const elem = document.querySelector(`[data-name="${event2.scrollTarget}"]`);
                elem == null ? void 0 : elem.scrollIntoView({
                  behavior: "smooth"
                });
              }
            }
          }
        };
        let removeListenerList = [];
        if (event2.type === "tap") {
          el2.addEventListener("click", handler, false);
          removeListenerList.push(() => {
            el2.removeEventListener("click", handler, false);
          });
        }
        if (event2.type === "mousedown") {
          el2.addEventListener("mousedown", handler, false);
          removeListenerList.push(() => {
            el2.removeEventListener("mousedown", handler, false);
          });
        }
        if (event2.type === "touchstart") {
          el2.addEventListener("touchstart", handler, false);
          removeListenerList.push(() => {
            el2.removeEventListener("touchstart", handler, false);
          });
        }
        return () => removeListenerList.forEach((fn) => fn());
      };
    };
    const useProps = (props, componentTypeName) => {
      const propsRef = reactive(props);
      const elem = ref(null);
      useEvent(propsRef, elem);
      const { animationMap } = useAnimation(propsRef, elem);
      useEffect(propsRef);
      const style2 = computed(() => useStyle({
        ...componentTypeName === "Text" ? useTextBasicStyle(propsRef.basic) : componentTypeName === "Image" ? useImageBasicStyle(propsRef.basic) : componentTypeName === "Icon" ? useIconBasicStyle(propsRef.basic) : {},
        ...useFontStyle(propsRef.font),
        ...useLayoutStyle(propsRef.layout),
        ...useSizeStyle(propsRef.size, propsRef.direction),
        ...useSpacingStyle(propsRef.spacing),
        ...useBorderStyle(propsRef.border),
        ...useBackgroundStyle(propsRef.background),
        ...useContainerStyle(propsRef.container),
        ...usePositionStyle(propsRef.position),
        ...useAnimationStyle(animationMap),
        ...useEffectStyle(propsRef.effect, propsRef.componentName),
        ...propsRef.common.hide ? { display: "none" } : null
      }));
      const uName = computed(() => getUniqueName(propsRef.componentName));
      const tagClassNames = computed(() => propsRef.tags.map((tag) => getTagClassName(tag)));
      onMounted(() => {
        if (!elem.value)
          return;
        elem.value.__node__ = props;
      });
      onBeforeMount(() => {
        if (!elem.value)
          return;
        delete elem.value.__node__;
      });
      return {
        elem,
        style: style2,
        uName,
        tagClassNames,
        props: propsRef
      };
    };
    const _hoisted_1$Y = ["id"];
    const __default__$9 = {
      inheritAttrs: false
    };
    const _sfc_main$10 = /* @__PURE__ */ defineComponent({
      ...__default__$9,
      __name: "Text",
      setup(__props) {
        const { elem, uName, style: style2, props, tagClassNames } = useProps(useAttrs(), "Text");
        const classNames = computed(() => ["text", uName.value, ...tagClassNames.value]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({
            ref_key: "elem",
            ref: elem,
            id: unref$1(uName),
            style: unref$1(style2),
            class: classNames.value
          }, unref$1(props).inheritAttrs), toDisplayString(unref$1(props).basic.text), 17, _hoisted_1$Y);
        };
      }
    });
    const Text_vue_vue_type_style_index_0_scoped_a5319143_lang = "";
    const Text = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__scopeId", "data-v-a5319143"]]);
    const _hoisted_1$X = ["id"];
    const __default__$8 = {
      inheritAttrs: false
    };
    const _sfc_main$$ = /* @__PURE__ */ defineComponent({
      ...__default__$8,
      __name: "Block",
      setup(__props) {
        const { elem, uName, style: style2, props, tagClassNames } = useProps(useAttrs(), "Block");
        const classNames = computed(() => ["block", uName.value, ...tagClassNames.value]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({
            ref_key: "elem",
            ref: elem
          }, unref$1(props).inheritAttrs, {
            class: classNames.value,
            style: unref$1(style2),
            id: unref$1(uName)
          }), [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 16, _hoisted_1$X);
        };
      }
    });
    const Block_vue_vue_type_style_index_0_scoped_3c139d75_lang = "";
    const Block = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__scopeId", "data-v-3c139d75"]]);
    const _hoisted_1$W = ["id", "src"];
    const __default__$7 = {
      inheritAttrs: false
    };
    const _sfc_main$_ = /* @__PURE__ */ defineComponent({
      ...__default__$7,
      __name: "Image",
      setup(__props) {
        const { elem, uName, style: style2, props, tagClassNames } = useProps(useAttrs(), "Image");
        const src2 = computed(() => {
          var _a, _b;
          return ((_b = (_a = props.basic) == null ? void 0 : _a.src) == null ? void 0 : _b.trim()) || "";
        });
        const classNames = computed(() => [
          "image",
          uName.value,
          ...tagClassNames.value,
          { "no-image": !props.basic.src }
        ]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("img", mergeProps({
            ref_key: "elem",
            ref: elem,
            class: classNames.value,
            style: unref$1(style2),
            id: unref$1(uName),
            src: src2.value
          }, unref$1(props).inheritAttrs), null, 16, _hoisted_1$W);
        };
      }
    });
    const Image_vue_vue_type_style_index_0_scoped_db217255_lang = "";
    const Image$1 = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__scopeId", "data-v-db217255"]]);
    const _hoisted_1$V = ["id"];
    const __default__$6 = {
      inheritAttrs: false
    };
    const iconLinkList = [];
    const _sfc_main$Z = /* @__PURE__ */ defineComponent({
      ...__default__$6,
      __name: "Icon",
      setup(__props) {
        const { elem, uName, style: style2, props, tagClassNames } = useProps(useAttrs(), "Icon");
        let styleElem = ref(null);
        getIsEditMode();
        watch(() => props.basic.styleLink, () => {
          if (styleElem.value) {
            document.body.removeChild(styleElem.value);
            styleElem.value = null;
          }
          if (props.basic.styleLink) {
            if (iconLinkList.includes(props.basic.styleLink))
              return;
            styleElem.value = document.createElement("link");
            styleElem.value.rel = "stylesheet";
            styleElem.value.href = props.basic.styleLink;
            document.body.appendChild(styleElem.value);
            iconLinkList.push(props.basic.styleLink);
          }
        }, { immediate: true });
        const classNames = computed(() => {
          var _a;
          return [
            "fa",
            uName.value,
            ...tagClassNames.value,
            `${props.basic.prefixClass || ""}${props.basic.name}`,
            `${((_a = props.basic) == null ? void 0 : _a.extraClass) || ""}`
          ];
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({ class: ["fa-icon"] }, unref$1(props).inheritAttrs), [
            createBaseVNode("i", {
              class: normalizeClass(classNames.value),
              style: normalizeStyle(unref$1(style2)),
              id: unref$1(uName)
            }, null, 14, _hoisted_1$V)
          ], 16);
        };
      }
    });
    const Icon_vue_vue_type_style_index_0_scoped_43be0ae9_lang = "";
    const Icon = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__scopeId", "data-v-43be0ae9"]]);
    const template = "";
    const GlobalDirective = {
      install(app2) {
        app2.directive("collapse", {
          mounted(el, binding) {
            if (binding.value === false) {
              const height = el.getBoundingClientRect().height;
              el.style.transition = "none";
              el.dataset.originHeight = height;
              el.style.paddingTop = "0";
              el.style.paddingBottom = "0";
              el.style.overflow = "hidden";
              el.style.height = "0";
              el.offsetWidth;
              el.style.transition = "";
            }
          },
          updated(el, binding) {
            if (binding.value === true) {
              if (el.dataset.originHeight) {
                let onTransitionEnd = function() {
                  el.style.height = "";
                  el.style.overflow = "";
                  el.style.transition = "";
                  el.removeEventListener("transitionend", onTransitionEnd);
                };
                el.style.transition = "all .2s ease-out";
                el.style.paddingTop = "";
                el.style.paddingBottom = "";
                el.style.height = el.dataset.originHeight + "px";
                delete el.dataset.originHeight;
                el.addEventListener("transitionend", onTransitionEnd);
              }
            } else {
              const height = el.getBoundingClientRect().height;
              if (!height)
                return;
              el.style.transition = "all .2s ease-out";
              el.style.height = height + "px";
              el.style.paddingTop = "0";
              el.style.paddingBottom = "0";
              el.style.overflow = "hidden";
              el.dataset.originHeight = height;
              el.offsetWidth;
              el.style.height = "0";
            }
          }
        });
        app2.directive("click-outside", {
          created(el, binding) {
            if (!binding.value)
              return;
            if (typeof binding.value !== "function" && typeof binding.value.handler !== "function") {
              console.warn("[Vue-click-outside:] provided expression", binding.value, "is not a function.");
              return;
            }
            const { value } = binding;
            el.__clickOutside_cb__ = typeof value === "function" ? value : value.handler;
            const extraSelectors = value.extraSelectors || [];
            const includeParent = value.parent || true;
            function handleClick(e) {
              var _a, _b;
              const target = e.target;
              if (el.contains(target) || (includeParent ? (_a = el.parentElement) == null ? void 0 : _a.contains(target) : false) || extraSelectors.some((selector) => Array.from(document.querySelectorAll(selector)).some((elem) => elem.contains(target))))
                return;
              (_b = el.__clickOutside_cb__) == null ? void 0 : _b.call(el, e);
            }
            const clickHandler = "ontouchstart" in document.documentElement ? "touchstart" : "click";
            document.addEventListener(clickHandler, handleClick, true);
            el.__clickOutside_rm__ = () => document.removeEventListener(clickHandler, handleClick);
          },
          updated(el, binding) {
            if (!binding.value)
              return;
            el.__clickOutside_cb__ = typeof binding.value === "function" ? binding.value : binding.value.handler;
          },
          beforeUnmount(el) {
            var _a;
            el.__clickOutside_cb__ = null;
            delete el.__clickOutside_cb__;
            (_a = el.__clickOutside_rm__) == null ? void 0 : _a.call(el);
            delete el.__clickOutside_rm__;
          }
        });
        app2.directive("hover", {
          mounted(el, binding) {
            const setValue = (value) => binding.value(value);
            const handleMouseEnter = () => setValue(true);
            const handleMouseLeave = () => setValue(false);
            el.addEventListener("mouseenter", handleMouseEnter);
            el.addEventListener("mouseleave", handleMouseLeave);
            el.__hover_directive__ = () => {
              el.removeEventListener("mouseenter", handleMouseEnter);
              el.removeEventListener("mouseleave", handleMouseLeave);
            };
          },
          beforeMount(el) {
            var _a;
            (_a = el.__hover_directive__) == null ? void 0 : _a.call(el);
          }
        });
        app2.directive("tap", {
          mounted(el, binding) {
            var _a;
            let mousedownTime = 0;
            el.__tap_cb__ = binding.value;
            const isStop = (_a = binding.modifiers) == null ? void 0 : _a.stop;
            const handleMousedown = () => mousedownTime = Date.now();
            const handleClick = (e) => {
              var _a2;
              if (Date.now() - mousedownTime < 300) {
                isStop && (e == null ? void 0 : e.stopPropagation());
                (_a2 = el.__tap_cb__) == null ? void 0 : _a2.call(el, e);
              }
            };
            el.addEventListener("mousedown", handleMousedown, false);
            el.addEventListener("click", handleClick);
            el.__tap_rm__ = () => {
              el.removeEventListener("mousedown", handleMousedown);
              el.removeEventListener("click", handleClick);
            };
          },
          updated(el, binding) {
            el.__tap_cb__ = binding.value;
          },
          beforeUnmount(el) {
            var _a;
            (_a = el.__tap_rm__) == null ? void 0 : _a.call(el);
            delete el.__tap_rm__;
            delete el.__tap_cb__;
          }
        });
      }
    };
    const style = "";
    const index$2 = "";
    const useDragStore = defineStore("drag", {
      state: () => ({
        dragNode: null,
        dragParentNode: null,
        dragType: "clone",
        dropZone: null,
        isCancelDrag: false
      }),
      getters: {
        dragNodeType: (state) => {
          var _a;
          return (_a = state.dragNode) == null ? void 0 : _a.type;
        },
        dragNodeChildNameMap: (state) => {
          if (state.dragNode === null || state.dragType !== "move")
            return {};
          const nameMap = {
            [state.dragNode.name]: state.dragNode
          };
          const dfs = (nodes) => {
            nodes.forEach((item) => {
              nameMap[item.name] = item;
              if (item.children)
                dfs(item.children);
            });
          };
          dfs(state.dragNode.children || []);
          return nameMap;
        },
        getIsInDragNode: function() {
          return (name) => this.dragNodeChildNameMap[name];
        }
      },
      actions: {
        setDragNode(node, dragType = "clone") {
          this.dragNode = node;
          this.dragType = dragType;
          this.dropZone = null;
          this.isCancelDrag = false;
        },
        setDropZone(node) {
          this.dropZone = node;
        },
        setIsCancelDrag(isCancelDrag) {
          this.isCancelDrag = isCancelDrag;
        }
      }
    });
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal$1 || freeSelf || Function("return this")();
    const root$1 = root;
    var Symbol$1 = root$1.Symbol;
    const Symbol$2 = Symbol$1;
    var objectProto$d = Object.prototype;
    var hasOwnProperty$a = objectProto$d.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$d.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$c = Object.prototype;
    var nativeObjectToString = objectProto$c.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$2 = "[object Symbol]";
    function isSymbol$2(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
    }
    function arrayMap(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var isArray$1 = Array.isArray;
    const isArray$2 = isArray$1;
    var INFINITY$1 = 1 / 0;
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$2(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol$2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function isObject$2(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol$2(value)) {
        return NAN;
      }
      if (isObject$2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$2(value) {
      if (!isObject$2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$b = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
      if (!isObject$2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root$1, "WeakMap");
    const WeakMap$2 = WeakMap$1;
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject$2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    const baseCreate$1 = baseCreate;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array2) {
      var index2 = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index2 < length) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    const defineProperty$1 = defineProperty;
    var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
      return defineProperty$1(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var setToString = shortOut(baseSetToString$1);
    const setToString$1 = setToString;
    function arrayEach(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$a = Object.prototype;
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$8.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
        while (++index2 < length) {
          array2[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform2(array2);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString$1(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$2(value);
    }
    function isIterateeCall(value, index2, object) {
      if (!isObject$2(object)) {
        return false;
      }
      var type2 = typeof index2;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
        return eq(object[index2], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$9 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    const isArguments$1 = isArguments;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
    var isBuffer$1 = nativeIsBuffer || stubFalse;
    const isBuffer$2 = isBuffer$1;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    const nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    const isTypedArray$2 = isTypedArray$1;
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys$1(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$5.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject$2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray$2(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate$1) {
        var result = data2[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$3.call(data2, key) ? data2[key] : void 0;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$2.call(data2, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size2 = data2.size;
      data2.set(key, value);
      this.size += data2.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar$1 = /\\(\\)?/g;
    var stringToPath$1 = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName$1, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number2 || match);
      });
      return result;
    });
    const stringToPath$2 = stringToPath$1;
    function toString$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray$2(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath$2(toString$1(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol$2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index2 = 0, length = path.length;
      while (object != null && index2 < length) {
        object = object[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    var objectTag$2 = "[object Object]";
    var funcProto = Function.prototype, objectProto$2 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject$2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
        return false;
      }
      var proto = getPrototype$1(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$1.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$1 = Object.prototype;
    var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function copySymbols(source, object) {
      return copyObject(source, getSymbols$1(source), object);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols$1(object));
        object = getPrototype$1(object);
      }
      return result;
    };
    const getSymbolsIn$1 = getSymbolsIn;
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn$1(source), object);
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols$1);
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
    }
    var DataView$1 = getNative(root$1, "DataView");
    const DataView$2 = DataView$1;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    const Set$2 = Set$1;
    var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
    var getTag = baseGetTag;
    if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var Uint8Array$1 = root$1.Uint8Array;
    const Uint8Array$2 = Uint8Array$1;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object);
        case dataViewTag$1:
          return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$1:
          return new Ctor(object);
        case regexpTag$1:
          return cloneRegExp(object);
        case setTag$2:
          return new Ctor();
        case symbolTag$1:
          return cloneSymbol(object);
      }
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
    }
    var mapTag$1 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$1;
    }
    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    const isMap$2 = isMap;
    var setTag$1 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$1;
    }
    var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    const isSet$2 = isSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (customizer) {
        result = object ? customizer(value, key, object, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$2(value)) {
        return value;
      }
      var isArr = isArray$2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet$2(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap$2(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    const baseFor$1 = baseFor;
    var now = function() {
      return root$1.Date.now();
    };
    const now$1 = now;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject$2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now$1();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now$1());
      }
      function debounced() {
        var time = now$1(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray$2(srcValue), isBuff = !isArr && isBuffer$2(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray$2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject$2(srcValue) || isArguments$1(srcValue)) {
          newValue = objValue;
          if (isArguments$1(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject$2(objValue) || isFunction$2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor$1(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject$2(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var merge$1 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    const merge$2 = merge$1;
    function baseSet(object, path, value, customizer) {
      if (!isObject$2(object)) {
        return object;
      }
      path = castPath(path, object);
      var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index2 < length) {
        var key = toKey(path[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index2 != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject$2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle$2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject$2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    const createUnitName = (originName, nameMap) => {
      var _a, _b, _c, _d;
      const matchObj = /(?<name>.*)-(?<index>\d+)$/.exec(originName);
      let baseName = (_b = (_a = matchObj == null ? void 0 : matchObj.groups) == null ? void 0 : _a.name) != null ? _b : originName;
      let i2 = ((_c = matchObj == null ? void 0 : matchObj.groups) == null ? void 0 : _c.index) ? parseInt((_d = matchObj == null ? void 0 : matchObj.groups) == null ? void 0 : _d.index) + 1 : 1;
      let name = `${baseName}-${i2}`;
      while (nameMap[name]) {
        name = `${baseName}-${++i2}`;
      }
      return name;
    };
    const formatNodeByUniqueName = (originNode, nameMap, isLinkProp = false) => {
      const newNode = cloneDeep(originNode);
      let pendingNodeList = [newNode];
      let allChildNode = [];
      let nameUpdatedMap = {};
      while (pendingNodeList.length) {
        const node = pendingNodeList.shift();
        allChildNode.push(node);
        if (node.name in nameMap) {
          const originName = node.name;
          node.name = createUnitName(originName, nameMap);
          nameUpdatedMap[originName] = node.name;
          if (isLinkProp) {
            node.config = node.propLink && node.config ? node.config : { props: {} };
            node.propLink = node.propLink || originName;
          }
          nameMap[node.name] = node;
        }
        if (node.children) {
          pendingNodeList = pendingNodeList.concat(node.children);
        }
      }
      if (!isLinkProp) {
        allChildNode.forEach((node) => {
          if (node.propLink) {
            node.propLink = nameUpdatedMap[node.propLink] || node.propLink;
          }
        });
      }
      return newNode;
    };
    const getDefaultDevice = (parent2, preset, type2 = "desktop") => {
      const refer = (type2 === "desktop" ? parent2.width : parent2.height) * 0.9;
      const referIndex = type2 === "desktop" ? 0 : 1;
      let size2 = preset[0];
      let zoom = 1;
      if (refer < size2[referIndex] * 0.6) {
        zoom = 0.5;
      } else if (refer < size2[referIndex] * 0.8) {
        zoom = 0.6;
      } else if (refer < size2[referIndex]) {
        zoom = 0.8;
      } else {
        for (let i2 = 1; i2 < preset.length; i2++) {
          if (refer >= preset[i2][referIndex]) {
            size2 = preset[i2];
          }
        }
      }
      return {
        width: size2[0],
        height: size2[1],
        zoom
      };
    };
    const useDisplayStore = defineStore("display", {
      state: () => ({
        presetDevice: {
          desktop: [
            [1366, 768],
            [1920, 1080],
            [2560, 1440]
          ],
          mobile: [
            [375, 667],
            [414, 896],
            [768, 1024]
          ]
        },
        deviceType: "desktop",
        device: { width: 0, height: 0, zoom: 1 },
        groupStatus: {},
        layerStatus: /* @__PURE__ */ new WeakMap(),
        displayMode: "edit",
        lockDragSetPosition: false,
        lockScriptTrigger: true,
        minimize: false,
        colorType: "variable"
      }),
      getters: {
        realDeviceSize(state) {
          return {
            width: state.device.width * state.device.zoom,
            height: state.device.height * state.device.zoom
          };
        },
        getGroupStatus(state) {
          return (group) => state.groupStatus[group];
        },
        curPresetDeviceList(state) {
          return state.presetDevice[state.deviceType];
        },
        curWidthFootSize(state) {
          var _a;
          return ((_a = usePageStore().font.mediaFontSize) == null ? void 0 : _a[state.device.width]) || 0;
        },
        curFootSize(state) {
          var _a;
          const curWidthFootSize = (_a = usePageStore().font.mediaFontSize) == null ? void 0 : _a[state.device.width];
          if (curWidthFootSize)
            return curWidthFootSize;
          let fontSize = usePageStore().font.fontSize;
          Object.entries(usePageStore().font.mediaFontSize).sort((a, b) => +a[0] - +b[0]).forEach(([width, size2]) => {
            if (state.device.width >= +width) {
              fontSize = size2;
            }
          });
          return fontSize;
        },
        lockDrag(state) {
          return state.lockDragSetPosition || state.displayMode !== "edit";
        }
      },
      actions: {
        setDeviceByParent(parentWidth, parentHeight) {
          this.device = getDefaultDevice({ width: parentWidth, height: parentHeight }, this.presetDevice[this.deviceType], this.deviceType);
        },
        setDevice(index2 = 0) {
          const size2 = this.presetDevice[this.deviceType][index2];
          this.device = {
            width: size2[0],
            height: size2[1],
            zoom: this.device.zoom
          };
        },
        saveGroupStatus(name, status) {
          this.groupStatus[name] = status;
        },
        setDisplayMode(mode) {
          this.displayMode = mode;
        },
        setLockDragSetPosition(lock) {
          this.lockDragSetPosition = lock;
        },
        setMinimize(minimize) {
          this.minimize = minimize;
        },
        setLockScriptTrigger(lock) {
          this.lockScriptTrigger = lock;
        }
      }
    });
    const useMobileConfig = () => usePageStore().setting.client === "both" && useDisplayStore().deviceType === "mobile";
    const useSourceNode = (node) => {
      const linkNode = node.propLink && usePageStore().nameMap[node.propLink];
      return linkNode || node;
    };
    const useConfig = (node) => {
      return useSourceNode(node).config;
    };
    const useConfigProps = (node) => {
      if (!node)
        return { common: { hide: false } };
      const groupTypeList = ComponentPropsGroup[node.component];
      let obj = {};
      for (let i2 = 0; i2 < groupTypeList.length; i2++) {
        const groupType = groupTypeList[i2];
        const group = useGroupConfig(node, groupType);
        if (group) {
          obj[groupType] = group;
        }
      }
      return obj;
    };
    const useGroupConfig = (node, groupType) => {
      if (!node)
        return null;
      const linkNode = node.propLink && usePageStore().nameMap[node.propLink];
      return useGroupConfigByNode(node, groupType) || useGroupConfigByNode(linkNode, groupType);
    };
    const useGroupConfigByNode = (node, groupType) => {
      var _a, _b, _c, _d, _e, _f;
      if (!node)
        return null;
      if (useMobileConfig() && ((_b = (_a = node.config) == null ? void 0 : _a.mobile) == null ? void 0 : _b[groupType])) {
        return (_d = (_c = node.config) == null ? void 0 : _c.mobile) == null ? void 0 : _d[groupType];
      }
      if ((_f = (_e = node.config) == null ? void 0 : _e.props) == null ? void 0 : _f[groupType]) {
        return node.config.props[groupType];
      }
      return null;
    };
    const isMobileGroupConfig = (node, groupType) => {
      var _a, _b, _c;
      if (!node || !groupType)
        return false;
      const configBySelf = useGroupConfigByNode(node, groupType);
      if (configBySelf) {
        return !!((_b = (_a = node.config) == null ? void 0 : _a.mobile) == null ? void 0 : _b[groupType]);
      }
      const config2 = useConfig(node);
      if (useMobileConfig() && ((_c = config2 == null ? void 0 : config2.mobile) == null ? void 0 : _c[groupType])) {
        return true;
      }
      return false;
    };
    const copyToClipboard = async (text) => {
      const data2 = [new ClipboardItem({ "text/plain": new Blob([text], { type: "text/plain" }) })];
      await navigator.clipboard.write(data2);
    };
    const getClipboardText = async () => {
      return await navigator.clipboard.readText();
    };
    let prevCutNode = null;
    const usePageStore = defineStore("page", {
      state: () => getStoragePageState("", {
        project: { name: "", cover: "" },
        allPageData: [],
        activeNode: null,
        activeParentChain: [],
        materialData: {
          section: [],
          component: [],
          template: []
        },
        activeSection: null,
        colorVars: [{ name: "$primary", color: "#3e7ce8" }],
        setting: {
          client: "both",
          title: "Page Title",
          favicon: "",
          description: ""
        },
        font: {
          fontFamily: `'Lato', -apple-system, PingFang SC, "Helvetica Neue", sans-serif`,
          customFontFace: ["https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&display=swap"],
          fontSize: 20,
          mediaFontSize: {}
        }
      }),
      getters: {
        activeNodeGroups: (state) => {
          var _a, _b;
          return state.activeNode ? state.activeNode.isModule ? new Array(((_b = (_a = state.activeNode) == null ? void 0 : _a.moduleConfig) == null ? void 0 : _b.length) || 0).fill("custom") : ComponentPropsGroup[state.activeNode.component] : null;
        },
        isActiveAllSection: (state) => state.activeSection === null,
        pageData: (state) => {
          if (!state.activeSection)
            return state.allPageData;
          const pageData = state.allPageData.find((item) => item === state.activeSection);
          return pageData ? [pageData] : state.allPageData;
        },
        nameMap: (state) => {
          const nameMap = {};
          const dfs = (nodes) => {
            nodes.forEach((item) => {
              nameMap[item.name] = item;
              if (item.children)
                dfs(item.children);
            });
          };
          dfs(state.allPageData);
          return nameMap;
        },
        getTagsByNode: (state) => (node) => {
          const tagList = [];
          const dfs = (nodes) => {
            nodes.forEach((item) => {
              tagList.push(...item.tags);
              if (item.children)
                dfs(item.children);
            });
          };
          dfs(node);
          return Array.from(new Set(tagList));
        },
        getAllTags: function(state) {
          return () => this.getTagsByNode(state.allPageData);
        },
        getActiveNodeRound: function(state) {
          return (change) => {
            var _a;
            if (!state.activeNode)
              return null;
            const nodeList = state.activeNode.type === "section" ? state.allPageData : (_a = this.activeParentNode) == null ? void 0 : _a.children;
            if (!nodeList || nodeList.length === 0)
              return null;
            const index2 = nodeList == null ? void 0 : nodeList.indexOf(state.activeNode);
            if (index2 === -1)
              return null;
            const newIndex2 = index2 + change;
            if (newIndex2 < 0 || newIndex2 >= nodeList.length)
              return null;
            return nodeList[newIndex2];
          };
        },
        getAllChildNode: (state) => (node) => {
          var _a, _b, _c;
          if (!node.children)
            return [];
          const children = [...node.children];
          let i2 = 0;
          while (i2 < children.length) {
            if ((_b = (_a = children[i2]) == null ? void 0 : _a.children) == null ? void 0 : _b.length) {
              children.push(...(_c = children[i2]) == null ? void 0 : _c.children);
            }
            i2++;
          }
          return children;
        },
        activeParentNode: (state) => {
          var _a;
          return ((_a = state.activeParentChain) == null ? void 0 : _a[0]) || null;
        },
        activeNodeHide: (state) => state.activeNode ? useGroupConfig(state.activeNode, "common").hide || false : false,
        getMaterialByMaterialId: (state) => (materialId) => {
          const { section, component, template: template2 } = state.materialData;
          return [
            ...section || [],
            ...component || [],
            ...template2 || []
          ].find((item) => item.id === materialId);
        }
      },
      actions: {
        async getProjectData(id) {
          const { data: data2 } = await projectApi.get("" + id);
          const pageData = data2.page;
          this.project.name = data2.name;
          this.project.cover = data2.cover;
          this.allPageData = pageData.pageData;
          this.colorVars = pageData.colorVars;
          this.font = pageData.font;
          this.setting = pageData.setting;
        },
        async saveProjectData(id, params) {
          const body = {
            name: params.name,
            cover: params.cover,
            page: {
              pageData: this.allPageData,
              colorVars: this.colorVars,
              setting: this.setting,
              font: this.font
            }
          };
          const { data: data2 } = await projectApi.patch(id, body);
          this.project.name = data2.name;
          this.project.cover = data2.cover;
          return data2;
        },
        async getAssetsData() {
          const res = await materialApi.get("", {
            query: { section: true, component: true, template: false }
          });
          this.materialData = res.data;
        },
        async download() {
          this.allPageData;
          const res = await downloadApi.post({
            data: {
              pageData: this.allPageData,
              colorVars: this.colorVars,
              font: this.font,
              setting: this.setting
            }
          });
          return res;
        },
        async fetchSaveMaterial(params) {
          var _a;
          params.node;
          const material = this.covertMaterialNode(params);
          const res = await materialApi.patch(material);
          const list = (_a = this.materialData) == null ? void 0 : _a[material.type];
          if (list) {
            if (material.id) {
              this.materialData[material.type] = list.map((item) => {
                if (item.id === material.id) {
                  return res.data;
                }
                return item;
              });
            } else {
              this.materialData[material.type].push(res.data);
            }
          }
          return res.data;
        },
        async deleteMaterial(id) {
          await materialApi.delete(id);
          Object.values(this.materialData).forEach((list) => {
            const index2 = list == null ? void 0 : list.findIndex((item) => item.id === id);
            if (index2 > -1) {
              list.splice(index2, 1);
            }
          });
        },
        async loadTemplateData(materialId) {
          const res = await materialApi.get(materialId);
          const { page } = res.data;
          if (page) {
            this.allPageData = page.pageData;
            this.colorVars = page.colorVars;
            this.font = page.font;
            this.setting = page.setting;
          }
        },
        insertNode(dragNode, parentNode, index2, isLinkProp = false) {
          var _a;
          const newNode = this.handleInsertNode(formatNodeByUniqueName(dragNode, this.nameMap, isLinkProp));
          (_a = parentNode.children) == null ? void 0 : _a.splice(index2, 0, newNode);
          return newNode;
        },
        swapNode(parentNode, index2, targetIndex) {
          const dropZone = useDragStore().dropZone;
          if (!(parentNode == null ? void 0 : parentNode.children) || !(dropZone == null ? void 0 : dropZone.children) || dropZone.isModule)
            return;
          const node = parentNode.children[index2];
          if (!node)
            return;
          parentNode.children.splice(index2, 1);
          dropZone.children.splice(targetIndex, 0, node);
        },
        addSection(node, index2) {
          const insertIndex = index2 != null ? index2 : this.allPageData.length;
          const newSection = this.handleInsertNode(formatNodeByUniqueName(node, this.nameMap));
          this.allPageData.splice(insertIndex, 0, newSection);
          return newSection;
        },
        removeSection(node) {
          const index2 = this.allPageData.indexOf(node);
          this.allPageData.splice(index2, 1);
        },
        swapSection(index2, targetIndex) {
          const node = this.allPageData[index2];
          this.allPageData.splice(index2, 1);
          this.allPageData.splice(targetIndex, 0, node);
        },
        setActiveNode(node, parent2) {
          if (this.activeNode === node)
            return;
          this.activeNode = node || null;
          this.activeParentChain.length = 0;
        },
        setActiveParentNodeToActive() {
          if (!this.activeParentNode)
            return;
          this.activeNode = this.activeParentNode;
          this.activeParentChain.shift();
        },
        setActiveNodeChildrenToActive() {
          var _a, _b;
          if (!this.activeNode || !((_b = (_a = this.activeNode) == null ? void 0 : _a.children) == null ? void 0 : _b.length))
            return;
          this.activeParentChain.unshift(this.activeNode);
          this.activeNode = this.activeNode.children[0];
        },
        setActiveNodeToRound(change) {
          const node = this.getActiveNodeRound(change);
          if (node) {
            if (this.activeSection === this.activeNode) {
              this.activeSection = node;
              nextTick$1(() => this.activeNode = node);
            } else {
              this.activeNode = node;
            }
          }
        },
        addActiveParentChain(node) {
          var _a;
          if (node.isModule && !((_a = this.activeNode) == null ? void 0 : _a.isModule)) {
            this.activeNode = node;
            this.activeParentChain.length = 0;
          } else {
            !this.activeParentChain.includes(node) && this.activeParentChain.push(node);
          }
        },
        deleteActiveNode() {
          var _a, _b, _c, _d, _e, _f;
          if (!this.activeNode)
            return;
          if (this.activeNode.type === "section") {
            if (this.activeNode === this.activeSection) {
              this.activeSection = null;
            }
            this.removeNode(this.activeNode);
            this.removeSection(this.activeNode);
          } else {
            const index2 = (_b = (_a = this.activeParentNode) == null ? void 0 : _a.children) == null ? void 0 : _b.indexOf(this.activeNode);
            this.removeNode(this.activeNode);
            (_d = (_c = this.activeParentNode) == null ? void 0 : _c.children) == null ? void 0 : _d.splice(index2, 1);
            if ((_f = (_e = this.activeParentNode) == null ? void 0 : _e.children) == null ? void 0 : _f.length) {
              this.activeNode = this.activeParentNode.children[Math.max(0, index2 - 1)];
              return;
            }
          }
          this.activeNode = null;
          this.activeParentChain = [];
        },
        removeNode(node) {
          const children = [node].concat(this.getAllChildNode(node));
          Object.values(this.nameMap).forEach((obj) => {
            const deleteNode = children.find((c) => c.name === obj.propLink);
            if (deleteNode) {
              obj.propLink = "";
              obj.config = merge$2({}, cloneDeep(deleteNode.config), obj.config);
            }
          });
        },
        copyActiveNode() {
          var _a, _b;
          if (!this.activeNode)
            return;
          const node = this.activeNode;
          const parentNode = this.activeParentNode;
          const index2 = node.type === "section" ? (_a = this.allPageData) == null ? void 0 : _a.indexOf(node) : (_b = parentNode == null ? void 0 : parentNode.children) == null ? void 0 : _b.indexOf(node);
          this.copyNode(node, parentNode, index2, true);
        },
        copyNode(node, parentNode, index2, isLinkProp) {
          var _a;
          if (node.type === "section") {
            this.addSection(node, index2 !== void 0 ? index2 + 1 : this.allPageData.length);
          } else if (parentNode) {
            const newNode = this.insertNode(node, parentNode, index2 !== void 0 ? index2 + 1 : (_a = parentNode == null ? void 0 : parentNode.children) == null ? void 0 : _a.length, isLinkProp ? !node.isModule : false);
            nextTick$1(() => this.activeNode = newNode);
          }
        },
        setActiveSection(node) {
          this.activeSection = node;
        },
        separateActiveNode() {
          if (!this.activeNode)
            return;
          this.activeNode.isModule = false;
          Alert($t("ungroupTip"));
        },
        updateAllPageNode(pageNode) {
          this.allPageData = pageNode;
          const newNameMap = this.nameMap;
          if (this.activeNode) {
            this.activeNode = newNameMap[this.activeNode.name];
          }
          if (this.activeSection) {
            this.activeSection = newNameMap[this.activeSection.name];
          }
          if (this.activeParentChain.length) {
            this.activeParentChain = this.activeParentChain.map((node) => newNameMap[node.name]);
          }
        },
        setActiveNodeHide(hide) {
          var _a;
          if (!this.activeNode)
            return;
          if (useMobileConfig()) {
            if (!((_a = this.activeNode.config) == null ? void 0 : _a.mobile))
              this.activeNode.config.mobile = {};
            if (!this.activeNode.config.mobile.common)
              this.activeNode.config.mobile.common = { hide };
            this.activeNode.config.mobile.common.hide = hide;
          }
          if (!useMobileConfig()) {
            if (!this.activeNode.config.props.common)
              this.activeNode.config.props.common = { hide };
            this.activeNode.config.props.common.hide = hide;
          }
        },
        switchActiveNodeConfigMode(groupType) {
          var _a;
          if (!this.activeNode)
            return;
          const currentOpen = isMobileGroupConfig(this.activeNode, groupType);
          const isLink = !!this.activeNode.propLink && groupType && !useGroupConfigByNode(this.activeNode, groupType);
          let config2 = isLink ? useConfig(this.activeNode) : this.activeNode.config;
          if (!currentOpen) {
            if (!config2.mobile)
              config2.mobile = {};
            config2.mobile[groupType] = cloneDeep(config2.props[groupType]);
          } else {
            (_a = config2.mobile) == null ? true : delete _a[groupType];
          }
        },
        unlinkActiveNodeProp(includeChildren = false) {
          if (!this.activeNode)
            return;
          const list = [this.activeNode];
          while (list.length) {
            const node = list.shift();
            const linkName = node.propLink;
            if (!linkName)
              break;
            const linkNode = this.nameMap[linkName];
            const linkNodeConfig = cloneDeep(linkNode.config);
            node.config = merge$2(linkNodeConfig, node.config);
            node.propLink = "";
            if (includeChildren && Array.isArray(node.children) && node.children.length > 0) {
              list.push(...node.children);
            }
          }
        },
        unlinkActiveNodePropGroup(groupType) {
          var _a, _b;
          if (!this.activeNode)
            return;
          const node = this.activeNode;
          const linkName = node.propLink;
          if (!linkName)
            return;
          const linkNode = this.nameMap[linkName];
          if (!linkNode)
            return;
          if ((_a = linkNode.config.mobile) == null ? void 0 : _a[groupType]) {
            if (!node.config.mobile)
              node.config.mobile = {};
            node.config.mobile[groupType] = cloneDeep(linkNode.config.mobile[groupType]);
          }
          if ((_b = linkNode.config.props) == null ? void 0 : _b[groupType]) {
            node.config.props[groupType] = cloneDeep(linkNode.config.props[groupType]);
          }
        },
        setMediaFontSize(width, fontSize) {
          if (this.font.mediaFontSize[width] && fontSize === 0) {
            delete this.font.mediaFontSize[width];
          }
          if (fontSize > 0) {
            this.font.mediaFontSize[width] = fontSize;
          }
        },
        covertMaterialNode(material) {
          if (material.type === "template")
            return material;
          const node = this.covertNodeLinkToClear(material.node);
          if (node.materialId) {
            node.materialId = "";
          }
          material.node = node;
          return material;
        },
        covertNodeLinkToClear(originNode) {
          const node = cloneDeep(originNode);
          const nodeList = [node, ...this.getAllChildNode(node)];
          const nodeNameMap = {};
          const allNameMap = this.nameMap;
          nodeList.forEach((n) => nodeNameMap[n.name] = n);
          nodeList.forEach((n) => {
            if (!n.propLink || nodeNameMap[n.propLink])
              return;
            if (allNameMap[n.propLink]) {
              n.config = merge$2({}, allNameMap[n.propLink].config, n.config);
              n.propLink = "";
            }
          });
          return node;
        },
        handleInsertNode(node) {
          var _a;
          if (node.moduleDependence) {
            if (node.moduleDependence.customFontFace && !this.font.customFontFace.includes(node.moduleDependence.customFontFace)) {
              this.font.customFontFace.push(node.moduleDependence.customFontFace);
              Alert($t("fontFaceImportTip"));
            }
            if (node.moduleDependence.colorVars && ((_a = node.moduleDependence.colorVars) == null ? void 0 : _a.length) > 0) {
              const addColorVars = node.moduleDependence.colorVars.filter((c1) => !this.colorVars.find((c2) => c1.name === c2.name));
              if (addColorVars.length > 0) {
                this.colorVars.push(...addColorVars);
                Alert($t("colorVarImportTip"));
              }
            }
          }
          return node;
        },
        changeNodeName(node, name) {
          if (!node)
            return;
          for (let n in this.nameMap) {
            if (n !== node.name && this.nameMap[n].propLink === node.name) {
              this.nameMap[n].propLink = name;
            }
          }
          node.name = name;
        },
        syncNodeModuleConfig() {
          if (!this.activeNode)
            return;
          const node = this.activeNode;
          const config2 = node.config;
          if (!config2 || node.propLink || !node.materialId)
            return;
          const material = this.getMaterialByMaterialId(node.materialId);
          if (material && material.node) {
            node.isModule = material.node.isModule;
            node.moduleConfig = material.node.moduleConfig;
          }
        },
        async copyActiveNodeToClipboard(cut) {
          if (!this.activeNode)
            return;
          const node = this.covertNodeLinkToClear(this.activeNode);
          const nodeText = JSON.stringify(node);
          await copyToClipboard(nodeText);
          if (cut) {
            prevCutNode = this.activeNode;
            this.deleteActiveNode();
          }
        },
        async pasteClipboardNode(pasteToInside) {
          var _a, _b, _c;
          if (!this.activeNode)
            return;
          let node = this.activeNode;
          let parentNode = this.activeParentNode;
          let index2;
          if (pasteToInside && (node.component === "Block" && node.children)) {
            parentNode = node;
            index2 = (_a = node.children) == null ? void 0 : _a.length;
          } else {
            index2 = node.type === "section" ? (_b = this.allPageData) == null ? void 0 : _b.indexOf(node) : (_c = parentNode == null ? void 0 : parentNode.children) == null ? void 0 : _c.indexOf(node);
          }
          try {
            const text = await getClipboardText();
            if (text) {
              let pasteNode = JSON.parse(text);
              if (pasteNode.name && pasteNode.component) {
                if (pasteNode.type === "component" && !parentNode || (parentNode == null ? void 0 : parentNode.isModule))
                  return;
                const originNode = this.nameMap[pasteNode.name];
                let isLink = false;
                if (originNode && originNode.type === pasteNode.type && originNode.component === pasteNode.component && !originNode.isModule) {
                  pasteNode = originNode;
                  isLink = true;
                } else if (prevCutNode && !this.nameMap[prevCutNode.name] && prevCutNode.name === pasteNode.name && prevCutNode.component === pasteNode.component && prevCutNode.type === pasteNode.type) {
                  pasteNode = prevCutNode;
                  isLink = true;
                }
                this.copyNode(pasteNode, parentNode, index2, isLink);
                prevCutNode = null;
                return true;
              }
            }
          } catch (e) {
          }
        }
      }
    });
    const groupIconMap = {
      layout: "layout",
      size: "size",
      spacing: "spacing",
      border: "border",
      font: "font",
      background: "background",
      container: "container",
      basic: "basic",
      position: "absolute",
      event: "event",
      animation: "animation",
      effect: "effect"
    };
    const groupTitleMap = {
      common: "",
      layout: $t("layout"),
      size: $t("size"),
      spacing: $t("spacing"),
      border: $t("border"),
      font: $t("font"),
      background: $t("background"),
      container: $t("container"),
      basic: $t("basic"),
      position: $t("position"),
      event: $t("event"),
      animation: $t("animation"),
      effect: $t("effect"),
      custom: $t("custom")
    };
    const defaultGroupIcon = "basic";
    function mitt(n) {
      return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
        var i2 = n.get(t);
        i2 ? i2.push(e) : n.set(t, [e]);
      }, off: function(t, e) {
        var i2 = n.get(t);
        i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
      }, emit: function(t, e) {
        var i2 = n.get(t);
        i2 && i2.slice().map(function(n2) {
          n2(e);
        }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
          n2(t, e);
        });
      } };
    }
    const emitter = mitt();
    const _hoisted_1$U = { class: "group" };
    const _hoisted_2$E = { class: "info" };
    const _hoisted_3$w = { class: "info-op" };
    const _hoisted_4$j = ["onClick"];
    const _hoisted_5$e = { class: "content" };
    const _sfc_main$Y = /* @__PURE__ */ defineComponent({
      __name: "Group",
      props: {
        title: null,
        titleEn: null,
        groupName: null,
        icon: null,
        minimize: { type: Boolean },
        defaultCollapsed: { type: Boolean, default: true },
        canAdvanced: { type: Boolean }
      },
      setup(__props) {
        const pageStore = usePageStore();
        const { activeNode } = storeToRefs(pageStore);
        const { unlinkActiveNodePropGroup, switchActiveNodeConfigMode } = pageStore;
        const displayStore = useDisplayStore();
        const { saveGroupStatus, getGroupStatus } = displayStore;
        const groupStatusKey = computed(() => __props.title || __props.groupName);
        const showTitle = computed(() => {
          return __props.title ? lang === "en" && __props.titleEn || __props.title : __props.groupName && groupTitleMap[__props.groupName];
        });
        const status = getGroupStatus(groupStatusKey.value);
        let collapsed = ref(status ? status.collapsed : __props.defaultCollapsed);
        let showAdvanced = ref(status ? status.advanced : false);
        const showMobileConfig = computed(() => __props.groupName && useMobileConfig());
        const isMobileStyle = computed(() => isMobileGroupConfig(activeNode.value, __props.groupName));
        const handleSwitchMobileConfig = () => __props.groupName && switchActiveNodeConfigMode(__props.groupName);
        onUpdated(() => {
          saveGroupStatus(groupStatusKey.value, { collapsed: collapsed.value, advanced: showAdvanced.value });
        });
        const collapseFn = () => collapsed.value = false;
        onMounted(() => {
          emitter.on("collapseGroup", collapseFn);
        });
        onBeforeUnmount(() => {
          emitter.off("collapseGroup", collapseFn);
        });
        const iconName = computed(() => __props.icon || groupIconMap[__props.groupName] || defaultGroupIcon);
        const isLink = computed(() => {
          var _a;
          return !!((_a = activeNode.value) == null ? void 0 : _a.propLink) && __props.groupName && !useGroupConfigByNode(activeNode.value, __props.groupName);
        });
        const handleUnlinkPropGroup = () => {
          unlinkActiveNodePropGroup(__props.groupName);
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          const _directive_collapse = resolveDirective("collapse");
          return openBlock(), createElementBlock("div", _hoisted_1$U, [
            createBaseVNode("div", _hoisted_2$E, [
              createBaseVNode("span", {
                class: "title",
                onClick: _cache[0] || (_cache[0] = ($event) => !__props.minimize ? collapsed.value = !collapsed.value : null)
              }, [
                createVNode(Icon$1, {
                  class: "icon",
                  name: iconName.value,
                  size: 14
                }, null, 8, ["name"]),
                createBaseVNode("span", null, toDisplayString(showTitle.value), 1)
              ]),
              createBaseVNode("span", _hoisted_3$w, [
                isLink.value ? withDirectives((openBlock(), createBlock(Icon$1, {
                  key: 0,
                  type: "btn",
                  color: "pink",
                  size: 14,
                  name: "link-broken",
                  onClick: withModifiers(handleUnlinkPropGroup, ["stop"])
                }, null, 8, ["onClick"])), [
                  [_directive_tooltip, _ctx.$t("brokenLink")]
                ]) : createCommentVNode("", true),
                showMobileConfig.value ? withDirectives((openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(["mobile-config-text", { mobile: isMobileStyle.value }]),
                  onClick: withModifiers(handleSwitchMobileConfig, ["stop"])
                }, [
                  createTextVNode(toDisplayString(isMobileStyle.value ? _ctx.$t("configMobile") : _ctx.$t("configBoth")), 1)
                ], 10, _hoisted_4$j)), [
                  [_directive_tooltip, isMobileStyle.value ? _ctx.$t("configMobileTip") : _ctx.$t("configBothTip")]
                ]) : createCommentVNode("", true),
                !__props.minimize ? (openBlock(), createBlock(Icon$1, {
                  key: 2,
                  class: normalizeClass({ rotate: collapsed.value }),
                  onClick: _cache[1] || (_cache[1] = ($event) => collapsed.value = !collapsed.value),
                  name: "down",
                  size: 12,
                  type: "btn"
                }, null, 8, ["class"])) : createCommentVNode("", true)
              ])
            ]),
            withDirectives((openBlock(), createElementBlock("div", _hoisted_5$e, [
              renderSlot(_ctx.$slots, "default", { showAdvanced: showAdvanced.value }, void 0, true),
              __props.canAdvanced ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "advanced-switch",
                onClick: _cache[2] || (_cache[2] = ($event) => showAdvanced.value = !showAdvanced.value)
              }, [
                createBaseVNode("span", null, toDisplayString(!showAdvanced.value ? _ctx.$t("advancedOptions") : _ctx.$t("hideAdvancedOptions")), 1)
              ])) : createCommentVNode("", true)
            ])), [
              [_directive_collapse, __props.minimize || collapsed.value]
            ])
          ]);
        };
      }
    });
    const Group_vue_vue_type_style_index_0_scoped_16ac2478_lang = "";
    const Group = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__scopeId", "data-v-16ac2478"]]);
    const isUnitType = (type2) => ["%", "px", "rem", "vw"].includes(type2);
    const getUnit = (s) => {
      if (!s || typeof s !== "string")
        return "";
      if (s.slice(-3) === "rem") {
        return "rem";
      }
      if (s.slice(-2) === "px") {
        return "px";
      }
      if (s.slice(-2) === "vw") {
        return "vw";
      }
      if (s.slice(-1) === "%") {
        return "%";
      }
      return "";
    };
    const fixedPointToNumber = (s, decimal = 2) => +(parseFloat("" + s) || 0).toFixed(decimal);
    const fixedPoint = (s) => {
      const unit = getUnit(s);
      if (!unit)
        return s;
      return fixedPointToNumber(s.slice(0, -unit.length)) + unit;
    };
    const covertPXToUnit = (s, unit, referSiz) => {
      if (!isUnitType(unit))
        return s;
      const nowUnit = getUnit(s);
      if (nowUnit !== "px")
        return s;
      else if (unit === "px")
        return s;
      else if (unit === "rem")
        return `${fixedPointToNumber(parseFloat(s) / useDisplayStore().curFootSize)}rem`;
      else if (unit === "%")
        return `${fixedPointToNumber(parseFloat(s) / (referSiz || 100) * 100)}%`;
      else if (unit === "vw")
        return `${fixedPointToNumber(parseFloat(s) * (100 / useDisplayStore().device.width))}vw`;
      return s;
    };
    const covertSize = (s, options) => {
      if (!s)
        return s;
      const unit = getUnit(s);
      const n = parseFloat(s);
      const { isSection = false, type: type2 = "" } = options || {};
      const isEditMode = getIsEditMode();
      switch (unit) {
        case "%":
          if (!type2)
            return s;
          return isEditMode ? isSection ? `${useDisplayStore().device[type2] * (n / 100)}px` : s : isSection ? `${n}${type2 === "height" ? "vh" : "vw"}` : s;
        case "rem":
          return isEditMode ? `${useDisplayStore().curFootSize * n}px` : s;
        case "vw":
          return isEditMode ? `${n / (100 / useDisplayStore().device.width)}px` : s;
        case "px":
        default:
          return s;
      }
    };
    window.covertSize = covertSize;
    const covertSizeToOtherUnit = (n, oldUnit, newUnit) => {
      if (!n || !isUnitType(oldUnit) || !isUnitType(newUnit) || oldUnit === newUnit)
        return n;
      if (oldUnit === "px") {
        if (newUnit === "rem")
          return fixedPointToNumber(n / useDisplayStore().curFootSize);
        if (newUnit === "vw")
          return fixedPointToNumber(n * (100 / useDisplayStore().device.width));
        return n;
      }
      const toPx = oldUnit === "rem" ? fixedPointToNumber(n * useDisplayStore().curFootSize) : oldUnit === "vw" ? fixedPointToNumber(n / (100 / useDisplayStore().device.width)) : n;
      if (newUnit === "vw" || newUnit === "rem")
        return covertSizeToOtherUnit(toPx, "px", newUnit);
      return toPx;
    };
    const _hoisted_1$T = { ref: "el" };
    const _sfc_main$X = /* @__PURE__ */ defineComponent({
      __name: "Dropdown",
      props: {
        type: { default: "default" },
        disabled: { type: Boolean },
        triggers: { default: () => ["click"] },
        placement: { default: "bottom-end" },
        popperClass: { default: "" },
        delay: null,
        isMenu: { type: Boolean },
        showGroup: null,
        distance: { default: 5 }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          const _directive_click_outside = resolveDirective("click-outside");
          return openBlock(), createBlock(resolveDynamicComponent(unref$1(Dropdown)), mergeProps({
            disabled: __props.disabled,
            triggers: __props.triggers,
            class: "dropdown-handle",
            popperClass: ["dropdown-popper", `dropdown-popper-${__props.type}`, __props.popperClass],
            distance: __props.distance,
            "arrow-padding": 10,
            placement: __props.placement,
            delay: __props.delay,
            "instant-move": !!__props.isMenu,
            "show-group": __props.showGroup,
            "auto-hide": !__props.isMenu
          }, _ctx.$attrs), {
            default: withCtx(({ shown }) => [
              renderSlot(_ctx.$slots, "default", { shown })
            ]),
            popper: withCtx(({ hide }) => [
              withDirectives((openBlock(), createElementBlock("div", _hoisted_1$T, [
                renderSlot(_ctx.$slots, "content", { hide })
              ])), [
                [
                  _directive_click_outside,
                  __props.isMenu ? {
                    handler: () => hide(),
                    extraSelectors: [".dropdown-popper", ".dropdown-handle.v-popper--shown"]
                  } : null
                ]
              ])
            ]),
            _: 3
          }, 16, ["disabled", "triggers", "popperClass", "distance", "placement", "delay", "instant-move", "show-group", "auto-hide"]);
        };
      }
    });
    const Dropdown_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$S = { class: "select-value" };
    const _hoisted_2$D = {
      class: /* @__PURE__ */ normalizeClass(["select-option-wrapper"])
    };
    const _hoisted_3$v = ["onClick"];
    const _sfc_main$W = /* @__PURE__ */ defineComponent({
      __name: "Select",
      props: {
        display: { default: "block" },
        placement: null,
        modelValue: null,
        container: null,
        disabled: { type: Boolean },
        distance: null,
        options: null
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const showValue = computed(() => {
          const value = __props.options[__props.modelValue] || __props.modelValue;
          if (typeof value === "string") {
            return value || "";
          }
          return value.title || "";
        });
        const handleChange = (val) => {
          emit("update:model-value", val);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$X, {
            type: "pure",
            placement: __props.placement,
            disabled: __props.disabled,
            container: __props.container,
            distance: __props.distance
          }, {
            content: withCtx(({ hide }) => [
              createBaseVNode("div", _hoisted_2$D, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (label, key) => {
                  return openBlock(), createElementBlock("div", {
                    key,
                    class: normalizeClass(["select-option", { active: key === __props.modelValue, "has-icon": label == null ? void 0 : label.icon }]),
                    onClick: withModifiers(() => {
                      handleChange(key);
                      hide();
                    }, ["stop"])
                  }, [
                    renderSlot(_ctx.$slots, "item", { item: label }, () => [
                      typeof label === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        createTextVNode(toDisplayString(label), 1)
                      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        label.icon ? (openBlock(), createBlock(Icon$1, {
                          key: 0,
                          class: "option-icon",
                          name: label.icon,
                          size: 11
                        }, null, 8, ["name"])) : createCommentVNode("", true),
                        createBaseVNode("div", null, toDisplayString(label.title), 1)
                      ], 64))
                    ], true)
                  ], 10, _hoisted_3$v);
                }), 128))
              ])
            ]),
            default: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(["select", `select-display-${__props.display}`, { disabled: __props.disabled }])
              }, [
                renderSlot(_ctx.$slots, "value", { value: showValue.value }, () => [
                  createBaseVNode("div", _hoisted_1$S, [
                    createTextVNode(toDisplayString(showValue.value) + " ", 1),
                    __props.display === "text" ? (openBlock(), createBlock(Icon$1, {
                      key: 0,
                      class: "select-icon",
                      name: "down",
                      size: 8
                    })) : createCommentVNode("", true)
                  ])
                ], true)
              ], 2)
            ]),
            _: 3
          }, 8, ["placement", "disabled", "container", "distance"]);
        };
      }
    });
    const Select_vue_vue_type_style_index_0_scoped_8457b226_lang = "";
    const Select_vue_vue_type_style_index_1_lang = "";
    const Select = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__scopeId", "data-v-8457b226"]]);
    const _hoisted_1$R = {
      key: 0,
      class: "prefix"
    };
    const __default__$5 = {
      inheritAttrs: false
    };
    const _sfc_main$V = /* @__PURE__ */ defineComponent({
      ...__default__$5,
      __name: "Input",
      props: {
        type: { default: "text" },
        modelValue: { default: "" },
        disabled: { type: Boolean },
        prefix: { default: "" },
        suffix: null,
        placeholder: null,
        realTime: { type: Boolean },
        hideSuffix: { type: Boolean },
        autoFocus: { type: Boolean },
        onBlur: null,
        onFocus: null
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        var _a, _b;
        let inputValue = ref(__props.modelValue);
        let suffixInValue = ref((_b = (_a = __props.suffix) == null ? void 0 : _a[0]) != null ? _b : "");
        let focus = ref(false);
        let inputRef = ref(null);
        let memoryNumberValue = ref(0);
        const suffixMap = {
          px: "px",
          "%": "%",
          rem: "rem",
          x: "\xD7",
          vw: "vw",
          circle: $t("unitCircle"),
          refined: $t("unitRefined"),
          auto: $t("unitAuto"),
          none: $t("unitNone"),
          stretch: $t("unitStretch")
        };
        const hideInput = computed(() => __props.type === "number" && !isUnitType(suffixInValue.value));
        const getSuffixText = computed(() => (suffixType) => {
          return suffixMap[suffixType];
        });
        const getValueBySuffix = computed(() => (suffixType) => {
          const getVal = () => covertSizeToOtherUnit(fixedPointToNumber(inputValue.value) || memoryNumberValue.value, suffixInValue.value, suffixType);
          return (__props.prefix || "") + ({
            px: `${getVal()}px`,
            "%": `${getVal()}%`,
            rem: `${getVal()}rem`,
            vw: `${getVal()}vw`,
            x: `${getVal()}x`,
            circle: "circle",
            refined: "refined",
            auto: "auto",
            none: "none",
            stretch: "stretch"
          }[suffixType] || inputValue.value);
        });
        watchEffect(() => {
          let newValue = __props.modelValue;
          if (__props.suffix && __props.suffix.length > 0 && __props.modelValue) {
            if (suffixInValue.value)
              ;
            else {
              suffixInValue.value = __props.suffix[0];
            }
            let newSuffixInValue = suffixInValue.value;
            __props.suffix.some((s) => {
              if (__props.modelValue.slice(-s.length) === s) {
                newSuffixInValue = s;
                return true;
              }
            });
            if (newSuffixInValue !== suffixInValue.value) {
              memoryNumberValue.value = !isUnitType(newSuffixInValue) ? fixedPointToNumber(inputValue.value) || 0 : memoryNumberValue.value;
              suffixInValue.value = newSuffixInValue;
            }
            newValue = __props.modelValue.slice(0, -suffixInValue.value.length);
          }
          if (__props.prefix) {
            newValue = newValue.slice(__props.prefix.length);
          }
          inputValue.value = newValue;
        });
        const handleChange = (event) => {
          const target = event.target;
          let value = target.value;
          if (__props.type === "number") {
            value = "" + (parseFloat(value) || 0);
          }
          inputValue.value = value;
          emit("update:model-value", getValueBySuffix.value(suffixInValue.value));
        };
        const handleSuffixClick = (key) => {
          emit("update:model-value", getValueBySuffix.value(key));
          nextTick$1(() => {
            var _a2, _b2;
            return (_b2 = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b2.call(_a2);
          });
        };
        const handleInput = (e) => __props.realTime && handleChange(e);
        const handleFocus = (e) => {
          var _a2;
          focus.value = true;
          (_a2 = __props.onFocus) == null ? void 0 : _a2.call(__props, e);
        };
        const handleBlur = (e) => {
          var _a2;
          focus.value = false;
          (_a2 = __props.onBlur) == null ? void 0 : _a2.call(__props, e);
          handleChange(e);
        };
        onMounted(() => {
          var _a2;
          if (__props.autoFocus)
            (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["input-wrapper", { disabled: __props.disabled, focus: focus.value }, _ctx.$attrs.class || ""])
          }, [
            __props.prefix ? (openBlock(), createElementBlock("span", _hoisted_1$R, toDisplayString(__props.prefix), 1)) : createCommentVNode("", true),
            withDirectives((openBlock(), createBlock(resolveDynamicComponent(__props.type === "textarea" ? "textarea" : "input"), mergeProps({
              ref_key: "inputRef",
              ref: inputRef,
              type: "text",
              value: inputValue.value,
              disabled: __props.disabled,
              placeholder: __props.placeholder,
              rows: 4
            }, _ctx.$attrs, {
              onKeydown: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onKeyup: withKeys(handleChange, ["enter"]),
              onFocus: handleFocus,
              onBlur: handleBlur,
              onInput: withModifiers(handleInput, ["stop", "prevent"])
            }), null, 16, ["value", "disabled", "placeholder", "onKeyup", "onInput"])), [
              [vShow, !hideInput.value]
            ]),
            renderSlot(_ctx.$slots, "suffix", {}, () => [
              suffixInValue.value && __props.suffix && !__props.hideSuffix ? (openBlock(), createBlock(Select, {
                key: 0,
                display: "inline",
                class: normalizeClass(hideInput.value ? "suffix-select-hide-input" : "suffix-select"),
                "model-value": suffixInValue.value,
                options: Object.fromEntries(__props.suffix.map((s) => [s, getSuffixText.value(s)])),
                disabled: __props.disabled || __props.suffix.length <= 1,
                "onUpdate:modelValue": handleSuffixClick
              }, null, 8, ["class", "model-value", "options", "disabled"])) : createCommentVNode("", true)
            ], true)
          ], 2);
        };
      }
    });
    const Input_vue_vue_type_style_index_0_scoped_70bc6daa_lang = "";
    const Input = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["__scopeId", "data-v-70bc6daa"]]);
    const _hoisted_1$Q = {
      key: 0,
      class: "label"
    };
    const _hoisted_2$C = { class: "label-suffix" };
    const __default__$4 = {
      inheritAttrs: false
    };
    const _sfc_main$U = /* @__PURE__ */ defineComponent({
      ...__default__$4,
      __name: "InputItem",
      props: {
        label: null,
        modelValue: null,
        type: null,
        realTime: { type: Boolean },
        onFocus: null,
        onBlur: null,
        wrapperClass: null,
        tip: null
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const props = __props;
        const __$temp_1 = props, label = toRef(__$temp_1, "label"), modelValue = toRef(__$temp_1, "modelValue"), type2 = toRef(__$temp_1, "type"), realTime = toRef(__$temp_1, "realTime"), wrapperClass = toRef(__$temp_1, "wrapperClass"), tip = toRef(__$temp_1, "tip"), onFocus = toRef(__$temp_1, "onFocus"), onBlur = toRef(__$temp_1, "onBlur");
        const value = computed({
          get: () => modelValue.value,
          set: (val) => {
            emit("update:model-value", val);
          }
        });
        let preValue = ref("");
        const handleFocus = (e) => {
          var _a;
          (_a = onFocus.value) == null ? void 0 : _a.call(onFocus, e);
        };
        const handleBlur = (e) => {
          var _a;
          if (modelValue.value !== preValue.value) {
            emitter.emit("saveHistory");
          }
          (_a = onBlur.value) == null ? void 0 : _a.call(onBlur, e);
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["item", { column: type2.value === "textarea" }, wrapperClass.value])
          }, [
            label.value ? (openBlock(), createElementBlock("span", _hoisted_1$Q, [
              renderSlot(_ctx.$slots, "label", { label: label.value }, () => [
                createTextVNode(toDisplayString(label.value), 1)
              ], true),
              tip.value ? withDirectives((openBlock(), createBlock(Icon$1, {
                key: 0,
                name: "question",
                class: "question-icon",
                size: 13
              }, null, 512)), [
                [_directive_tooltip, {
                  content: tip.value
                }]
              ]) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_2$C, [
                renderSlot(_ctx.$slots, "label-suffix", {}, void 0, true)
              ])
            ])) : createCommentVNode("", true),
            createVNode(Input, mergeProps({
              class: "input",
              modelValue: value.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event),
              type: type2.value,
              "real-time": realTime.value,
              "on-focus": handleFocus,
              "on-blur": handleBlur
            }, _ctx.$attrs), {
              suffix: withCtx(() => [
                renderSlot(_ctx.$slots, "suffix", {}, void 0, true)
              ]),
              _: 3
            }, 16, ["modelValue", "type", "real-time"]),
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 2);
        };
      }
    });
    const InputItem_vue_vue_type_style_index_0_scoped_40e79979_lang = "";
    const InputItem = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__scopeId", "data-v-40e79979"]]);
    const scriptRel = "modulepreload";
    const assetsURL = function(dep) {
      return "/site/" + dep;
    };
    const seen = {};
    const __vitePreload = function preload(baseModule, deps, importerUrl) {
      if (!deps || deps.length === 0) {
        return baseModule();
      }
      return Promise.all(deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen)
          return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
          link.crossOrigin = "";
        }
        link.href = dep;
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
          });
        }
      })).then(() => baseModule());
    };
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
    const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    function validate(uuid) {
      return typeof uuid === "string" && REGEX.test(uuid);
    }
    var byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify(arr) {
      var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
      if (!validate(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    function v4(options, buf, offset2) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset2 = offset2 || 0;
        for (var i2 = 0; i2 < 16; ++i2) {
          buf[offset2 + i2] = rnds[i2];
        }
        return buf;
      }
      return stringify(rnds);
    }
    const getClient = async () => {
      const OSS = (await __vitePreload(() => import("./aliyun-oss-sdk.629ad0ad.js").then((n) => n.a), true ? ["assets/aliyun-oss-sdk.629ad0ad.js","assets/lodash.f70a6700.js"] : void 0)).default;
      const client = new OSS({
        region: "oss-cn-shanghai",
        accessKeyId: "LTAI5tKHL8vmNGSxc3zbwxoD",
        accessKeySecret: "hJ5z4JyZOfeIY0d2FLPhyayeu1jiz9",
        bucket: "peasy"
      });
      return client;
    };
    const upload = async (file) => {
      try {
        const client = await getClient();
        const res = await client.put(v4(), file);
        return res.url;
      } catch (e) {
        alert(e);
      }
    };
    const uploadByBase64 = async (base64) => {
      var _a;
      try {
        let arr = base64.split(",");
        let mime = (_a = arr[0].match(/:(.*?);/)) == null ? void 0 : _a[1];
        let bstr = atob(arr[1]);
        let n = bstr.length;
        let u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        const blob = new File([u8arr], "image.png", { type: mime });
        return await upload(blob);
      } catch (e) {
        console.error(e);
        AlertError($t("imageError"));
      }
    };
    const uploadByEvent = async (e, cb) => {
      const files = e.target.files;
      if (files == null ? void 0 : files[0]) {
        if (files[0].size <= 10 * 1024) {
          var reader = new FileReader();
          reader.readAsDataURL(files[0]);
          reader.onload = function(e2) {
            cb(reader.result);
          };
        } else {
          const url = await upload(files[0]);
          cb(url);
        }
      }
      e.target.value = "";
    };
    const _hoisted_1$P = { class: "upload-wrapper" };
    const _hoisted_2$B = { class: "upload-btn" };
    const _hoisted_3$u = ["accept"];
    const _hoisted_4$i = ["src"];
    const _hoisted_5$d = {
      key: 1,
      class: "cover"
    };
    const _sfc_main$T = /* @__PURE__ */ defineComponent({
      __name: "ImageItem",
      props: {
        label: null,
        modelValue: null,
        hideLabel: { type: Boolean },
        placeholder: { default: "https://" },
        accept: { default: "image/*" },
        loading: { type: Boolean }
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        let showCover = ref(!!__props.modelValue);
        let coverUrl = ref(__props.modelValue);
        const handleChange = (img) => {
          emit("update:model-value", img);
          emitter.emit("saveHistory");
        };
        watch(() => __props.modelValue, () => {
          coverUrl.value = __props.modelValue;
          if (coverUrl.value) {
            showCover.value = true;
          }
        }, { immediate: true });
        const uploadImage = async (e) => {
          uploadByEvent(e, handleChange);
        };
        const handleCoverError = () => {
          AlertError($t("imageLoadError"));
          coverUrl.value = imgErrorFallback;
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createBlock(InputItem, mergeProps({
            "wrapper-class": "image-item",
            "model-value": __props.modelValue,
            label: __props.label,
            type: "textarea",
            placeholder: __props.placeholder
          }, _ctx.$attrs, { "onUpdate:modelValue": handleChange }), createSlots({
            suffix: withCtx(() => [
              createBaseVNode("div", _hoisted_1$P, [
                __props.modelValue ? (openBlock(), createBlock(Icon$1, {
                  key: 0,
                  class: "preview-btn",
                  name: "preview",
                  type: "circle",
                  color: "primary",
                  size: 13,
                  onClick: _cache[0] || (_cache[0] = ($event) => showCover.value = !showCover.value)
                })) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_2$B, [
                  createTextVNode(toDisplayString(unref$1($t)("upload")) + " ", 1),
                  createBaseVNode("input", {
                    type: "file",
                    class: "upload-btn-input",
                    accept: __props.accept,
                    onChange: uploadImage
                  }, null, 40, _hoisted_3$u)
                ]),
                withDirectives(createVNode(Icon$1, {
                  name: "question",
                  class: "question-icon",
                  size: 13
                }, null, 512), [
                  [_directive_tooltip, {
                    showTriggers: ["click"],
                    hideTriggers: ["click", "hover"],
                    content: unref$1($t)("uploadTip")
                  }]
                ])
              ]),
              showCover.value && coverUrl.value && !__props.loading ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "cover",
                onClick: _cache[1] || (_cache[1] = ($event) => showCover.value = false)
              }, [
                createBaseVNode("img", {
                  src: coverUrl.value,
                  onError: handleCoverError
                }, null, 40, _hoisted_4$i)
              ])) : createCommentVNode("", true),
              __props.loading ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
                createVNode(Icon$1, {
                  name: "spin",
                  size: 32,
                  loading: ""
                })
              ])) : createCommentVNode("", true)
            ]),
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ]),
            _: 2
          }, [
            !__props.hideLabel ? {
              name: "label",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "label", {}, void 0, true)
              ])
            } : void 0
          ]), 1040, ["model-value", "label", "placeholder"]);
        };
      }
    });
    const ImageItem_vue_vue_type_style_index_0_scoped_facf9478_lang = "";
    const ImageItem = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__scopeId", "data-v-facf9478"]]);
    const _hoisted_1$O = { class: "label" };
    const _sfc_main$S = /* @__PURE__ */ defineComponent({
      __name: "SelectItem",
      props: {
        label: null,
        modelValue: null,
        wrapperClass: null,
        options: null
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const value = computed({
          get: () => __props.modelValue,
          set: (val) => {
            emit("update:model-value", val);
            __props.modelValue !== val && emitter.emit("saveHistory");
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["item", __props.wrapperClass])
          }, [
            createBaseVNode("div", _hoisted_1$O, toDisplayString(__props.label), 1),
            createVNode(Select, mergeProps({
              modelValue: value.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event),
              options: __props.options
            }, _ctx.$attrs), {
              item: withCtx(({ item }) => [
                renderSlot(_ctx.$slots, "item", { item }, void 0, true)
              ]),
              _: 3
            }, 16, ["modelValue", "options"]),
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 2);
        };
      }
    });
    const SelectItem_vue_vue_type_style_index_0_scoped_67d49b67_lang = "";
    const SelectItem = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__scopeId", "data-v-67d49b67"]]);
    const prefix = "";
    function styleInject(css2, ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var insertAt = ref2.insertAt;
      if (!css2 || typeof document === "undefined") {
        return;
      }
      var head = document.head || document.getElementsByTagName("head")[0];
      var style2 = document.createElement("style");
      style2.type = "text/css";
      if (insertAt === "top") {
        if (head.firstChild) {
          head.insertBefore(style2, head.firstChild);
        } else {
          head.appendChild(style2);
        }
      } else {
        head.appendChild(style2);
      }
      if (style2.styleSheet) {
        style2.styleSheet.cssText = css2;
      } else {
        style2.appendChild(document.createTextNode(css2));
      }
    }
    const install = function(app2, options) {
      const { componentPrefix = prefix } = options || {};
      app2.component(`${componentPrefix}${this.name}`, this);
    };
    const _checkboardCache = {};
    var script$5 = {
      name: "Checkboard",
      props: {
        size: {
          type: [Number, String],
          default: 8
        },
        white: {
          type: String,
          default: "#fff"
        },
        grey: {
          type: String,
          default: "#e6e6e6"
        }
      },
      computed: {
        bgStyle() {
          return {
            "background-image": `url(${getCheckboard(this.white, this.grey, this.size)})`
          };
        }
      }
    };
    function renderCheckboard(c1, c2, size2) {
      if (typeof document === "undefined") {
        return null;
      }
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size2 * 2;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return null;
      }
      ctx.fillStyle = c1;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = c2;
      ctx.fillRect(0, 0, size2, size2);
      ctx.translate(size2, size2);
      ctx.fillRect(0, 0, size2, size2);
      return canvas.toDataURL();
    }
    function getCheckboard(c1, c2, size2) {
      const key = `${c1},${c2},${size2}`;
      if (_checkboardCache[key]) {
        return _checkboardCache[key];
      }
      const checkboard = renderCheckboard(c1, c2, size2);
      _checkboardCache[key] = checkboard;
      return checkboard;
    }
    function render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: "vc-checkerboard",
        style: normalizeStyle($options.bgStyle)
      }, null, 4);
    }
    var css_248z$5 = ".vc-checkerboard{background-size:contain;bottom:0;left:0;position:absolute;right:0;top:0}";
    styleInject(css_248z$5);
    script$5.render = render$5;
    script$5.__file = "src/components/checkboard/checkboard.vue";
    script$5.install = install;
    var script$4 = {
      name: "Alpha",
      props: {
        value: Object,
        onChange: Function
      },
      components: {
        checkboard: script$5
      },
      computed: {
        colors() {
          return this.value;
        },
        gradientColor() {
          const { rgba } = this.colors;
          const rgbStr = [rgba.r, rgba.g, rgba.b].join(",");
          return `linear-gradient(to right, rgba(${rgbStr}, 0) 0%, rgba(${rgbStr}, 1) 100%)`;
        }
      },
      methods: {
        handleChange(e, skip) {
          !skip && e.preventDefault();
          const { container } = this.$refs;
          if (!container) {
            return;
          }
          const containerWidth = container.clientWidth;
          const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
          const pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
          const left = pageX - xOffset;
          let a;
          if (left < 0) {
            a = 0;
          } else if (left > containerWidth) {
            a = 1;
          } else {
            a = Math.round(left * 100 / containerWidth) / 100;
          }
          if (this.colors.a !== a) {
            this.$emit("change", {
              h: this.colors.hsl.h,
              s: this.colors.hsl.s,
              l: this.colors.hsl.l,
              a,
              source: "rgba"
            });
          }
        },
        handleMouseDown(e) {
          this.handleChange(e, true);
          window.addEventListener("mousemove", this.handleChange);
          window.addEventListener("mouseup", this.handleMouseUp);
        },
        handleMouseUp() {
          this.unbindEventListeners();
        },
        unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }
    };
    const _hoisted_1$N = { class: "vc-alpha" };
    const _hoisted_2$A = { class: "vc-alpha-checkboard-wrap" };
    const _hoisted_3$t = /* @__PURE__ */ createBaseVNode("div", { class: "vc-alpha-picker" }, null, -1);
    const _hoisted_4$h = [
      _hoisted_3$t
    ];
    function render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_checkboard = resolveComponent("checkboard");
      return openBlock(), createElementBlock("div", _hoisted_1$N, [
        createBaseVNode("div", _hoisted_2$A, [
          createVNode(_component_checkboard)
        ]),
        createBaseVNode("div", {
          class: "vc-alpha-gradient",
          style: normalizeStyle({ background: $options.gradientColor })
        }, null, 4),
        createBaseVNode("div", {
          class: "vc-alpha-container",
          ref: "container",
          onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
          onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
          onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
        }, [
          createBaseVNode("div", {
            class: "vc-alpha-pointer",
            style: normalizeStyle({ left: $options.colors.a * 100 + "%" })
          }, _hoisted_4$h, 4)
        ], 544)
      ]);
    }
    var css_248z$4 = ".vc-alpha,.vc-alpha-checkboard-wrap{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-checkboard-wrap{overflow:hidden}.vc-alpha-gradient{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-container{cursor:pointer;height:100%;margin:0 3px;position:relative;z-index:2}.vc-alpha-pointer{position:absolute;z-index:2}.vc-alpha-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
    styleInject(css_248z$4);
    script$4.render = render$4;
    script$4.__file = "src/components/alpha/alpha.vue";
    script$4.install = install;
    function bound01(n, max2) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var isPercent = isPercentage(n);
      n = max2 === 360 ? n : Math.min(max2, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max2), 10) / 100;
      }
      if (Math.abs(n - max2) < 1e-6) {
        return 1;
      }
      if (max2 === 360) {
        n = (n < 0 ? n % max2 + max2 : n % max2) / parseFloat(String(max2));
      } else {
        n = n % max2 / parseFloat(String(max2));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c) {
      return c.length === 1 ? "0" + c : String(c);
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max2 = Math.max(r, g, b);
      var min2 = Math.min(r, g, b);
      var h2 = 0;
      var s = 0;
      var l = (max2 + min2) / 2;
      if (max2 === min2) {
        s = 0;
        h2 = 0;
      } else {
        var d = max2 - min2;
        s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
        switch (max2) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l };
    }
    function hue2rgb(p2, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q - p2) * (6 * t);
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p2 + (q - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s, l) {
      var r;
      var g;
      var b;
      h2 = bound01(h2, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      if (s === 0) {
        g = l;
        b = l;
        r = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p2 = 2 * l - q;
        r = hue2rgb(p2, q, h2 + 1 / 3);
        g = hue2rgb(p2, q, h2);
        b = hue2rgb(p2, q, h2 - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max2 = Math.max(r, g, b);
      var min2 = Math.min(r, g, b);
      var h2 = 0;
      var v = max2;
      var d = max2 - min2;
      var s = max2 === 0 ? 0 : d / max2;
      if (max2 === min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v };
    }
    function hsvToRgb(h2, s, v) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i2 = Math.floor(h2);
      var f = h2 - i2;
      var p2 = v * (1 - s);
      var q = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      var mod = i2 % 6;
      var r = [v, q, p2, p2, t, v][mod];
      var g = [t, v, v, q, p2, p2][mod];
      var b = [p2, p2, t, v, v, q][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l);
          ok = true;
          format = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = function() {
      function TinyColor2(color, opts) {
        if (color === void 0) {
          color = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a;
        if (color instanceof TinyColor2) {
          return color;
        }
        if (typeof color === "number") {
          color = numberInputToObject(color);
        }
        this.originalInput = color;
        var rgb = inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R;
        var G;
        var B2;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R + 0.7152 * G + 0.0722 * B2;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h2 = Math.round(hsv.h * 360);
        var s = Math.round(hsv.s * 100);
        var v = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h2 = Math.round(hsl.h * 360);
        var s = Math.round(hsl.s * 100);
        var l = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r = Math.round(this.r);
        var g = Math.round(this.g);
        var b = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = function(x) {
          return "".concat(Math.round(bound01(x, 255) * 100), "%");
        };
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = function(x) {
          return Math.round(bound01(x, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
          var _b = _a[_i], key = _b[0], value = _b[1];
          if (hex === value) {
            return key;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format) {
        var formatSet = Boolean(format);
        format = format !== null && format !== void 0 ? format : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
        if (needsAlphaFormat) {
          if (format === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
          formattedString = this.toHexString();
        }
        if (format === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format === "name") {
          formattedString = this.toName();
        }
        if (format === "hsl") {
          formattedString = this.toHslString();
        }
        if (format === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color).toRgb();
        var p2 = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
          a: (rgb2.a - rgb1.a) * p2 + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h2 = hsv.h;
        var s = hsv.s;
        var v = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h: h2, s, v }));
          v = (v + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        return new TinyColor2({
          r: bg.r + (fg.r - bg.r) * fg.a,
          g: bg.g + (fg.g - bg.g) * fg.a,
          b: bg.b + (fg.b - bg.b) * fg.a
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n) {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        var result = [this];
        var increment = 360 / n;
        for (var i2 = 1; i2 < n; i2++) {
          result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor2(color).toRgbString();
      };
      return TinyColor2;
    }();
    function tinycolor(...args) {
      return new TinyColor(...args);
    }
    function _colorChange(data2, oldHue) {
      const alpha = data2 && data2.a;
      let color;
      if (data2 && data2.hsl) {
        color = tinycolor(data2.hsl);
      } else if (data2 && data2.hex && data2.hex.length > 0) {
        color = tinycolor(data2.hex);
      } else if (data2 && data2.hsv) {
        color = tinycolor(data2.hsv);
      } else if (data2 && data2.rgba) {
        color = tinycolor(data2.rgba);
      } else if (data2 && data2.rgb) {
        color = tinycolor(data2.rgb);
      } else {
        color = tinycolor(data2);
      }
      if (color && (color._a === void 0 || color._a === null)) {
        color.setAlpha(alpha || color.getAlpha());
      }
      const hsl = color.toHsl();
      const hsv = color.toHsv();
      if (hsl.s === 0) {
        hsv.h = hsl.h = data2.h || data2.hsl && data2.hsl.h || oldHue || 0;
      }
      return {
        hsl,
        hex: color.toHexString().toUpperCase(),
        hex8: color.toHex8String().toUpperCase(),
        rgba: color.toRgb(),
        hsv,
        oldHue: data2.h || oldHue || hsl.h,
        source: data2.source,
        a: color.getAlpha()
      };
    }
    var colorMixin = {
      model: {
        prop: "modelValue",
        event: "update:modelValue"
      },
      props: ["modelValue"],
      data() {
        return {
          val: _colorChange(this.modelValue)
        };
      },
      computed: {
        colors: {
          get() {
            return this.val;
          },
          set(newVal) {
            this.val = newVal;
            this.$emit("update:modelValue", newVal);
          }
        }
      },
      watch: {
        modelValue(newVal) {
          this.val = _colorChange(newVal);
        }
      },
      methods: {
        colorChange(data2, oldHue) {
          this.oldHue = this.colors.hsl.h;
          this.colors = _colorChange(data2, oldHue || this.oldHue);
        },
        isValidHex(hex) {
          return tinycolor(hex).isValid;
        },
        simpleCheckForValidColor(data2) {
          const keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
          let checked = 0;
          let passed = 0;
          for (let i2 = 0; i2 < keysToCheck.length; i2++) {
            const letter = keysToCheck[i2];
            if (data2[letter]) {
              checked++;
              if (!isNaN(data2[letter])) {
                passed++;
              }
            }
          }
          if (checked === passed) {
            return data2;
          }
        },
        paletteUpperCase(palette) {
          return palette.map((c) => c.toUpperCase());
        },
        isTransparent(color) {
          return tinycolor(color).getAlpha() === 0;
        }
      }
    };
    var script$3 = {
      name: "editableInput",
      props: {
        label: String,
        labelText: String,
        desc: String,
        value: [String, Number],
        max: Number,
        min: Number,
        arrowOffset: {
          type: Number,
          default: 1
        }
      },
      computed: {
        val: {
          get() {
            return this.value;
          },
          set(v) {
            if (!(this.max === void 0) && +v > this.max) {
              this.$refs.input.value = this.max;
            } else {
              return v;
            }
          }
        },
        labelId() {
          return `input__label__${this.label}__${Math.random().toString().slice(2, 5)}`;
        },
        labelSpanText() {
          return this.labelText || this.label;
        }
      },
      methods: {
        update(e) {
          this.handleChange(e.target.value);
        },
        handleChange(newVal) {
          const data2 = {};
          data2[this.label] = newVal;
          if (data2.hex === void 0 && data2["#"] === void 0) {
            this.$emit("change", data2);
          } else if (newVal.length > 5) {
            this.$emit("change", data2);
          }
        },
        handleKeyDown(e) {
          let { val } = this;
          const number2 = Number(val);
          if (number2) {
            const amount = this.arrowOffset || 1;
            if (e.keyCode === 38) {
              val = number2 + amount;
              this.handleChange(val);
              e.preventDefault();
            }
            if (e.keyCode === 40) {
              val = number2 - amount;
              this.handleChange(val);
              e.preventDefault();
            }
          }
        }
      }
    };
    const _hoisted_1$M = { class: "vc-editable-input" };
    const _hoisted_2$z = ["aria-labelledby"];
    const _hoisted_3$s = ["for", "id"];
    const _hoisted_4$g = { class: "vc-input__desc" };
    function render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$M, [
        withDirectives(createBaseVNode("input", {
          "aria-labelledby": $options.labelId,
          class: "vc-input__input",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.val = $event),
          onKeydown: _cache[1] || (_cache[1] = (...args) => $options.handleKeyDown && $options.handleKeyDown(...args)),
          onInput: _cache[2] || (_cache[2] = (...args) => $options.update && $options.update(...args)),
          ref: "input"
        }, null, 40, _hoisted_2$z), [
          [vModelText, $options.val]
        ]),
        createBaseVNode("span", {
          for: $props.label,
          class: "vc-input__label",
          id: $options.labelId
        }, toDisplayString($options.labelSpanText), 9, _hoisted_3$s),
        createBaseVNode("span", _hoisted_4$g, toDisplayString($props.desc), 1)
      ]);
    }
    var css_248z$3 = ".vc-editable-input{position:relative}.vc-input__input{border:0;outline:none;padding:0}.vc-input__label{text-transform:capitalize}";
    styleInject(css_248z$3);
    script$3.render = render$3;
    script$3.__file = "src/components/editable-input/editable-input.vue";
    script$3.install = install;
    function clamp(value, min2, max2) {
      return min2 < max2 ? value < min2 ? min2 : value > max2 ? max2 : value : value < max2 ? max2 : value > min2 ? min2 : value;
    }
    var script$2 = {
      name: "Saturation",
      props: {
        value: Object
      },
      computed: {
        colors() {
          return this.value;
        },
        bgColor() {
          return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
        },
        pointerTop() {
          return `${-(this.colors.hsv.v * 100) + 1 + 100}%`;
        },
        pointerLeft() {
          return `${this.colors.hsv.s * 100}%`;
        }
      },
      methods: {
        throttle: throttle$2((fn, data2) => {
          fn(data2);
        }, 20, {
          leading: true,
          trailing: false
        }),
        handleChange(e, skip) {
          !skip && e.preventDefault();
          const { container } = this.$refs;
          if (!container) {
            return;
          }
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
          const yOffset = container.getBoundingClientRect().top + window.pageYOffset;
          const pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
          const pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
          const left = clamp(pageX - xOffset, 0, containerWidth);
          const top = clamp(pageY - yOffset, 0, containerHeight);
          const saturation = left / containerWidth;
          const bright = clamp(-(top / containerHeight) + 1, 0, 1);
          this.throttle(this.onChange, {
            h: this.colors.hsv.h,
            s: saturation,
            v: bright,
            a: this.colors.hsv.a,
            source: "hsva"
          });
        },
        onChange(param) {
          this.$emit("change", param);
        },
        handleMouseDown(e) {
          window.addEventListener("mousemove", this.handleChange);
          window.addEventListener("mouseup", this.handleChange);
          window.addEventListener("mouseup", this.handleMouseUp);
        },
        handleMouseUp(e) {
          this.unbindEventListeners();
        },
        unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }
    };
    const _hoisted_1$L = /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation--white" }, null, -1);
    const _hoisted_2$y = /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation--black" }, null, -1);
    const _hoisted_3$r = /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation-circle" }, null, -1);
    const _hoisted_4$f = [
      _hoisted_3$r
    ];
    function render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: "vc-saturation",
        style: normalizeStyle({ background: $options.bgColor }),
        ref: "container",
        onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
        onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
        onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
      }, [
        _hoisted_1$L,
        _hoisted_2$y,
        createBaseVNode("div", {
          class: "vc-saturation-pointer",
          style: normalizeStyle({ top: $options.pointerTop, left: $options.pointerLeft })
        }, _hoisted_4$f, 4)
      ], 36);
    }
    var css_248z$2 = ".vc-saturation,.vc-saturation--black,.vc-saturation--white{bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.vc-saturation--white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.vc-saturation--black{background:linear-gradient(0deg,#000,transparent)}.vc-saturation-pointer{cursor:pointer;position:absolute}.vc-saturation-circle{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}";
    styleInject(css_248z$2);
    script$2.render = render$2;
    script$2.__file = "src/components/saturation/saturation.vue";
    script$2.install = install;
    var script$1 = {
      name: "Hue",
      props: {
        value: Object,
        direction: {
          type: String,
          default: "horizontal"
        }
      },
      data() {
        return {
          oldHue: 0,
          pullDirection: ""
        };
      },
      computed: {
        colors() {
          const { h: h2 } = this.value.hsl;
          if (h2 !== 0 && h2 - this.oldHue > 0)
            this.pullDirection = "right";
          if (h2 !== 0 && h2 - this.oldHue < 0)
            this.pullDirection = "left";
          this.oldHue = h2;
          return this.value;
        },
        directionClass() {
          return {
            "vc-hue--horizontal": this.direction === "horizontal",
            "vc-hue--vertical": this.direction === "vertical"
          };
        },
        pointerTop() {
          if (this.direction === "vertical") {
            if (this.colors.hsl.h === 0 && this.pullDirection === "right")
              return 0;
            return `${-(this.colors.hsl.h * 100 / 360) + 100}%`;
          }
          return 0;
        },
        pointerLeft() {
          if (this.direction === "vertical") {
            return 0;
          }
          if (this.colors.hsl.h === 0 && this.pullDirection === "right")
            return "100%";
          return `${this.colors.hsl.h * 100 / 360}%`;
        }
      },
      methods: {
        handleChange(e, skip) {
          !skip && e.preventDefault();
          const { container } = this.$refs;
          if (!container) {
            return;
          }
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
          const yOffset = container.getBoundingClientRect().top + window.pageYOffset;
          const pageX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
          const pageY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
          const left = pageX - xOffset;
          const top = pageY - yOffset;
          let h2;
          let percent;
          if (this.direction === "vertical") {
            if (top < 0) {
              h2 = 360;
            } else if (top > containerHeight) {
              h2 = 0;
            } else {
              percent = -(top * 100 / containerHeight) + 100;
              h2 = 360 * percent / 100;
            }
            if (this.colors.hsl.h !== h2) {
              this.$emit("change", {
                h: h2,
                s: this.colors.hsl.s,
                l: this.colors.hsl.l,
                a: this.colors.hsl.a,
                source: "hsl"
              });
            }
          } else {
            if (left < 0) {
              h2 = 0;
            } else if (left > containerWidth) {
              h2 = 360;
            } else {
              percent = left * 100 / containerWidth;
              h2 = 360 * percent / 100;
            }
            if (this.colors.hsl.h !== h2) {
              this.$emit("change", {
                h: h2,
                s: this.colors.hsl.s,
                l: this.colors.hsl.l,
                a: this.colors.hsl.a,
                source: "hsl"
              });
            }
          }
        },
        handleMouseDown(e) {
          this.handleChange(e, true);
          window.addEventListener("mousemove", this.handleChange);
          window.addEventListener("mouseup", this.handleChange);
          window.addEventListener("mouseup", this.handleMouseUp);
        },
        handleMouseUp(e) {
          this.unbindEventListeners();
        },
        unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }
    };
    const _hoisted_1$K = ["aria-valuenow"];
    const _hoisted_2$x = /* @__PURE__ */ createBaseVNode("div", { class: "vc-hue-picker" }, null, -1);
    const _hoisted_3$q = [
      _hoisted_2$x
    ];
    function render$1(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-hue", $options.directionClass])
      }, [
        createBaseVNode("div", {
          class: "vc-hue-container",
          role: "slider",
          "aria-valuenow": $options.colors.hsl.h,
          "aria-valuemin": "0",
          "aria-valuemax": "360",
          ref: "container",
          onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
          onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
          onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
        }, [
          createBaseVNode("div", {
            class: "vc-hue-pointer",
            style: normalizeStyle({ top: $options.pointerTop, left: $options.pointerLeft }),
            role: "presentation"
          }, _hoisted_3$q, 4)
        ], 40, _hoisted_1$K)
      ], 2);
    }
    var css_248z$1 = ".vc-hue{border-radius:2px;bottom:0;left:0;position:absolute;right:0;top:0}.vc-hue--horizontal{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue--vertical{background:linear-gradient(0deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue-container{cursor:pointer;height:100%;margin:0 2px;position:relative}.vc-hue-pointer{position:absolute;z-index:2}.vc-hue-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
    styleInject(css_248z$1);
    script$1.render = render$1;
    script$1.__file = "src/components/hue/hue.vue";
    script$1.install = install;
    var script = {
      name: "Chrome",
      mixins: [colorMixin],
      props: {
        disableAlpha: {
          type: Boolean,
          default: false
        },
        disableFields: {
          type: Boolean,
          default: false
        }
      },
      components: {
        saturation: script$2,
        hue: script$1,
        alpha: script$4,
        "ed-in": script$3,
        checkboard: script$5
      },
      data() {
        return {
          fieldsIndex: 0,
          highlight: false
        };
      },
      computed: {
        hsl() {
          const { h: h2, s, l } = this.colors.hsl;
          return {
            h: h2.toFixed(),
            s: `${(s * 100).toFixed()}%`,
            l: `${(l * 100).toFixed()}%`
          };
        },
        activeColor() {
          const { rgba } = this.colors;
          return `rgba(${[rgba.r, rgba.g, rgba.b, rgba.a].join(",")})`;
        },
        hasAlpha() {
          return this.colors.a < 1;
        }
      },
      methods: {
        childChange(data2) {
          this.colorChange(data2);
        },
        inputChange(data2) {
          if (!data2) {
            return;
          }
          if (data2.hex) {
            this.isValidHex(data2.hex) && this.colorChange({
              hex: data2.hex,
              source: "hex"
            });
          } else if (data2.r || data2.g || data2.b || data2.a) {
            this.colorChange({
              r: data2.r || this.colors.rgba.r,
              g: data2.g || this.colors.rgba.g,
              b: data2.b || this.colors.rgba.b,
              a: data2.a || this.colors.rgba.a,
              source: "rgba"
            });
          } else if (data2.h || data2.s || data2.l) {
            const s = data2.s ? data2.s.replace("%", "") / 100 : this.colors.hsl.s;
            const l = data2.l ? data2.l.replace("%", "") / 100 : this.colors.hsl.l;
            this.colorChange({
              h: data2.h || this.colors.hsl.h,
              s,
              l,
              source: "hsl"
            });
          }
        },
        toggleViews() {
          if (this.fieldsIndex >= 2) {
            this.fieldsIndex = 0;
            return;
          }
          this.fieldsIndex++;
        },
        showHighlight() {
          this.highlight = true;
        },
        hideHighlight() {
          this.highlight = false;
        }
      }
    };
    const _hoisted_1$J = { class: "vc-chrome-saturation-wrap" };
    const _hoisted_2$w = { class: "vc-chrome-body" };
    const _hoisted_3$p = { class: "vc-chrome-controls" };
    const _hoisted_4$e = { class: "vc-chrome-color-wrap" };
    const _hoisted_5$c = ["aria-label"];
    const _hoisted_6$b = { class: "vc-chrome-sliders" };
    const _hoisted_7$9 = { class: "vc-chrome-hue-wrap" };
    const _hoisted_8$6 = {
      key: 0,
      class: "vc-chrome-alpha-wrap"
    };
    const _hoisted_9$6 = {
      key: 0,
      class: "vc-chrome-fields-wrap"
    };
    const _hoisted_10$5 = { class: "vc-chrome-fields" };
    const _hoisted_11$4 = { class: "vc-chrome-field" };
    const _hoisted_12$3 = { class: "vc-chrome-fields" };
    const _hoisted_13$3 = { class: "vc-chrome-field" };
    const _hoisted_14$3 = { class: "vc-chrome-field" };
    const _hoisted_15$2 = { class: "vc-chrome-field" };
    const _hoisted_16$1 = {
      key: 0,
      class: "vc-chrome-field"
    };
    const _hoisted_17$1 = { class: "vc-chrome-fields" };
    const _hoisted_18$1 = { class: "vc-chrome-field" };
    const _hoisted_19$1 = { class: "vc-chrome-field" };
    const _hoisted_20$1 = { class: "vc-chrome-field" };
    const _hoisted_21$1 = {
      key: 0,
      class: "vc-chrome-field"
    };
    const _hoisted_22$1 = { class: "vc-chrome-toggle-icon" };
    const _hoisted_23$1 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "#333",
      d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
    }, null, -1);
    const _hoisted_24 = [
      _hoisted_23$1
    ];
    const _hoisted_25 = { class: "vc-chrome-toggle-icon-highlight" };
    function render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_saturation = resolveComponent("saturation");
      const _component_checkboard = resolveComponent("checkboard");
      const _component_hue = resolveComponent("hue");
      const _component_alpha = resolveComponent("alpha");
      const _component_ed_in = resolveComponent("ed-in");
      return openBlock(), createElementBlock("div", {
        role: "application",
        "aria-label": "Chrome color picker",
        class: normalizeClass(["vc-chrome", $props.disableAlpha ? "vc-chrome__disable-alpha" : ""])
      }, [
        createBaseVNode("div", _hoisted_1$J, [
          createVNode(_component_saturation, {
            value: _ctx.colors,
            onChange: $options.childChange
          }, null, 8, ["value", "onChange"])
        ]),
        createBaseVNode("div", _hoisted_2$w, [
          createBaseVNode("div", _hoisted_3$p, [
            createBaseVNode("div", _hoisted_4$e, [
              createBaseVNode("div", {
                "aria-label": `current color is ${_ctx.colors.hex}`,
                class: "vc-chrome-active-color",
                style: normalizeStyle({ background: $options.activeColor })
              }, null, 12, _hoisted_5$c),
              !$props.disableAlpha ? (openBlock(), createBlock(_component_checkboard, { key: 0 })) : createCommentVNode("v-if", true)
            ]),
            createBaseVNode("div", _hoisted_6$b, [
              createBaseVNode("div", _hoisted_7$9, [
                createVNode(_component_hue, {
                  value: _ctx.colors,
                  onChange: $options.childChange
                }, null, 8, ["value", "onChange"])
              ]),
              !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_8$6, [
                createVNode(_component_alpha, {
                  value: _ctx.colors,
                  onChange: $options.childChange
                }, null, 8, ["value", "onChange"])
              ])) : createCommentVNode("v-if", true)
            ])
          ]),
          !$props.disableFields ? (openBlock(), createElementBlock("div", _hoisted_9$6, [
            withDirectives(createBaseVNode("div", _hoisted_10$5, [
              createCommentVNode(" hex "),
              createBaseVNode("div", _hoisted_11$4, [
                !$options.hasAlpha ? (openBlock(), createBlock(_component_ed_in, {
                  key: 0,
                  label: "hex",
                  value: _ctx.colors.hex,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])) : createCommentVNode("v-if", true),
                $options.hasAlpha ? (openBlock(), createBlock(_component_ed_in, {
                  key: 1,
                  label: "hex",
                  value: _ctx.colors.hex8,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])) : createCommentVNode("v-if", true)
              ])
            ], 512), [
              [vShow, $data.fieldsIndex === 0]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_12$3, [
              createCommentVNode(" rgba "),
              createBaseVNode("div", _hoisted_13$3, [
                createVNode(_component_ed_in, {
                  label: "r",
                  value: _ctx.colors.rgba.r,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_14$3, [
                createVNode(_component_ed_in, {
                  label: "g",
                  value: _ctx.colors.rgba.g,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_15$2, [
                createVNode(_component_ed_in, {
                  label: "b",
                  value: _ctx.colors.rgba.b,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_16$1, [
                createVNode(_component_ed_in, {
                  label: "a",
                  value: _ctx.colors.a,
                  "arrow-offset": 0.01,
                  max: 1,
                  onChange: $options.inputChange
                }, null, 8, ["value", "arrow-offset", "onChange"])
              ])) : createCommentVNode("v-if", true)
            ], 512), [
              [vShow, $data.fieldsIndex === 1]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_17$1, [
              createCommentVNode(" hsla "),
              createBaseVNode("div", _hoisted_18$1, [
                createVNode(_component_ed_in, {
                  label: "h",
                  value: $options.hsl.h,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_19$1, [
                createVNode(_component_ed_in, {
                  label: "s",
                  value: $options.hsl.s,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_20$1, [
                createVNode(_component_ed_in, {
                  label: "l",
                  value: $options.hsl.l,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_21$1, [
                createVNode(_component_ed_in, {
                  label: "a",
                  value: _ctx.colors.a,
                  "arrow-offset": 0.01,
                  max: 1,
                  onChange: $options.inputChange
                }, null, 8, ["value", "arrow-offset", "onChange"])
              ])) : createCommentVNode("v-if", true)
            ], 512), [
              [vShow, $data.fieldsIndex === 2]
            ]),
            createCommentVNode(" btn "),
            createBaseVNode("div", {
              class: "vc-chrome-toggle-btn",
              role: "button",
              "aria-label": "Change another color definition",
              onClick: _cache[3] || (_cache[3] = (...args) => $options.toggleViews && $options.toggleViews(...args))
            }, [
              createBaseVNode("div", _hoisted_22$1, [
                (openBlock(), createElementBlock("svg", {
                  style: { "width": "24px", "height": "24px" },
                  viewBox: "0 0 24 24",
                  onMouseover: _cache[0] || (_cache[0] = (...args) => $options.showHighlight && $options.showHighlight(...args)),
                  onMouseenter: _cache[1] || (_cache[1] = (...args) => $options.showHighlight && $options.showHighlight(...args)),
                  onMouseout: _cache[2] || (_cache[2] = (...args) => $options.hideHighlight && $options.hideHighlight(...args))
                }, _hoisted_24, 32))
              ]),
              withDirectives(createBaseVNode("div", _hoisted_25, null, 512), [
                [vShow, $data.highlight]
              ])
            ]),
            createCommentVNode(" btn ")
          ])) : createCommentVNode("v-if", true)
        ])
      ], 2);
    }
    var css_248z = ".vc-chrome{background:#fff;background-color:#fff;border-radius:2px;box-shadow:0 0 2px rgba(0,0,0,.3),0 4px 8px rgba(0,0,0,.3);box-sizing:initial;font-family:Menlo;width:225px}.vc-chrome-controls{display:flex}.vc-chrome-color-wrap{position:relative;width:36px}.vc-chrome-active-color{border-radius:15px;height:30px;overflow:hidden;position:relative;width:30px;z-index:1}.vc-chrome-color-wrap .vc-checkerboard{background-size:auto;border-radius:15px;height:30px;width:30px}.vc-chrome-sliders{flex:1}.vc-chrome-fields-wrap{display:flex;padding-top:16px}.vc-chrome-fields{display:flex;flex:1;margin-left:-6px}.vc-chrome-field{padding-left:6px;width:100%}.vc-chrome-toggle-btn{position:relative;text-align:right;width:32px}.vc-chrome-toggle-icon{cursor:pointer;margin-right:-4px;margin-top:12px;position:relative;z-index:2}.vc-chrome-toggle-icon-highlight{background:#eee;border-radius:4px;height:28px;left:12px;position:absolute;top:10px;width:24px}.vc-chrome-hue-wrap{margin-bottom:8px}.vc-chrome-alpha-wrap,.vc-chrome-hue-wrap{height:10px;position:relative}.vc-chrome-alpha-wrap .vc-alpha-gradient,.vc-chrome-hue-wrap .vc-hue{border-radius:2px}.vc-chrome-alpha-wrap .vc-alpha-picker,.vc-chrome-hue-wrap .vc-hue-picker{background-color:#f8f8f8;border-radius:6px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:12px;transform:translate(-6px,-2px);width:12px}.vc-chrome-body{background-color:#fff;padding:16px 16px 12px}.vc-chrome-saturation-wrap{border-radius:2px 2px 0 0;overflow:hidden;padding-bottom:55%;position:relative;width:100%}.vc-chrome-saturation-wrap .vc-saturation-circle{height:12px;width:12px}.vc-chrome-fields .vc-input__input{border:none;border-radius:2px;box-shadow:inset 0 0 0 1px #dadada;color:#333;font-size:11px;height:21px;text-align:center;width:100%}.vc-chrome-fields .vc-input__label{color:#969696;display:block;font-size:11px;line-height:11px;margin-top:12px;text-align:center;text-transform:uppercase}.vc-chrome__disable-alpha .vc-chrome-active-color{height:18px;width:18px}.vc-chrome__disable-alpha .vc-chrome-color-wrap{width:30px}.vc-chrome__disable-alpha .vc-chrome-hue-wrap{margin-bottom:4px;margin-top:4px}";
    styleInject(css_248z);
    script.render = render;
    script.__file = "src/components/chrome/chrome.vue";
    script.install = install;
    let recentColorsMaxLen = 16;
    let recentColors = [
      "#000000",
      "#333333",
      "#666666",
      "#999999",
      "#AAAAAA",
      "#CCCCCC",
      "#EEEEEE",
      "#FFFFFF",
      "#3da8f5",
      "#d71345",
      "#ffaf38",
      "#00b281",
      "#2fbdb3",
      "#7973c9",
      "#f7acbc",
      "#7b5d5f"
    ];
    const getRecentColors = () => recentColors;
    const pushRecentColor = (color) => {
      var _a;
      const index2 = recentColors.indexOf(color);
      if (index2 > -1) {
        recentColors.unshift(recentColors.splice(index2, 1)[0]);
      } else {
        recentColors.unshift(color);
      }
      if (recentColors.length > recentColorsMaxLen) {
        recentColors.pop();
      }
      (_a = sessionStorage == null ? void 0 : sessionStorage.setItem) == null ? void 0 : _a.call(sessionStorage, "__recentColors__", JSON.stringify(recentColors));
      return recentColors;
    };
    const initRecentColors = () => {
      try {
        const rcStr = sessionStorage.getItem("__recentColors__");
        if (rcStr) {
          const list = JSON.parse(rcStr);
          if (Array.isArray(list)) {
            recentColors = list;
          }
        }
      } catch (error) {
        console.log("recentColor read error: ", error);
      }
    };
    const _hoisted_1$I = { class: "color-plus" };
    const _hoisted_2$v = { class: "select-wrapper" };
    const _hoisted_3$o = {
      key: 0,
      class: "color-wrapper"
    };
    const _hoisted_4$d = ["onClick"];
    const _hoisted_5$b = { class: "color-var-name" };
    const _hoisted_6$a = {
      key: 1,
      class: "color-wrapper"
    };
    const _hoisted_7$8 = ["onClick"];
    initRecentColors();
    const _sfc_main$R = /* @__PURE__ */ defineComponent({
      __name: "ColorItem",
      props: {
        label: null,
        modelValue: null,
        hideVariable: { type: Boolean }
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const pageStore = usePageStore();
        const { colorVars } = storeToRefs(pageStore);
        const displayStore = useDisplayStore();
        const { colorType } = storeToRefs(displayStore);
        let recentColors2 = ref(getRecentColors());
        const value = computed({
          get: () => __props.modelValue,
          set: (val) => {
            const newColor = val.hex8 ? val.hex8.slice(-2) === "FF" ? val.hex : val.hex8 : val;
            emit("update:model-value", newColor);
          }
        });
        let preColor = ref("");
        const savePreColor = () => preColor.value = __props.modelValue;
        const saveRecentColor = (val) => {
          const value2 = val || __props.modelValue;
          if (preColor.value === value2)
            return;
          if (value2.slice(0, 1) !== variableColorSymbol) {
            recentColors2.value = pushRecentColor(value2);
          }
          emitter.emit("saveHistory");
        };
        const handleInputChange = (e) => {
          const value2 = e.target.value;
          if (value2 && value2 !== __props.modelValue) {
            saveRecentColor(value2);
          }
        };
        const showValue = computed(() => getColor(__props.modelValue));
        const showSaveBtn = computed(() => !__props.hideVariable && colorType.value === "variable" && __props.modelValue[0] !== variableColorSymbol);
        const handleSaveColorVar = () => {
          emitter.emit("saveColorVars", __props.modelValue);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(InputItem, {
            type: "text",
            label: __props.label,
            modelValue: value.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => value.value = $event),
            onChange: handleInputChange
          }, {
            suffix: withCtx(() => [
              createVNode(_sfc_main$X, {
                type: "color-picker",
                "popper-class": "color-dropdown",
                skidding: 20,
                distance: 10,
                onApplyShow: savePreColor,
                onApplyHide: saveRecentColor
              }, {
                content: withCtx(({ hide: hide2 }) => [
                  createVNode(unref$1(script), {
                    modelValue: value.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event)
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("div", _hoisted_1$I, [
                    createBaseVNode("div", _hoisted_2$v, [
                      createVNode(Select, {
                        display: "text",
                        disabled: __props.hideVariable,
                        "model-value": __props.hideVariable ? "recent" : unref$1(colorType),
                        placement: "bottom-start",
                        container: ".color-dropdown",
                        distance: -3,
                        options: __props.hideVariable ? { recent: _ctx.$t("recentColor") } : {
                          variable: _ctx.$t("colorVariable"),
                          recent: _ctx.$t("recentColor")
                        },
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = (val) => colorType.value = val)
                      }, null, 8, ["disabled", "model-value", "options"]),
                      withDirectives(createBaseVNode("div", {
                        class: "save-btn",
                        onClick: handleSaveColorVar
                      }, toDisplayString(_ctx.$t("saveVariable")), 513), [
                        [vShow, showSaveBtn.value]
                      ])
                    ]),
                    !__props.hideVariable && unref$1(colorType) === "variable" ? (openBlock(), createElementBlock("div", _hoisted_3$o, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(colorVars), (c) => {
                        return withDirectives((openBlock(), createElementBlock("div", {
                          class: "color-var-item",
                          key: c.name,
                          onClick: () => {
                            value.value = c.name;
                            hide2();
                          }
                        }, [
                          createBaseVNode("div", {
                            class: "color-box",
                            style: normalizeStyle({ background: c.color })
                          }, null, 4),
                          createBaseVNode("div", _hoisted_5$b, toDisplayString(c.name), 1)
                        ], 8, _hoisted_4$d)), [
                          [vShow, c.name.length > 1]
                        ]);
                      }), 128))
                    ])) : createCommentVNode("", true),
                    __props.hideVariable || unref$1(colorType) === "recent" ? (openBlock(), createElementBlock("div", _hoisted_6$a, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(recentColors2.value, (c) => {
                        return openBlock(), createElementBlock("div", {
                          class: "color-box",
                          key: c,
                          style: normalizeStyle({ background: c }),
                          onClick: () => {
                            value.value = c;
                            hide2();
                          }
                        }, null, 12, _hoisted_7$8);
                      }), 128))
                    ])) : createCommentVNode("", true)
                  ])
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "color-preview",
                    style: normalizeStyle({ background: showValue.value })
                  }, null, 4)
                ]),
                _: 1
              })
            ]),
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ]),
            _: 3
          }, 8, ["label", "modelValue"]);
        };
      }
    });
    const ColorItem_vue_vue_type_style_index_0_scoped_cdbf01dd_lang = "";
    const ColorItem_vue_vue_type_style_index_1_lang = "";
    const ColorItem = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["__scopeId", "data-v-cdbf01dd"]]);
    const _hoisted_1$H = ["innerHTML"];
    const _sfc_main$Q = /* @__PURE__ */ defineComponent({
      __name: "Tip",
      props: {
        type: null,
        block: { type: Boolean },
        noRadius: { type: Boolean },
        message: null,
        messageEn: null
      },
      setup(__props) {
        const iconMap = {
          warning: "warning"
        };
        const showMsg = computed(() => lang === "en" && __props.messageEn || __props.message);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["tip", `tip-${__props.type}`, { block: __props.block, "no-radius": __props.noRadius }])
          }, [
            createVNode(Icon$1, {
              class: "tip-icon",
              name: unref$1(iconMap)[__props.type],
              size: 14
            }, null, 8, ["name"]),
            createBaseVNode("div", {
              class: "tip-msg",
              innerHTML: showMsg.value
            }, null, 8, _hoisted_1$H)
          ], 2);
        };
      }
    });
    const Tip_vue_vue_type_style_index_0_scoped_ad9fd510_lang = "";
    const Tip = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["__scopeId", "data-v-ad9fd510"]]);
    const _sfc_main$P = /* @__PURE__ */ defineComponent({
      __name: "BasicGroup",
      props: {
        node: null,
        basic: null
      },
      setup(__props) {
        const pageStore = usePageStore();
        const { deleteActiveNode } = pageStore;
        computed(() => __props.node.type === "section");
        const configs = computed(() => {
          if (isSomeBasicType(__props.node.component, "Text", __props.basic)) {
            return [
              {
                component: InputItem,
                props: {
                  label: "Text",
                  type: "textarea",
                  modelValue: __props.basic.text,
                  placeholder: $t("textEmptyTip"),
                  realTime: true,
                  onBlur: () => {
                    if (!__props.basic.text) {
                      deleteActiveNode();
                    }
                  }
                },
                setValue: (val) => {
                  __props.basic.text = val;
                }
              },
              {
                component: SelectItem,
                props: {
                  label: $t("whiteSpace"),
                  modelValue: __props.basic.whiteSpace || "",
                  options: {
                    normal: $t("whiteSpaceNormal"),
                    nowrap: $t("whiteSpaceNowrap"),
                    pre: $t("whiteSpacePre"),
                    "pre-wrap": $t("whiteSpacePreWrap"),
                    "pre-line": $t("whiteSpacePreLine")
                  }
                },
                setValue: (val) => {
                  __props.basic.whiteSpace = val;
                }
              }
            ];
          }
          if (isSomeBasicType(__props.node.component, "Image", __props.basic)) {
            return [
              {
                component: ImageItem,
                props: {
                  label: $t("imgSrc"),
                  modelValue: __props.basic.src
                },
                setValue: (val) => {
                  __props.basic.src = val;
                }
              },
              {
                hide: !__props.basic.src,
                component: SelectItem,
                props: {
                  label: $t("objectFit"),
                  modelValue: __props.basic.objectFit,
                  options: {
                    contain: $t("objectFitContain"),
                    cover: $t("objectFitCover"),
                    fill: $t("objectFitFill"),
                    none: $t("objectFitNone"),
                    scaleDown: $t("objectFitScaleDown")
                  }
                },
                setValue: (val) => {
                  __props.basic.objectFit = val;
                }
              }
            ];
          }
          if (isSomeBasicType(__props.node.component, "Icon", __props.basic)) {
            const fontAwesomeItems = [
              {
                hide: __props.basic.styleLink !== DefaultIconStyleLink,
                component: Tip,
                props: {
                  type: "warning",
                  message: $t("iconTip"),
                  style: { marginBottom: "12px" }
                }
              },
              {
                component: InputItem,
                props: {
                  label: $t("iconName"),
                  type: "text",
                  modelValue: __props.basic.name,
                  placeholder: "Font Awesome name"
                },
                setValue: (val) => {
                  __props.basic.name = val;
                }
              },
              {
                component: InputItem,
                props: {
                  label: $t("iconSize"),
                  type: "number",
                  modelValue: __props.basic.size,
                  suffix: ["px", "rem", "vw"]
                },
                setValue: (val) => {
                  __props.basic.size = val;
                }
              },
              {
                component: ColorItem,
                props: {
                  label: $t("iconColor"),
                  modelValue: __props.basic.color
                },
                setValue: (val) => {
                  __props.basic.color = val;
                }
              },
              {
                isAdvanced: true,
                component: InputItem,
                props: {
                  label: $t("prefixClass"),
                  type: "text",
                  modelValue: __props.basic.prefixClass
                },
                setValue: (val) => {
                  __props.basic.prefixClass = val;
                }
              },
              {
                isAdvanced: true,
                component: InputItem,
                props: {
                  label: $t("extraClass"),
                  type: "text",
                  modelValue: __props.basic.extraClass,
                  placeholder: "like 'fa-spin'"
                },
                setValue: (val) => {
                  __props.basic.extraClass = val;
                }
              },
              {
                isAdvanced: true,
                component: InputItem,
                props: {
                  label: $t("cssLink"),
                  type: "text",
                  modelValue: __props.basic.styleLink
                },
                setValue: (val) => {
                  __props.basic.styleLink = val;
                }
              }
            ];
            return fontAwesomeItems;
          }
          return [];
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "basic",
            class: "basic-group",
            "default-collapsed": true,
            "can-advanced": configs.value.some((item) => item.isAdvanced)
          }, {
            default: withCtx(({ showAdvanced }) => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(configs.value, (item) => {
                return openBlock(), createElementBlock(Fragment, null, [
                  !item.hide && (!item.isAdvanced || showAdvanced) ? (openBlock(), createBlock(resolveDynamicComponent(item.component), mergeProps({ key: 0 }, item.props, {
                    "onUpdate:modelValue": item == null ? void 0 : item.setValue
                  }), null, 16, ["onUpdate:modelValue"])) : createCommentVNode("", true)
                ], 64);
              }), 256))
            ]),
            _: 1
          }, 8, ["can-advanced"]);
        };
      }
    });
    const BasicGroup_vue_vue_type_style_index_0_scoped_6fff688f_lang = "";
    const BasicGroup = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["__scopeId", "data-v-6fff688f"]]);
    const _hoisted_1$G = ["onClick"];
    const _sfc_main$O = /* @__PURE__ */ defineComponent({
      __name: "Tabs",
      props: {
        data: null,
        modelValue: null,
        type: { default: "default" },
        iconMap: null
      },
      setup(__props) {
        const list = computed(() => {
          if (Array.isArray(__props.data)) {
            return __props.data.map((item) => typeof item === "string" ? { key: item, value: item } : item);
          } else {
            return Object.keys(__props.data).map((key) => ({ key, value: __props.data[key] }));
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["tabs", `tabs-type-${__props.type}`])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(list.value, (item) => {
              return openBlock(), createElementBlock("div", {
                key: item.key,
                class: normalizeClass(["tab-item", { active: __props.modelValue === item.key || item.active }]),
                onClick: () => {
                  var _a;
                  _ctx.$emit("update:model-value", item.key);
                  (_a = item.onClick) == null ? void 0 : _a.call(item, !item.active);
                }
              }, [
                renderSlot(_ctx.$slots, "option", {
                  key: item.key,
                  value: item.value
                }, () => [
                  __props.iconMap && __props.iconMap[item.key] ? (openBlock(), createBlock(Icon$1, {
                    key: 0,
                    name: __props.iconMap[item.key],
                    size: 16
                  }, null, 8, ["name"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(item.value), 1)
                  ], 64))
                ], true)
              ], 10, _hoisted_1$G);
            }), 128))
          ], 2);
        };
      }
    });
    const Tabs_vue_vue_type_style_index_0_scoped_63d18836_lang = "";
    const Tabs = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__scopeId", "data-v-63d18836"]]);
    const _hoisted_1$F = { class: "item" };
    const _hoisted_2$u = { class: "label" };
    const _sfc_main$N = /* @__PURE__ */ defineComponent({
      __name: "TabsItem",
      props: {
        label: null,
        modelValue: null,
        data: null,
        iconMap: null
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const handleChange = (val) => {
          emit("update:model-value", val);
          __props.modelValue !== val && emitter.emit("saveHistory");
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$F, [
            createBaseVNode("div", _hoisted_2$u, toDisplayString(__props.label), 1),
            createVNode(Tabs, {
              data: __props.data,
              "model-value": __props.modelValue,
              "icon-map": __props.iconMap,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = (key) => handleChange(key))
            }, {
              option: withCtx((props) => [
                renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(props)), void 0, true)
              ]),
              _: 3
            }, 8, ["data", "model-value", "icon-map"])
          ]);
        };
      }
    });
    const TabsItem_vue_vue_type_style_index_0_scoped_832e1712_lang = "";
    const TabsItemVue = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__scopeId", "data-v-832e1712"]]);
    const _hoisted_1$E = ["data-text"];
    const _hoisted_2$t = ["value", "onChange"];
    const _sfc_main$M = /* @__PURE__ */ defineComponent({
      __name: "BorderGroup",
      props: {
        node: null,
        border: null
      },
      setup(__props) {
        const isRefinedRadius = computed(() => Array.isArray(__props.border.borderRadius));
        const curShowBorderIndex = ref(-1);
        const showList = computed(() => {
          return {
            borderWidth: {
              name: $t("borderWidth"),
              type: "number",
              value: curShowBorderIndex.value > -1 ? __props.border.borderWidth[curShowBorderIndex.value] : __props.border.borderWidth[0],
              setValue: (val) => {
                const value = fixedPoint(val);
                if (curShowBorderIndex.value === -1) {
                  __props.border.borderWidth = [value, value, value, value];
                } else {
                  __props.border.borderWidth.splice(curShowBorderIndex.value, 1, value);
                }
              },
              suffix: ["px"]
            },
            borderColor: {
              name: $t("borderColor"),
              type: "color",
              value: Array.isArray(__props.border.borderColor) ? curShowBorderIndex.value > -1 ? __props.border.borderColor[curShowBorderIndex.value] : __props.border.borderColor[0] : __props.border.borderColor,
              setValue: (value) => {
                if (curShowBorderIndex.value === -1) {
                  __props.border.borderColor = value;
                } else {
                  if (!Array.isArray(__props.border.borderColor)) {
                    __props.border.borderColor = new Array(4).fill(__props.border.borderColor);
                  }
                  __props.border.borderColor.splice(curShowBorderIndex.value, 1, value);
                }
              }
            },
            borderStyle: {
              name: $t("borderStyle"),
              type: "select",
              value: curShowBorderIndex.value > -1 ? __props.border.borderStyle[curShowBorderIndex.value] : __props.border.borderStyle[0],
              setValue: (value) => {
                if (curShowBorderIndex.value === -1) {
                  __props.border.borderStyle = [value, value, value, value];
                } else {
                  __props.border.borderStyle.splice(curShowBorderIndex.value, 1, value);
                }
              },
              options: ["solid", "dashed", "dotted", "double"]
            },
            borderRadius: {
              name: $t("cornerRadius"),
              type: "number",
              value: isRefinedRadius.value ? "refined" : __props.border.borderRadius,
              setValue: (val) => {
                if (val === "refined") {
                  __props.border.borderRadius = new Array(4).fill(__props.border.borderRadius === "circle" ? "0px" : __props.border.borderRadius);
                } else {
                  __props.border.borderRadius = val;
                }
              },
              suffix: ["px", "circle", "refined"]
            }
          };
        });
        const handleInput = (e) => {
          const elem = e.target;
          const value = elem.value;
          if (value.length > 4) {
            elem.value = value.slice(0, 4);
          } else if (!/\.|[0-9]/.test(value[value.length - 1])) {
            elem.value = value.slice(0, -1);
          }
        };
        const handleChange = (e, setValue) => {
          const elem = e.target;
          const value = elem.value;
          setValue(fixedPointToNumber(value) + "px");
          emitter.emit("saveHistory");
        };
        const boxStyles = computed(() => {
          const getBorderRadius = (radius) => radius === "circle" ? "50%" : radius;
          return {
            [curShowBorderIndex.value === -1 ? "borderColor" : ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"][curShowBorderIndex.value]]: curShowBorderIndex.value === -1 ? "#DDD" : "#3e7ce8",
            borderRadius: Array.isArray(__props.border.borderRadius) ? __props.border.borderRadius.map(getBorderRadius).join(" ") : getBorderRadius(__props.border.borderRadius)
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "border",
            class: "border-group",
            "can-advanced": false,
            "default-collapsed": false
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "spacing-block",
                "data-text": unref$1($t)("preview")
              }, [
                createBaseVNode("div", {
                  class: "inner-block",
                  style: normalizeStyle(boxStyles.value)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(["top", "right", "bottom", "left"], (dir, i2) => {
                    return createVNode(Icon$1, {
                      name: "caret-down",
                      size: 14,
                      class: normalizeClass(["border-btn", "border-btn-" + dir, { active: curShowBorderIndex.value === i2 }]),
                      onClick: ($event) => curShowBorderIndex.value = i2
                    }, null, 8, ["class", "onClick"]);
                  }), 64)),
                  createBaseVNode("div", {
                    class: normalizeClass(["all-btn", { active: curShowBorderIndex.value === -1 }]),
                    onClick: _cache[0] || (_cache[0] = ($event) => curShowBorderIndex.value = -1)
                  }, toDisplayString(curShowBorderIndex.value === -1 ? unref$1($t)("all") : [unref$1($t)("top"), unref$1($t)("right"), unref$1($t)("bottom"), unref$1($t)("left")][curShowBorderIndex.value]), 3)
                ], 4),
                isRefinedRadius.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.border.borderRadius, (val, i2) => {
                  return openBlock(), createElementBlock("input", {
                    key: i2,
                    class: normalizeClass(["spacing-input", `spacing-input-${i2}`]),
                    value: parseFloat(val),
                    onInput: handleInput,
                    onChange: (e) => handleChange(e, (val2) => Array.isArray(__props.border.borderRadius) && __props.border.borderRadius.splice(i2, 1, val2))
                  }, null, 42, _hoisted_2$t);
                }), 128)) : createCommentVNode("", true)
              ], 8, _hoisted_1$E),
              (openBlock(true), createElementBlock(Fragment, null, renderList(showList.value, (item, key) => {
                return openBlock(), createElementBlock(Fragment, { key }, [
                  item.type === "number" ? (openBlock(), createBlock(InputItem, {
                    key: 0,
                    label: item.name,
                    type: "number",
                    "model-value": item.value,
                    suffix: item.suffix,
                    "onUpdate:modelValue": item.setValue
                  }, null, 8, ["label", "model-value", "suffix", "onUpdate:modelValue"])) : item.type === "select" ? (openBlock(), createBlock(TabsItemVue, {
                    key: 1,
                    label: item.name,
                    data: Object.fromEntries(item.options.map((key2) => [key2, key2])),
                    "model-value": item.value,
                    "onUpdate:modelValue": item.setValue
                  }, {
                    option: withCtx(({ key: key2 }) => [
                      key2 === "solid" ? (openBlock(), createBlock(Icon$1, {
                        key: 0,
                        name: "line",
                        size: 16
                      })) : createCommentVNode("", true),
                      key2 === "dashed" ? (openBlock(), createBlock(Icon$1, {
                        key: 1,
                        name: "dashed",
                        size: 16
                      })) : createCommentVNode("", true),
                      key2 === "dotted" ? (openBlock(), createBlock(Icon$1, {
                        key: 2,
                        name: "dotted",
                        size: 16
                      })) : createCommentVNode("", true),
                      key2 === "double" ? (openBlock(), createBlock(Icon$1, {
                        key: 3,
                        name: "line-double",
                        size: 16
                      })) : createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1032, ["label", "data", "model-value", "onUpdate:modelValue"])) : item.type === "color" ? (openBlock(), createBlock(ColorItem, {
                    key: 2,
                    label: item.name,
                    "model-value": item.value,
                    "onUpdate:modelValue": item.setValue
                  }, null, 8, ["label", "model-value", "onUpdate:modelValue"])) : createCommentVNode("", true)
                ], 64);
              }), 128))
            ]),
            _: 1
          });
        };
      }
    });
    const BorderGroup_vue_vue_type_style_index_0_scoped_51c52556_lang = "";
    const BorderGroup = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__scopeId", "data-v-51c52556"]]);
    const _hoisted_1$D = { class: "item preview-item" };
    const _hoisted_2$s = { class: "preview-wrapper" };
    const _hoisted_3$n = ["onClick"];
    const _sfc_main$L = /* @__PURE__ */ defineComponent({
      __name: "PreviewItem",
      props: {
        label: null,
        modelValue: null,
        options: null,
        hideAdvanced: { type: Boolean }
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const activeIndex = computed(() => __props.options.indexOf(__props.modelValue));
        const handleChange = (item) => {
          emit("update:model-value", item);
          emitter.emit("saveHistory");
        };
        const showCodeInput = ref(false);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$D, [
            createBaseVNode("div", {
              class: "label",
              onDblclick: _cache[0] || (_cache[0] = ($event) => showCodeInput.value = __props.hideAdvanced ? false : !showCodeInput.value)
            }, toDisplayString(__props.label), 33),
            createBaseVNode("div", _hoisted_2$s, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (item, index2) => {
                return openBlock(), createElementBlock("div", {
                  key: index2,
                  class: normalizeClass(["preview-wrapper-item", { active: activeIndex.value === index2 }]),
                  onClick: () => handleChange(activeIndex.value === index2 ? "" : item)
                }, [
                  renderSlot(_ctx.$slots, "default", {
                    item,
                    index: index2,
                    active: activeIndex.value === index2
                  }, void 0, true)
                ], 10, _hoisted_3$n);
              }), 128))
            ]),
            showCodeInput.value ? (openBlock(), createBlock(InputItem, {
              key: 0,
              label: __props.label + " Code",
              "model-value": __props.modelValue,
              "onUpdate:modelValue": handleChange
            }, null, 8, ["label", "model-value"])) : createCommentVNode("", true)
          ]);
        };
      }
    });
    const PreviewItem_vue_vue_type_style_index_0_scoped_70c2a346_lang = "";
    const PreviewItem = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__scopeId", "data-v-70c2a346"]]);
    const _sfc_main$K = /* @__PURE__ */ defineComponent({
      __name: "FontGroup",
      props: {
        node: null,
        font: null
      },
      setup(__props) {
        const fontSetting = computed(() => ({
          fontSize: {
            name: $t("fontSize"),
            type: "number",
            value: __props.font.fontSize,
            setValue: (val) => {
              __props.font.fontSize = val;
            },
            suffix: ["px", "rem", "vw"]
          },
          lineHeight: {
            name: $t("lineHeight"),
            type: "number",
            value: __props.font.lineHeight,
            setValue: (val) => __props.font.lineHeight = val,
            suffix: ["px", "rem", "vw", "%"]
          }
        }));
        const fontWeightMap = {
          normal: "Normal",
          500: "500",
          600: "600",
          bold: "Bold",
          800: "800",
          900: "900"
        };
        const fontTabs = computed(() => [
          {
            key: "bold",
            icon: "bold",
            isActive: __props.font.fontWeight === "bold",
            setValue: (val) => __props.font.fontWeight = val ? "bold" : "normal"
          },
          {
            key: "italic",
            icon: "italic",
            isActive: __props.font.fontStyle === "italic",
            setValue: (val) => __props.font.fontStyle = val ? "italic" : "normal"
          },
          {
            key: "underline",
            icon: "underline",
            isActive: __props.font.textDecoration === "underline",
            setValue: (val) => __props.font.textDecoration = val ? "underline" : "none"
          },
          {
            key: "line-through",
            icon: "line-through",
            isActive: __props.font.textDecoration === "line-through",
            setValue: (val) => __props.font.textDecoration = val ? "line-through" : "none"
          }
        ]);
        const textShadowPreset = [
          "2px 4px 3px rgba(0,0,0,0.3)",
          "6px 6px 0px rgba(0,0,0,0.2)",
          "0px 4px 3px rgba(0,0,0,0.4), 0px 8px 13px rgba(0,0,0,0.1), 0px 18px 23px rgba(0,0,0,0.1)",
          "0 13.36px 8.896px #c4b59d, 0 -2px 1px #fff",
          "0px 10px 5px rgba(0,0,0,0.1), 10px 15px 5px rgba(0,0,0,0.05), -10px 15px 5px rgba(0,0,0,0.05)",
          "2px 8px 6px rgba(0,0,0,0.2), 0px -5px 35px rgba(255,255,255,0.3)"
        ];
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, mergeProps({
            "group-name": "font",
            class: "size-group",
            "can-advanced": true,
            "default-collapsed": false
          }, _ctx.$attrs), {
            default: withCtx(({ showAdvanced }) => [
              createVNode(InputItem, {
                label: fontSetting.value.fontSize.name,
                "model-value": fontSetting.value.fontSize.value,
                suffix: fontSetting.value.fontSize.suffix,
                type: fontSetting.value.fontSize.type,
                "onUpdate:modelValue": fontSetting.value.fontSize.setValue
              }, null, 8, ["label", "model-value", "suffix", "type", "onUpdate:modelValue"]),
              createVNode(ColorItem, {
                label: unref$1($t)("fontColor"),
                modelValue: __props.font.color,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => __props.font.color = $event)
              }, null, 8, ["label", "modelValue"]),
              createVNode(TabsItemVue, {
                data: ["left", "center", "right", "justify"],
                modelValue: __props.font.textAlign,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => __props.font.textAlign = $event),
                "icon-map": {
                  left: "align-left",
                  center: "align-center",
                  right: "align-right",
                  justify: "align-justify"
                }
              }, null, 8, ["modelValue"]),
              showAdvanced ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createVNode(InputItem, {
                  label: fontSetting.value.lineHeight.name,
                  "model-value": fontSetting.value.lineHeight.value,
                  suffix: fontSetting.value.lineHeight.suffix,
                  type: fontSetting.value.lineHeight.type,
                  "onUpdate:modelValue": fontSetting.value.lineHeight.setValue
                }, null, 8, ["label", "model-value", "suffix", "type", "onUpdate:modelValue"]),
                createVNode(TabsItemVue, {
                  data: fontTabs.value.map((item) => ({
                    key: item.icon,
                    value: item.icon,
                    active: item.isActive,
                    onClick: item.setValue
                  })),
                  "icon-map": Object.fromEntries(fontTabs.value.map((item) => [item.key, item.icon]))
                }, null, 8, ["data", "icon-map"]),
                createVNode(SelectItem, {
                  label: unref$1($t)("fontWeight"),
                  modelValue: __props.font.fontWeight,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => __props.font.fontWeight = $event),
                  options: fontWeightMap
                }, null, 8, ["label", "modelValue"]),
                createVNode(PreviewItem, {
                  label: unref$1($t)("textShadow"),
                  options: textShadowPreset,
                  modelValue: __props.font.textShadow,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => __props.font.textShadow = $event)
                }, {
                  default: withCtx(({ item: shadow, active }) => [
                    createBaseVNode("div", {
                      class: normalizeClass(["inner", { active }]),
                      style: normalizeStyle({ textShadow: shadow })
                    }, "T", 6)
                  ]),
                  _: 1
                }, 8, ["label", "modelValue"]),
                createVNode(InputItem, {
                  label: unref$1($t)("fontFamily"),
                  placeholder: "inherit",
                  modelValue: __props.font.fontFamily,
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => __props.font.fontFamily = $event)
                }, null, 8, ["label", "modelValue"])
              ], 64)) : createCommentVNode("", true)
            ]),
            _: 1
          }, 16);
        };
      }
    });
    const FontGroup_vue_vue_type_style_index_0_scoped_a32236fb_lang = "";
    const FontGroup = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__scopeId", "data-v-a32236fb"]]);
    const _withScopeId$6 = (n) => (pushScopeId("data-v-cfc4ae59"), n = n(), popScopeId(), n);
    const _hoisted_1$C = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", {
      class: /* @__PURE__ */ normalizeClass(["switch-handler"])
    }, null, -1));
    const _hoisted_2$r = [
      _hoisted_1$C
    ];
    const _sfc_main$J = /* @__PURE__ */ defineComponent({
      __name: "Switch",
      props: {
        modelValue: { type: Boolean }
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const handleChange = (event) => {
          emit("update:model-value", !__props.modelValue);
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["switch", { active: __props.modelValue }]),
            onClick: handleChange
          }, _hoisted_2$r, 2);
        };
      }
    });
    const Switch_vue_vue_type_style_index_0_scoped_cfc4ae59_lang = "";
    const Switch = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__scopeId", "data-v-cfc4ae59"]]);
    const _hoisted_1$B = { class: "item" };
    const _hoisted_2$q = { class: "label" };
    const _sfc_main$I = /* @__PURE__ */ defineComponent({
      __name: "SwitchItem",
      props: {
        label: null,
        modelValue: { type: Boolean }
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const value = computed({
          get: () => __props.modelValue,
          set: (val) => {
            emit("update:model-value", val);
            __props.modelValue !== val && emitter.emit("saveHistory");
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$B, [
            createBaseVNode("div", _hoisted_2$q, toDisplayString(__props.label), 1),
            createVNode(Switch, {
              modelValue: value.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event)
            }, null, 8, ["modelValue"]),
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ]);
        };
      }
    });
    const SwitchItem_vue_vue_type_style_index_0_scoped_29749121_lang = "";
    const SwitchItem = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__scopeId", "data-v-29749121"]]);
    const _withScopeId$5 = (n) => (pushScopeId("data-v-d314cb10"), n = n(), popScopeId(), n);
    const _hoisted_1$A = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "align-preview-item" }, "1", -1));
    const _hoisted_2$p = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "align-preview-item" }, "2", -1));
    const _hoisted_3$m = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "align-preview-item" }, "3", -1));
    const _hoisted_4$c = [
      _hoisted_1$A,
      _hoisted_2$p,
      _hoisted_3$m
    ];
    const _sfc_main$H = /* @__PURE__ */ defineComponent({
      __name: "LayoutGroup",
      props: {
        node: null,
        layout: null
      },
      setup(__props) {
        const justifyMap = {
          start: $t("justifyStart"),
          center: $t("justifyCenter"),
          end: $t("justifyEnd"),
          "space-around": $t("justifySpaceAround"),
          "space-between": $t("justifySpaceBetween"),
          "space-evenly": $t("justifySpaceEvenly")
        };
        const alignMap = {
          start: $t("alignStart"),
          center: $t("alignCenter"),
          end: $t("alignEnd"),
          stretch: $t("alignStretch"),
          baseline: $t("alignBaseline")
        };
        const isWrap = computed({
          get() {
            return __props.layout.wrap === "wrap";
          },
          set(val) {
            __props.layout.wrap = val ? "wrap" : "nowrap";
          }
        });
        const isReverse = computed({
          get() {
            return !!__props.layout.reverse;
          },
          set(val) {
            __props.layout.reverse = val;
          }
        });
        const previewStyle = computed(() => useLayoutStyle(__props.layout));
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "layout",
            class: "layout-group",
            "default-collapsed": true
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "align-preview",
                "data-title": "Preview",
                style: normalizeStyle(previewStyle.value)
              }, _hoisted_4$c, 4),
              createVNode(TabsItemVue, {
                label: unref$1($t)("direction"),
                data: { row: unref$1($t)("row"), column: unref$1($t)("column") },
                modelValue: __props.layout.direction,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => __props.layout.direction = $event)
              }, null, 8, ["label", "data", "modelValue"]),
              createVNode(SelectItem, {
                label: unref$1($t)("mainAxisAlign"),
                modelValue: __props.layout.justify,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => __props.layout.justify = $event),
                options: justifyMap
              }, null, 8, ["label", "modelValue"]),
              createVNode(SelectItem, {
                label: unref$1($t)("crossAxisAlign"),
                modelValue: __props.layout.align,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => __props.layout.align = $event),
                options: alignMap
              }, null, 8, ["label", "modelValue"]),
              createVNode(SwitchItem, {
                label: unref$1($t)("wrap"),
                modelValue: isWrap.value,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => isWrap.value = $event)
              }, null, 8, ["label", "modelValue"]),
              createVNode(SwitchItem, {
                label: unref$1($t)("reverse"),
                modelValue: isReverse.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isReverse.value = $event)
              }, null, 8, ["label", "modelValue"])
            ]),
            _: 1
          });
        };
      }
    });
    const LayoutGroup_vue_vue_type_style_index_0_scoped_d314cb10_lang = "";
    const LayoutGroup = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__scopeId", "data-v-d314cb10"]]);
    let moveable = null;
    let isResizing = false;
    let isDragging = false;
    const getMoveable = () => {
      if (moveable)
        return moveable;
      const containerElement = document.querySelector(".edit-section");
      if (!containerElement)
        return null;
      moveable = new Moveable(containerElement, {
        draggable: false,
        snappable: true,
        origin: false,
        useResizeObserver: true,
        hideDefaultLines: true,
        ables: [
          {
            name: "outline",
            props: {},
            events: {},
            render: (m, renderer2) => {
              const rect = m.getRect();
              const elem = m.props.target;
              const name = (elem == null ? void 0 : elem.getAttribute("data-name")) || "";
              const zoom = useDisplayStore().device.zoom;
              return renderer2.createElement("div", {
                class: "moveable-outline",
                style: {
                  width: `${rect.width}px`,
                  height: `${rect.height}px`
                }
              }, name ? renderer2.createElement("div", {
                class: "moveable-outline-text right-top",
                style: {}
              }, name) : null, isResizing ? renderer2.createElement("div", {
                class: "moveable-outline-text left-bottom",
                style: {}
              }, `${elem.dataset.resizeWidth || elem.offsetWidth + "px"} x ${elem.dataset.resizeHeight || elem.offsetHeight + "px"}`) : null, isDragging && elem.dataset.leftMove ? renderer2.createElement("div", {
                class: "moveable-outline-line left",
                style: {
                  width: `${parseFloat(elem.style.left) * zoom}px`
                }
              }, renderer2.createElement("div", {}, elem.dataset.leftMove)) : null, isDragging && elem.dataset.rightMove ? renderer2.createElement("div", {
                class: "moveable-outline-line right",
                style: {
                  width: `${parseFloat(elem.style.right) * zoom}px`
                }
              }, renderer2.createElement("div", {}, elem.dataset.rightMove)) : null, isDragging && elem.dataset.topMove ? renderer2.createElement("div", {
                class: "moveable-outline-line top",
                style: {
                  height: `${parseFloat(elem.style.top) * zoom}px`
                }
              }, renderer2.createElement("div", {}, elem.dataset.topMove)) : null, isDragging && elem.dataset.bottomMove ? renderer2.createElement("div", {
                class: "moveable-outline-line bottom",
                style: {
                  height: `${parseFloat(elem.style.bottom) * zoom}px`
                }
              }, renderer2.createElement("div", {}, elem.dataset.bottomMove)) : null);
            }
          }
        ],
        props: {
          outline: true
        }
      });
      emitter.on("updateMoveable", updateMoveableRect);
      const wrapperElement = document.querySelector(".edit-wrapper");
      wrapperElement == null ? void 0 : wrapperElement.addEventListener("scroll", updateMoveableRect);
      return moveable;
    };
    const updateMoveableRect = () => {
      moveable == null ? void 0 : moveable.updateRect();
      ((moveable == null ? void 0 : moveable.draggable) || (moveable == null ? void 0 : moveable.resizable)) && setSnappableGuidelines();
    };
    const disabledMoveable = () => {
      const moveable2 = getMoveable();
      if (!moveable2)
        return;
      moveable2.resizable = false;
      moveable2.draggable = false;
      moveable2.target = null;
      moveable2.off();
    };
    const updateDirection = (item) => {
      var _a, _b;
      const moveable2 = getMoveable();
      if (!moveable2)
        return;
      const props = useConfigProps(item);
      const disableWidth = item.type === "section" || !isUnitType(getUnit((_a = props.size) == null ? void 0 : _a.width));
      const disableHeight = !isUnitType(getUnit((_b = props.size) == null ? void 0 : _b.height));
      const renderDirections = disableWidth && disableHeight ? [] : disableWidth ? ["s", "n"] : disableHeight ? ["w", "e"] : ["n", "nw", "ne", "s", "se", "sw", "e", "w"];
      moveable2.renderDirections = renderDirections;
    };
    const useMoveable = (elem, item, parent2) => {
      var _a;
      const moveable2 = getMoveable();
      if (!moveable2)
        return;
      const props = useConfigProps(item);
      const disableMove = !["absolute", "fixed"].includes(((_a = props == null ? void 0 : props.position) == null ? void 0 : _a.position) || "");
      let units = {};
      moveable2.resizable = true;
      moveable2.target = elem;
      moveable2.off();
      updateDirection(item);
      setSnappableGuidelines(elem);
      moveable2.on("beforeResize", (e) => {
        const shiftKey = e == null ? void 0 : e.inputEvent.shiftKey;
        moveable2.keepRatio = !!shiftKey;
      });
      moveable2.on("resizeStart", (e) => {
        var _a2, _b;
        elem.scrollLeft = 0;
        elem.scrollTop = 0;
        units.width = getUnit((_a2 = props.size) == null ? void 0 : _a2.width);
        units.widthReferSize = parent2 && elem.parentElement ? elem.parentElement.clientWidth : useDisplayStore().device.width;
        units.height = getUnit((_b = props.size) == null ? void 0 : _b.height);
        units.heightReferSize = parent2 && elem.parentElement ? elem.parentElement.clientHeight : useDisplayStore().device.height;
        isResizing = true;
      });
      moveable2.on("resize", (e) => {
        if (units == null ? void 0 : units.width) {
          elem.style.width = fixedPointToNumber(e.width) + "px";
          elem.dataset.resizeWidth = covertPXToUnit(elem.style.width, units.width, units.widthReferSize);
        }
        if (units == null ? void 0 : units.height) {
          elem.style.height = fixedPointToNumber(e.height) + "px";
          elem.dataset.resizeHeight = covertPXToUnit(elem.style.height, units.height, units.heightReferSize);
        }
      });
      moveable2.on("resizeEnd", (e) => {
        if (props.size && units.width && elem.dataset.resizeWidth) {
          props.size.width = elem.dataset.resizeWidth;
          delete elem.dataset.resizeWidth;
        }
        if (props.size && units.height && elem.dataset.resizeHeight) {
          props.size.height = elem.dataset.resizeHeight;
          delete elem.dataset.resizeHeight;
        }
        isResizing = false;
        emitter.emit("saveHistory");
      });
      if (!disableMove) {
        openDragMode(elem);
      } else {
        closeDragMode();
      }
    };
    const openDragMode = (activeElem) => {
      const moveable2 = getMoveable();
      if (!moveable2 || useDisplayStore().lockDrag)
        return;
      moveable2.draggable = true;
      const elem = activeElem || moveable2.target;
      setSnappableGuidelines(elem);
      const item = usePageStore().activeNode;
      const props = useConfigProps(item);
      const positionMap2 = ["left", "right", "top", "bottom"];
      let units = {};
      moveable2.on("dragStart", (e) => {
        units = {
          widthReferSize: parent && elem.parentElement ? elem.parentElement.clientWidth : useDisplayStore().device.width,
          heightReferSize: parent && elem.parentElement ? elem.parentElement.clientHeight : useDisplayStore().device.height
        };
        isDragging = true;
        positionMap2.forEach((key) => {
          var _a, _b;
          if (((_a = props.position) == null ? void 0 : _a[key]) !== "auto") {
            units[key] = getUnit((_b = props.position) == null ? void 0 : _b[key]);
          }
        });
      });
      moveable2.on("drag", (e) => {
        positionMap2.forEach((key) => {
          if (units[key]) {
            elem.style[key] = fixedPointToNumber(e[key]) + "px";
            elem.dataset[`${key}Move`] = covertPXToUnit(elem.style[key], units[key], ["top", "bottom"].includes(key) ? units.heightReferSize : units.widthReferSize);
          }
        });
      });
      moveable2.on("dragEnd", (e) => {
        const elem2 = e.target;
        isDragging = false;
        positionMap2.forEach((key) => {
          if (units[key] && elem2.dataset[`${key}Move`] && props.position) {
            props.position[key] = elem2.dataset[`${key}Move`];
            delete elem2.dataset[`${key}Move`];
          }
        });
        emitter.emit("saveHistory");
      });
    };
    const closeDragMode = () => {
      const moveable2 = getMoveable();
      if (!moveable2)
        return;
      moveable2.draggable = false;
    };
    const setSnappableGuidelines = (activeElement) => {
      const moveable2 = getMoveable();
      const editSection = document.querySelector(".edit-section");
      if (!moveable2 || !editSection)
        return;
      const activeElem = activeElement || moveable2.target;
      let horizontalGuidelines = [];
      let verticalGuidelines = [];
      const referElemList = [];
      const parentElement = activeElem.parentElement;
      if (!parentElement)
        return;
      const zoom = useDisplayStore().device.zoom;
      const siblingElement = Array.from((parentElement == null ? void 0 : parentElement.children) || []).filter((elem) => elem !== activeElem);
      if (parentElement && parentElement.classList.contains("lib-component")) {
        referElemList.push(parentElement);
      }
      referElemList.push(...siblingElement);
      if (referElemList.length > 0) {
        referElemList.forEach((elem) => {
          const wrapperOffset = getElementOffsetByWrapper(elem, editSection);
          verticalGuidelines.push(wrapperOffset.left, elem.offsetWidth * zoom + wrapperOffset.left);
          horizontalGuidelines.push(wrapperOffset.top, elem.offsetHeight * zoom + wrapperOffset.top);
        });
      }
      moveable2.horizontalGuidelines = horizontalGuidelines;
      moveable2.verticalGuidelines = verticalGuidelines;
    };
    const getElementOffsetByWrapper = (elem, wrapperElement) => {
      const rect = elem.getBoundingClientRect();
      const editSectionRect = wrapperElement.getBoundingClientRect();
      return {
        top: rect.top - editSectionRect.top,
        left: rect.left - editSectionRect.left
      };
    };
    const destroyMoveable = () => {
      disabledMoveable();
      moveable == null ? void 0 : moveable.destroy();
      moveable = null;
    };
    const _sfc_main$G = /* @__PURE__ */ defineComponent({
      __name: "SizeGroup",
      props: {
        node: null,
        size: null
      },
      setup(__props) {
        const isSection = computed(() => __props.node.type === "section");
        const list = computed(() => [
          {
            hide: isSection.value,
            name: $t("width"),
            type: "number",
            value: __props.size.width,
            setValue: (val) => {
              __props.size.width = val;
              updateDirection(__props.node);
            },
            suffix: ["px", "%", "rem", "vw", "auto", "stretch"]
          },
          {
            name: $t("height"),
            type: "number",
            value: __props.size.height,
            setValue: (val) => {
              __props.size.height = val;
              updateDirection(__props.node);
            },
            suffix: isSection.value ? ["px", "%", "rem", "vw", "auto"] : ["px", "%", "rem", "vw", "auto", "stretch"]
          },
          {
            hide: isSection.value,
            name: $t("minWidth"),
            type: "number",
            value: __props.size.minWidth,
            setValue: (val) => __props.size.minWidth = val,
            suffix: ["px", "%", "rem", "vw", "auto"],
            isAdvanced: true
          },
          {
            name: $t("minHeight"),
            type: "number",
            value: __props.size.minHeight,
            setValue: (val) => __props.size.minHeight = val,
            suffix: ["px", "%", "rem", "vw", "auto"],
            isAdvanced: true
          },
          {
            hide: isSection.value,
            name: $t("maxWidth"),
            type: "number",
            value: __props.size.maxWidth,
            setValue: (val) => __props.size.maxWidth = val,
            suffix: ["px", "%", "rem", "vw", "none"],
            isAdvanced: true
          },
          {
            name: $t("maxHeight"),
            type: "number",
            value: __props.size.maxHeight,
            setValue: (val) => __props.size.maxHeight = val,
            suffix: ["px", "%", "rem", "vw", "none"],
            isAdvanced: true
          }
        ]);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "size",
            class: "size-group",
            "can-advanced": true,
            "default-collapsed": false
          }, {
            default: withCtx(({ showAdvanced }) => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(list.value, (item, index2) => {
                return openBlock(), createElementBlock(Fragment, {
                  key: item.name
                }, [
                  !item.hide && (!item.isAdvanced || showAdvanced) ? (openBlock(), createBlock(InputItem, {
                    key: 0,
                    label: item.name,
                    "model-value": item.value,
                    suffix: item.suffix,
                    type: item.type,
                    "onUpdate:modelValue": item.setValue
                  }, null, 8, ["label", "model-value", "suffix", "type", "onUpdate:modelValue"])) : createCommentVNode("", true)
                ], 64);
              }), 128))
            ]),
            _: 1
          });
        };
      }
    });
    const SizeGroup_vue_vue_type_style_index_0_scoped_c6312be9_lang = "";
    const SizeGroup = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-c6312be9"]]);
    const _withScopeId$4 = (n) => (pushScopeId("data-v-1fc0f236"), n = n(), popScopeId(), n);
    const _hoisted_1$z = ["data-text"];
    const _hoisted_2$o = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "margin-sign" }, null, -1));
    const _hoisted_3$l = ["data-text"];
    const _hoisted_4$b = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "padding-sign" }, null, -1));
    const _hoisted_5$a = ["value", "onChange"];
    const _hoisted_6$9 = ["value"];
    const _hoisted_7$7 = ["value", "onChange"];
    const _sfc_main$F = /* @__PURE__ */ defineComponent({
      __name: "SpacingGroup",
      props: {
        node: null,
        spacing: null
      },
      setup(__props) {
        const handleInput = (e) => {
          const elem = e.target;
          const value = elem.value;
          if (value.length > 4) {
            elem.value = value.slice(0, 4);
          } else if (!/\.|[0-9]|-/.test(value[value.length - 1])) {
            elem.value = value.slice(0, -1);
          }
        };
        const handleChange = (e, setValue) => {
          const elem = e.target;
          const value = elem.value;
          setValue(fixedPointToNumber(value));
          emitter.emit("saveHistory");
        };
        const allPadding = computed({
          get: () => {
            const { padding } = __props.spacing;
            if (padding[0] === padding[1] && padding[1] === padding[2] && padding[2] === padding[3]) {
              return padding[0];
            }
            return "-";
          },
          set: (val) => {
            const value = fixedPointToNumber(val);
            if (value === 0) {
              __props.spacing.padding = [0, 0, 0, 0];
            } else {
              __props.spacing.padding = [value, value, value, value];
            }
            emitter.emit("saveHistory");
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "spacing",
            class: "spacing-group",
            "can-advanced": false,
            "default-collapsed": false
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "spacing-block",
                "data-text": _ctx.$t("margin")
              }, [
                _hoisted_2$o,
                createBaseVNode("div", {
                  class: "inner-block",
                  "data-text": _ctx.$t("padding")
                }, [
                  _hoisted_4$b,
                  (openBlock(true), createElementBlock(Fragment, null, renderList(__props.spacing.padding, (val, i2) => {
                    return openBlock(), createElementBlock("input", {
                      key: i2,
                      class: normalizeClass(["spacing-input", `spacing-input-${i2}`]),
                      value: val,
                      onInput: handleInput,
                      onChange: (e) => handleChange(e, (val2) => __props.spacing.padding.splice(i2, 1, val2))
                    }, null, 42, _hoisted_5$a);
                  }), 128)),
                  createBaseVNode("input", {
                    class: "spacing-input spacing-input-all",
                    value: allPadding.value,
                    onInput: handleInput,
                    onChange: _cache[0] || (_cache[0] = ($event) => allPadding.value = $event.target.value)
                  }, null, 40, _hoisted_6$9)
                ], 8, _hoisted_3$l),
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.spacing.margin, (val, i2) => {
                  return openBlock(), createElementBlock("input", {
                    key: i2,
                    class: normalizeClass(["spacing-input", `spacing-input-${i2}`]),
                    value: val,
                    onInput: handleInput,
                    onChange: (e) => handleChange(e, (val2) => __props.spacing.margin.splice(i2, 1, val2))
                  }, null, 42, _hoisted_7$7);
                }), 128))
              ], 8, _hoisted_1$z)
            ]),
            _: 1
          });
        };
      }
    });
    const SpacingGroup_vue_vue_type_style_index_0_scoped_1fc0f236_lang = "";
    const SpacingGroup = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__scopeId", "data-v-1fc0f236"]]);
    var vueSliderComponent_umd_min = { exports: {} };
    const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace$1(vue_runtime_esmBundler);
    (function(module2, exports2) {
      (function(t, e) {
        module2.exports = e(require$$0$1);
      })("undefined" !== typeof self ? self : commonjsGlobal$1, function(t) {
        return function() {
          var e = { 388: function(t2, e2) {
            var r2, n2, i3;
            (function(o, a) {
              n2 = [], r2 = a, i3 = "function" === typeof r2 ? r2.apply(e2, n2) : r2, void 0 === i3 || (t2.exports = i3);
            })("undefined" !== typeof self && self, function() {
              function t3() {
                var e3 = Object.getOwnPropertyDescriptor(document, "currentScript");
                if (!e3 && "currentScript" in document && document.currentScript)
                  return document.currentScript;
                if (e3 && e3.get !== t3 && document.currentScript)
                  return document.currentScript;
                try {
                  throw new Error();
                } catch (f) {
                  var r3, n3, i4, o = /.*at [^(]*\((.*):(.+):(.+)\)$/gi, a = /@([^@]*):(\d+):(\d+)\s*$/gi, s = o.exec(f.stack) || a.exec(f.stack), l = s && s[1] || false, u = s && s[2] || false, c = document.location.href.replace(document.location.hash, ""), d = document.getElementsByTagName("script");
                  l === c && (r3 = document.documentElement.outerHTML, n3 = new RegExp("(?:[^\\n]+?\\n){0," + (u - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i"), i4 = r3.replace(n3, "$1").trim());
                  for (var h2 = 0; h2 < d.length; h2++) {
                    if ("interactive" === d[h2].readyState)
                      return d[h2];
                    if (d[h2].src === l)
                      return d[h2];
                    if (l === c && d[h2].innerHTML && d[h2].innerHTML.trim() === i4)
                      return d[h2];
                  }
                  return null;
                }
              }
              return t3;
            });
          }, 905: function(t2, e2, r2) {
            r2.r(e2);
            var n2 = r2(117), i3 = r2.n(n2), o = r2(488), a = r2.n(o), s = a()(i3());
            s.push([t2.id, ".vue-slider-dot{position:absolute;-webkit-transition:all 0s;transition:all 0s;z-index:5}.vue-slider-dot:focus{outline:none}.vue-slider-dot-tooltip{position:absolute;visibility:hidden}.vue-slider-dot-hover:hover .vue-slider-dot-tooltip,.vue-slider-dot-tooltip-show{visibility:visible}.vue-slider-dot-tooltip-top{top:-10px;left:50%;-webkit-transform:translate(-50%,-100%);transform:translate(-50%,-100%)}.vue-slider-dot-tooltip-bottom{bottom:-10px;left:50%;-webkit-transform:translate(-50%,100%);transform:translate(-50%,100%)}.vue-slider-dot-tooltip-left{left:-10px;top:50%;-webkit-transform:translate(-100%,-50%);transform:translate(-100%,-50%)}.vue-slider-dot-tooltip-right{right:-10px;top:50%;-webkit-transform:translate(100%,-50%);transform:translate(100%,-50%)}", ""]), e2["default"] = s;
          }, 121: function(t2, e2, r2) {
            r2.r(e2);
            var n2 = r2(117), i3 = r2.n(n2), o = r2(488), a = r2.n(o), s = a()(i3());
            s.push([t2.id, ".vue-slider-marks{position:relative;width:100%;height:100%}.vue-slider-mark{position:absolute;z-index:1}.vue-slider-ltr .vue-slider-mark,.vue-slider-rtl .vue-slider-mark{width:0;height:100%;top:50%}.vue-slider-ltr .vue-slider-mark-step,.vue-slider-rtl .vue-slider-mark-step{top:0}.vue-slider-ltr .vue-slider-mark-label,.vue-slider-rtl .vue-slider-mark-label{top:100%;margin-top:10px}.vue-slider-ltr .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ltr .vue-slider-mark-step{left:0}.vue-slider-ltr .vue-slider-mark-label{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.vue-slider-rtl .vue-slider-mark{-webkit-transform:translate(50%,-50%);transform:translate(50%,-50%)}.vue-slider-rtl .vue-slider-mark-step{right:0}.vue-slider-rtl .vue-slider-mark-label{right:50%;-webkit-transform:translateX(50%);transform:translateX(50%)}.vue-slider-btt .vue-slider-mark,.vue-slider-ttb .vue-slider-mark{width:100%;height:0;left:50%}.vue-slider-btt .vue-slider-mark-step,.vue-slider-ttb .vue-slider-mark-step{left:0}.vue-slider-btt .vue-slider-mark-label,.vue-slider-ttb .vue-slider-mark-label{left:100%;margin-left:10px}.vue-slider-btt .vue-slider-mark{-webkit-transform:translate(-50%,50%);transform:translate(-50%,50%)}.vue-slider-btt .vue-slider-mark-step{top:0}.vue-slider-btt .vue-slider-mark-label{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.vue-slider-ttb .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ttb .vue-slider-mark-step{bottom:0}.vue-slider-ttb .vue-slider-mark-label{bottom:50%;-webkit-transform:translateY(50%);transform:translateY(50%)}.vue-slider-mark-label,.vue-slider-mark-step{position:absolute}", ""]), e2["default"] = s;
          }, 207: function(t2, e2, r2) {
            r2.r(e2);
            var n2 = r2(117), i3 = r2.n(n2), o = r2(488), a = r2.n(o), s = a()(i3());
            s.push([t2.id, ".vue-slider{position:relative;-webkit-box-sizing:content-box;box-sizing:content-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;-webkit-tap-highlight-color:rgba(0,0,0,0)}.vue-slider-rail{position:relative;width:100%;height:100%;-webkit-transition-property:width,height,left,right,top,bottom;transition-property:width,height,left,right,top,bottom}.vue-slider-process{position:absolute;z-index:1}", ""]), e2["default"] = s;
          }, 488: function(t2) {
            t2.exports = function(t3) {
              var e2 = [];
              return e2.toString = function() {
                return this.map(function(e3) {
                  var r2 = "", n2 = "undefined" !== typeof e3[5];
                  return e3[4] && (r2 += "@supports (".concat(e3[4], ") {")), e3[2] && (r2 += "@media ".concat(e3[2], " {")), n2 && (r2 += "@layer".concat(e3[5].length > 0 ? " ".concat(e3[5]) : "", " {")), r2 += t3(e3), n2 && (r2 += "}"), e3[2] && (r2 += "}"), e3[4] && (r2 += "}"), r2;
                }).join("");
              }, e2.i = function(t4, r2, n2, i3, o) {
                "string" === typeof t4 && (t4 = [[null, t4, void 0]]);
                var a = {};
                if (n2)
                  for (var s = 0; s < this.length; s++) {
                    var l = this[s][0];
                    null != l && (a[l] = true);
                  }
                for (var u = 0; u < t4.length; u++) {
                  var c = [].concat(t4[u]);
                  n2 && a[c[0]] || ("undefined" !== typeof o && ("undefined" === typeof c[5] || (c[1] = "@layer".concat(c[5].length > 0 ? " ".concat(c[5]) : "", " {").concat(c[1], "}")), c[5] = o), r2 && (c[2] ? (c[1] = "@media ".concat(c[2], " {").concat(c[1], "}"), c[2] = r2) : c[2] = r2), i3 && (c[4] ? (c[1] = "@supports (".concat(c[4], ") {").concat(c[1], "}"), c[4] = i3) : c[4] = "".concat(i3)), e2.push(c));
                }
              }, e2;
            };
          }, 117: function(t2) {
            t2.exports = function(t3) {
              return t3[1];
            };
          }, 831: function(t2, e2) {
            e2.Z = (t3, e3) => {
              const r2 = t3.__vccOpts || t3;
              for (const [n2, i3] of e3)
                r2[n2] = i3;
              return r2;
            };
          }, 466: function(t2, e2, r2) {
            var n2 = r2(905);
            n2.__esModule && (n2 = n2.default), "string" === typeof n2 && (n2 = [[t2.id, n2, ""]]), n2.locals && (t2.exports = n2.locals);
            var i3 = r2(959).Z;
            i3("50bc1720", n2, true, { sourceMap: false, shadowMode: false });
          }, 18: function(t2, e2, r2) {
            var n2 = r2(121);
            n2.__esModule && (n2 = n2.default), "string" === typeof n2 && (n2 = [[t2.id, n2, ""]]), n2.locals && (t2.exports = n2.locals);
            var i3 = r2(959).Z;
            i3("10aa5f36", n2, true, { sourceMap: false, shadowMode: false });
          }, 631: function(t2, e2, r2) {
            var n2 = r2(207);
            n2.__esModule && (n2 = n2.default), "string" === typeof n2 && (n2 = [[t2.id, n2, ""]]), n2.locals && (t2.exports = n2.locals);
            var i3 = r2(959).Z;
            i3("1772934e", n2, true, { sourceMap: false, shadowMode: false });
          }, 959: function(t2, e2, r2) {
            function n2(t3, e3) {
              for (var r3 = [], n3 = {}, i4 = 0; i4 < e3.length; i4++) {
                var o2 = e3[i4], a2 = o2[0], s2 = o2[1], l2 = o2[2], u2 = o2[3], c2 = { id: t3 + ":" + i4, css: s2, media: l2, sourceMap: u2 };
                n3[a2] ? n3[a2].parts.push(c2) : r3.push(n3[a2] = { id: a2, parts: [c2] });
              }
              return r3;
            }
            r2.d(e2, { Z: function() {
              return p2;
            } });
            var i3 = "undefined" !== typeof document;
            if ("undefined" !== typeof DEBUG && DEBUG && !i3)
              throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
            var o = {}, a = i3 && (document.head || document.getElementsByTagName("head")[0]), s = null, l = 0, u = false, c = function() {
            }, d = null, h2 = "data-vue-ssr-id", f = "undefined" !== typeof navigator && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
            function p2(t3, e3, r3, i4) {
              u = r3, d = i4 || {};
              var a2 = n2(t3, e3);
              return m(a2), function(e4) {
                for (var r4 = [], i5 = 0; i5 < a2.length; i5++) {
                  var s2 = a2[i5], l2 = o[s2.id];
                  l2.refs--, r4.push(l2);
                }
                e4 ? (a2 = n2(t3, e4), m(a2)) : a2 = [];
                for (i5 = 0; i5 < r4.length; i5++) {
                  l2 = r4[i5];
                  if (0 === l2.refs) {
                    for (var u2 = 0; u2 < l2.parts.length; u2++)
                      l2.parts[u2]();
                    delete o[l2.id];
                  }
                }
              };
            }
            function m(t3) {
              for (var e3 = 0; e3 < t3.length; e3++) {
                var r3 = t3[e3], n3 = o[r3.id];
                if (n3) {
                  n3.refs++;
                  for (var i4 = 0; i4 < n3.parts.length; i4++)
                    n3.parts[i4](r3.parts[i4]);
                  for (; i4 < r3.parts.length; i4++)
                    n3.parts.push(y(r3.parts[i4]));
                  n3.parts.length > r3.parts.length && (n3.parts.length = r3.parts.length);
                } else {
                  var a2 = [];
                  for (i4 = 0; i4 < r3.parts.length; i4++)
                    a2.push(y(r3.parts[i4]));
                  o[r3.id] = { id: r3.id, refs: 1, parts: a2 };
                }
              }
            }
            function v() {
              var t3 = document.createElement("style");
              return t3.type = "text/css", a.appendChild(t3), t3;
            }
            function y(t3) {
              var e3, r3, n3 = document.querySelector("style[" + h2 + '~="' + t3.id + '"]');
              if (n3) {
                if (u)
                  return c;
                n3.parentNode.removeChild(n3);
              }
              if (f) {
                var i4 = l++;
                n3 = s || (s = v()), e3 = g.bind(null, n3, i4, false), r3 = g.bind(null, n3, i4, true);
              } else
                n3 = v(), e3 = k.bind(null, n3), r3 = function() {
                  n3.parentNode.removeChild(n3);
                };
              return e3(t3), function(n4) {
                if (n4) {
                  if (n4.css === t3.css && n4.media === t3.media && n4.sourceMap === t3.sourceMap)
                    return;
                  e3(t3 = n4);
                } else
                  r3();
              };
            }
            var b = function() {
              var t3 = [];
              return function(e3, r3) {
                return t3[e3] = r3, t3.filter(Boolean).join("\n");
              };
            }();
            function g(t3, e3, r3, n3) {
              var i4 = r3 ? "" : n3.css;
              if (t3.styleSheet)
                t3.styleSheet.cssText = b(e3, i4);
              else {
                var o2 = document.createTextNode(i4), a2 = t3.childNodes;
                a2[e3] && t3.removeChild(a2[e3]), a2.length ? t3.insertBefore(o2, a2[e3]) : t3.appendChild(o2);
              }
            }
            function k(t3, e3) {
              var r3 = e3.css, n3 = e3.media, i4 = e3.sourceMap;
              if (n3 && t3.setAttribute("media", n3), d.ssrId && t3.setAttribute(h2, e3.id), i4 && (r3 += "\n/*# sourceURL=" + i4.sources[0] + " */", r3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(i4)))) + " */"), t3.styleSheet)
                t3.styleSheet.cssText = r3;
              else {
                while (t3.firstChild)
                  t3.removeChild(t3.firstChild);
                t3.appendChild(document.createTextNode(r3));
              }
            }
          }, 927: function(e2) {
            e2.exports = t;
          } }, r = {};
          function n(t2) {
            var i3 = r[t2];
            if (void 0 !== i3)
              return i3.exports;
            var o = r[t2] = { id: t2, exports: {} };
            return e[t2].call(o.exports, o, o.exports, n), o.exports;
          }
          !function() {
            n.n = function(t2) {
              var e2 = t2 && t2.__esModule ? function() {
                return t2["default"];
              } : function() {
                return t2;
              };
              return n.d(e2, { a: e2 }), e2;
            };
          }(), function() {
            n.d = function(t2, e2) {
              for (var r2 in e2)
                n.o(e2, r2) && !n.o(t2, r2) && Object.defineProperty(t2, r2, { enumerable: true, get: e2[r2] });
            };
          }(), function() {
            n.o = function(t2, e2) {
              return Object.prototype.hasOwnProperty.call(t2, e2);
            };
          }(), function() {
            n.r = function(t2) {
              "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
            };
          }(), function() {
            n.p = "";
          }();
          var i2 = {};
          return function() {
            if (n.d(i2, { default: function() {
              return St;
            } }), "undefined" !== typeof window) {
              var t2 = window.document.currentScript, e2 = n(388);
              t2 = e2(), "currentScript" in document || Object.defineProperty(document, "currentScript", { get: e2 });
              var r2 = t2 && t2.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
              r2 && (n.p = r2[1]);
            }
            var o = n(927);
            function a(t3, e3, r3) {
              return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
            }
            var s = { key: 0, class: "vue-slider-marks" };
            function l(t3, e3, r3, n2, i3, l2) {
              var u2 = (0, o.resolveComponent)("vue-slider-mark"), c2 = (0, o.resolveComponent)("vue-slider-dot");
              return (0, o.openBlock)(), (0, o.createElementBlock)("div", (0, o.mergeProps)({ ref: "container", class: t3.containerClasses, style: t3.containerStyles, onClick: e3[1] || (e3[1] = function() {
                return t3.clickHandle && t3.clickHandle.apply(t3, arguments);
              }), onTouchstartPassive: e3[2] || (e3[2] = function() {
                return t3.dragStartOnProcess && t3.dragStartOnProcess.apply(t3, arguments);
              }), onMousedownPassive: e3[3] || (e3[3] = function() {
                return t3.dragStartOnProcess && t3.dragStartOnProcess.apply(t3, arguments);
              }) }, t3.$attrs), [(0, o.createElementVNode)("div", { class: "vue-slider-rail", style: (0, o.normalizeStyle)(t3.railStyle) }, [((0, o.openBlock)(true), (0, o.createElementBlock)(o.Fragment, null, (0, o.renderList)(t3.processArray, function(e4, r4) {
                return (0, o.renderSlot)(t3.$slots, "process", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)), function() {
                  return [((0, o.openBlock)(), (0, o.createElementBlock)("div", { class: "vue-slider-process", key: "process-".concat(r4), style: (0, o.normalizeStyle)(e4.style) }, null, 4))];
                });
              }), 256)), t3.sliderMarks && t3.control ? ((0, o.openBlock)(), (0, o.createElementBlock)("div", s, [((0, o.openBlock)(true), (0, o.createElementBlock)(o.Fragment, null, (0, o.renderList)(t3.control.markList, function(e4, r4) {
                return (0, o.renderSlot)(t3.$slots, "mark", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)), function() {
                  var n3;
                  return [((0, o.openBlock)(), (0, o.createBlock)(u2, { key: "mark-".concat(r4), mark: e4, hideLabel: t3.hideLabel, style: (0, o.normalizeStyle)((n3 = {}, a(n3, t3.isHorizontal ? "height" : "width", "100%"), a(n3, t3.isHorizontal ? "width" : "height", t3.tailSize), a(n3, t3.mainDirection, "".concat(e4.pos, "%")), n3)), stepStyle: t3.stepStyle, stepActiveStyle: t3.stepActiveStyle, labelStyle: t3.labelStyle, labelActiveStyle: t3.labelActiveStyle, onPressLabel: function(e5) {
                    return t3.clickable && t3.setValueByPos(e5);
                  } }, { step: (0, o.withCtx)(function() {
                    return [(0, o.renderSlot)(t3.$slots, "step", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)))];
                  }), label: (0, o.withCtx)(function() {
                    return [(0, o.renderSlot)(t3.$slots, "label", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)))];
                  }), _: 2 }, 1032, ["mark", "hideLabel", "style", "stepStyle", "stepActiveStyle", "labelStyle", "labelActiveStyle", "onPressLabel"]))];
                });
              }), 256))])) : (0, o.createCommentVNode)("", true), ((0, o.openBlock)(true), (0, o.createElementBlock)(o.Fragment, null, (0, o.renderList)(t3.dots, function(r4, n3) {
                var i4;
                return (0, o.openBlock)(), (0, o.createBlock)(c2, (0, o.mergeProps)({ ref_for: true, ref: "dot-".concat(n3), key: "dot-".concat(n3), value: r4.value, disabled: r4.disabled, focus: r4.focus, "dot-style": [r4.style, r4.disabled ? r4.disabledStyle : null, r4.focus ? r4.focusStyle : null], tooltip: r4.tooltip || t3.tooltip, "tooltip-style": [t3.tooltipStyle, r4.tooltipStyle, r4.disabled ? r4.tooltipDisabledStyle : null, r4.focus ? r4.tooltipFocusStyle : null], "tooltip-formatter": Array.isArray(t3.sliderTooltipFormatter) ? t3.sliderTooltipFormatter[n3] : t3.sliderTooltipFormatter, "tooltip-placement": t3.tooltipDirections[n3], style: [t3.dotBaseStyle, (i4 = {}, a(i4, t3.mainDirection, "".concat(r4.pos, "%")), a(i4, "transition", "".concat(t3.mainDirection, " ").concat(t3.animateTime, "s")), i4)], onDragStart: function() {
                  return t3.dragStart(n3);
                }, role: "slider", "aria-valuenow": r4.value, "aria-valuemin": t3.min, "aria-valuemax": t3.max, "aria-orientation": t3.isHorizontal ? "horizontal" : "vertical", tabindex: "0", onFocus: function() {
                  return t3.focus(r4, n3);
                }, onBlur: e3[0] || (e3[0] = function() {
                  return t3.blur();
                }) }, t3.dotAttrs), { dot: (0, o.withCtx)(function() {
                  return [(0, o.renderSlot)(t3.$slots, "dot", (0, o.normalizeProps)((0, o.guardReactiveProps)(r4)))];
                }), tooltip: (0, o.withCtx)(function() {
                  return [(0, o.renderSlot)(t3.$slots, "tooltip", (0, o.normalizeProps)((0, o.guardReactiveProps)(r4)))];
                }), _: 2 }, 1040, ["value", "disabled", "focus", "dot-style", "tooltip", "tooltip-style", "tooltip-formatter", "tooltip-placement", "style", "onDragStart", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "onFocus"]);
              }), 128))], 4), (0, o.renderSlot)(t3.$slots, "default", { value: t3.getValue() })], 16);
            }
            var u = ["aria-valuetext"], c = { class: "vue-slider-dot-tooltip-text" };
            function d(t3, e3, r3, n2, i3, a2) {
              return (0, o.openBlock)(), (0, o.createElementBlock)("div", { ref: "dot", class: (0, o.normalizeClass)(t3.dotClasses), "aria-valuetext": t3.tooltipValue, onMousedownPassive: e3[0] || (e3[0] = function() {
                return t3.dragStart && t3.dragStart.apply(t3, arguments);
              }), onTouchstartPassive: e3[1] || (e3[1] = function() {
                return t3.dragStart && t3.dragStart.apply(t3, arguments);
              }) }, [(0, o.renderSlot)(t3.$slots, "dot", {}, function() {
                return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.handleClasses), style: (0, o.normalizeStyle)(t3.dotStyle) }, null, 6)];
              }), "none" !== t3.tooltip ? ((0, o.openBlock)(), (0, o.createElementBlock)("div", { key: 0, class: (0, o.normalizeClass)(t3.tooltipClasses) }, [(0, o.renderSlot)(t3.$slots, "tooltip", {}, function() {
                return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.tooltipInnerClasses), style: (0, o.normalizeStyle)(t3.tooltipStyle) }, [(0, o.createElementVNode)("span", c, (0, o.toDisplayString)(t3.tooltipValue), 1)], 6)];
              })], 2)) : (0, o.createCommentVNode)("", true)], 42, u);
            }
            n(466);
            var h2 = (0, o.defineComponent)({ name: "VueSliderDot", emits: ["DragStart"], props: { value: { type: [String, Number], default: 0 }, tooltip: { type: String, required: true }, tooltipPlacement: { type: String, validator: function(t3) {
              return ["top", "right", "bottom", "left"].indexOf(t3) > -1;
            }, required: true }, tooltipFormatter: { type: [String, Function] }, focus: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, dotStyle: { type: Object }, tooltipStyle: { type: Object } }, computed: { dotClasses: function() {
              return ["vue-slider-dot", { "vue-slider-dot-hover": "hover" === this.tooltip || "active" === this.tooltip, "vue-slider-dot-disabled": this.disabled, "vue-slider-dot-focus": this.focus }];
            }, handleClasses: function() {
              return ["vue-slider-dot-handle", { "vue-slider-dot-handle-disabled": this.disabled, "vue-slider-dot-handle-focus": this.focus }];
            }, tooltipClasses: function() {
              return ["vue-slider-dot-tooltip", ["vue-slider-dot-tooltip-".concat(this.tooltipPlacement)], { "vue-slider-dot-tooltip-show": this.showTooltip }];
            }, tooltipInnerClasses: function() {
              return ["vue-slider-dot-tooltip-inner", ["vue-slider-dot-tooltip-inner-".concat(this.tooltipPlacement)], { "vue-slider-dot-tooltip-inner-disabled": this.disabled, "vue-slider-dot-tooltip-inner-focus": this.focus }];
            }, showTooltip: function() {
              switch (this.tooltip) {
                case "always":
                  return true;
                case "none":
                  return false;
                case "focus":
                case "active":
                  return !!this.focus;
                default:
                  return false;
              }
            }, tooltipValue: function() {
              return this.tooltipFormatter ? "string" === typeof this.tooltipFormatter ? this.tooltipFormatter.replace(/\{value\}/, String(this.value)) : this.tooltipFormatter(this.value) : this.value;
            } }, methods: { dragStart: function() {
              if (this.disabled)
                return false;
              this.$emit("DragStart");
            } } }), f = n(831);
            const p2 = (0, f.Z)(h2, [["render", d]]);
            var m = p2;
            function v(t3, e3, r3, n2, i3, a2) {
              return (0, o.openBlock)(), (0, o.createElementBlock)("div", { class: (0, o.normalizeClass)(t3.marksClasses) }, [(0, o.renderSlot)(t3.$slots, "step", {}, function() {
                return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.stepClasses), style: (0, o.normalizeStyle)([t3.stepStyle, t3.mark.style, t3.mark.active ? t3.stepActiveStyle : null, t3.mark.active ? t3.mark.activeStyle : null]) }, null, 6)];
              }), t3.hideLabel ? (0, o.createCommentVNode)("", true) : (0, o.renderSlot)(t3.$slots, "label", { key: 0 }, function() {
                return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.labelClasses), style: (0, o.normalizeStyle)([t3.labelStyle, t3.mark.labelStyle, t3.mark.active ? t3.labelActiveStyle : null, t3.mark.active ? t3.mark.labelActiveStyle : null]), onClick: e3[0] || (e3[0] = function() {
                  return t3.labelClickHandle && t3.labelClickHandle.apply(t3, arguments);
                }) }, (0, o.toDisplayString)(t3.mark.label), 7)];
              })], 2);
            }
            n(18);
            var y = (0, o.defineComponent)({ name: "VueSliderMark", emits: ["PressLabel"], props: { mark: { type: Object, required: true }, hideLabel: { type: Boolean }, stepStyle: { type: Object }, stepActiveStyle: { type: Object }, labelStyle: { type: Object }, labelActiveStyle: { type: Object } }, computed: { marksClasses: function() {
              return ["vue-slider-mark", { "vue-slider-mark-active": this.mark.active }];
            }, stepClasses: function() {
              return ["vue-slider-mark-step", { "vue-slider-mark-step-active": this.mark.active }];
            }, labelClasses: function() {
              return ["vue-slider-mark-label", { "vue-slider-mark-label-active": this.mark.active }];
            } }, methods: { labelClickHandle: function(t3) {
              t3.stopPropagation(), this.$emit("PressLabel", this.mark.pos);
            } } });
            const b = (0, f.Z)(y, [["render", v]]);
            var g, k = b, S = function(t3) {
              return "number" === typeof t3 ? "".concat(t3, "px") : t3;
            }, x = function(t3) {
              var e3 = document.documentElement, r3 = document.body, n2 = t3.getBoundingClientRect(), i3 = { y: n2.top + (window.pageYOffset || e3.scrollTop) - (e3.clientTop || r3.clientTop || 0), x: n2.left + (window.pageXOffset || e3.scrollLeft) - (e3.clientLeft || r3.clientLeft || 0) };
              return i3;
            }, P = function(t3, e3, r3) {
              var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, i3 = "targetTouches" in t3 ? t3.targetTouches[0] : t3, o2 = x(e3), a2 = { x: i3.pageX - o2.x, y: i3.pageY - o2.y };
              return { x: r3 ? e3.offsetWidth * n2 - a2.x : a2.x, y: r3 ? e3.offsetHeight * n2 - a2.y : a2.y };
            };
            (function(t3) {
              t3[t3["PAGE_UP"] = 33] = "PAGE_UP", t3[t3["PAGE_DOWN"] = 34] = "PAGE_DOWN", t3[t3["END"] = 35] = "END", t3[t3["HOME"] = 36] = "HOME", t3[t3["LEFT"] = 37] = "LEFT", t3[t3["UP"] = 38] = "UP", t3[t3["RIGHT"] = 39] = "RIGHT", t3[t3["DOWN"] = 40] = "DOWN";
            })(g || (g = {}));
            var w = function(t3, e3) {
              if (e3.hook) {
                var r3 = e3.hook(t3);
                if ("function" === typeof r3)
                  return r3;
                if (!r3)
                  return null;
              }
              switch (t3.keyCode) {
                case g.UP:
                  return function(t4) {
                    return "ttb" === e3.direction ? t4 - 1 : t4 + 1;
                  };
                case g.RIGHT:
                  return function(t4) {
                    return "rtl" === e3.direction ? t4 - 1 : t4 + 1;
                  };
                case g.DOWN:
                  return function(t4) {
                    return "ttb" === e3.direction ? t4 + 1 : t4 - 1;
                  };
                case g.LEFT:
                  return function(t4) {
                    return "rtl" === e3.direction ? t4 + 1 : t4 - 1;
                  };
                case g.END:
                  return function() {
                    return e3.max;
                  };
                case g.HOME:
                  return function() {
                    return e3.min;
                  };
                case g.PAGE_UP:
                  return function(t4) {
                    return t4 + 10;
                  };
                case g.PAGE_DOWN:
                  return function(t4) {
                    return t4 - 10;
                  };
                default:
                  return null;
              }
            };
            function O(t3, e3) {
              if (!(t3 instanceof e3))
                throw new TypeError("Cannot call a class as a function");
            }
            function D(t3, e3) {
              for (var r3 = 0; r3 < e3.length; r3++) {
                var n2 = e3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
              }
            }
            function E(t3, e3, r3) {
              return e3 && D(t3.prototype, e3), r3 && D(t3, r3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
            }
            function R(t3, e3, r3) {
              return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
            }
            var A2, V, j = function() {
              function t3(e3) {
                O(this, t3), R(this, "num", void 0), this.num = e3;
              }
              return E(t3, [{ key: "decimal", value: function(t4, e3) {
                var r3 = this.num, n2 = this.getDecimalLen(r3), i3 = this.getDecimalLen(t4), o2 = 0;
                switch (e3) {
                  case "+":
                    o2 = this.getExponent(n2, i3), this.num = (this.safeRoundUp(r3, o2) + this.safeRoundUp(t4, o2)) / o2;
                    break;
                  case "-":
                    o2 = this.getExponent(n2, i3), this.num = (this.safeRoundUp(r3, o2) - this.safeRoundUp(t4, o2)) / o2;
                    break;
                  case "*":
                    this.num = this.safeRoundUp(this.safeRoundUp(r3, this.getExponent(n2)), this.safeRoundUp(t4, this.getExponent(i3))) / this.getExponent(n2 + i3);
                    break;
                  case "/":
                    o2 = this.getExponent(n2, i3), this.num = this.safeRoundUp(r3, o2) / this.safeRoundUp(t4, o2);
                    break;
                  case "%":
                    o2 = this.getExponent(n2, i3), this.num = this.safeRoundUp(r3, o2) % this.safeRoundUp(t4, o2) / o2;
                    break;
                }
                return this;
              } }, { key: "plus", value: function(t4) {
                return this.decimal(t4, "+");
              } }, { key: "minus", value: function(t4) {
                return this.decimal(t4, "-");
              } }, { key: "multiply", value: function(t4) {
                return this.decimal(t4, "*");
              } }, { key: "divide", value: function(t4) {
                return this.decimal(t4, "/");
              } }, { key: "remainder", value: function(t4) {
                return this.decimal(t4, "%");
              } }, { key: "toNumber", value: function() {
                return this.num;
              } }, { key: "getDecimalLen", value: function(t4) {
                var e3 = "".concat(t4).split("e");
                return ("".concat(e3[0]).split(".")[1] || "").length - (e3[1] ? +e3[1] : 0);
              } }, { key: "getExponent", value: function(t4, e3) {
                return Math.pow(10, void 0 !== e3 ? Math.max(t4, e3) : t4);
              } }, { key: "safeRoundUp", value: function(t4, e3) {
                return Math.round(t4 * e3);
              } }]), t3;
            }();
            function C2(t3, e3) {
              return L(t3) || M(t3, e3) || H(t3, e3) || B2();
            }
            function B2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function M(t3, e3) {
              var r3 = null == t3 ? null : "undefined" !== typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
              if (null != r3) {
                var n2, i3, o2 = [], a2 = true, s2 = false;
                try {
                  for (r3 = r3.call(t3); !(a2 = (n2 = r3.next()).done); a2 = true)
                    if (o2.push(n2.value), e3 && o2.length === e3)
                      break;
                } catch (l2) {
                  s2 = true, i3 = l2;
                } finally {
                  try {
                    a2 || null == r3["return"] || r3["return"]();
                  } finally {
                    if (s2)
                      throw i3;
                  }
                }
                return o2;
              }
            }
            function L(t3) {
              if (Array.isArray(t3))
                return t3;
            }
            function N(t3, e3) {
              var r3 = Object.keys(t3);
              if (Object.getOwnPropertySymbols) {
                var n2 = Object.getOwnPropertySymbols(t3);
                e3 && (n2 = n2.filter(function(e4) {
                  return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
                })), r3.push.apply(r3, n2);
              }
              return r3;
            }
            function z(t3) {
              for (var e3 = 1; e3 < arguments.length; e3++) {
                var r3 = null != arguments[e3] ? arguments[e3] : {};
                e3 % 2 ? N(Object(r3), true).forEach(function(e4) {
                  X(t3, e4, r3[e4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r3)) : N(Object(r3)).forEach(function(e4) {
                  Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r3, e4));
                });
              }
              return t3;
            }
            function I(t3) {
              return $(t3) || F(t3) || H(t3) || T();
            }
            function T() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function H(t3, e3) {
              if (t3) {
                if ("string" === typeof t3)
                  return U(t3, e3);
                var r3 = Object.prototype.toString.call(t3).slice(8, -1);
                return "Object" === r3 && t3.constructor && (r3 = t3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? U(t3, e3) : void 0;
              }
            }
            function F(t3) {
              if ("undefined" !== typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
                return Array.from(t3);
            }
            function $(t3) {
              if (Array.isArray(t3))
                return U(t3);
            }
            function U(t3, e3) {
              (null == e3 || e3 > t3.length) && (e3 = t3.length);
              for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
                n2[r3] = t3[r3];
              return n2;
            }
            function _(t3, e3) {
              if (!(t3 instanceof e3))
                throw new TypeError("Cannot call a class as a function");
            }
            function W(t3, e3) {
              for (var r3 = 0; r3 < e3.length; r3++) {
                var n2 = e3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
              }
            }
            function G(t3, e3, r3) {
              return e3 && W(t3.prototype, e3), r3 && W(t3, r3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
            }
            function X(t3, e3, r3) {
              return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
            }
            (function(t3) {
              t3[t3["VALUE"] = 1] = "VALUE", t3[t3["INTERVAL"] = 2] = "INTERVAL", t3[t3["MIN"] = 3] = "MIN", t3[t3["MAX"] = 4] = "MAX", t3[t3["ORDER"] = 5] = "ORDER";
            })(V || (V = {}));
            var q = (A2 = {}, X(A2, V.VALUE, 'The type of the "value" is illegal'), X(A2, V.INTERVAL, 'The prop "interval" is invalid, "(max - min)" must be divisible by "interval"'), X(A2, V.MIN, 'The "value" must be greater than or equal to the "min".'), X(A2, V.MAX, 'The "value" must be less than or equal to the "max".'), X(A2, V.ORDER, 'When "order" is false, the parameters "minRange", "maxRange", "fixed", "enabled" are invalid.'), A2), Z = function() {
              function t3(e3) {
                _(this, t3), X(this, "dotsPos", []), X(this, "dotsValue", []), X(this, "data", void 0), X(this, "enableCross", void 0), X(this, "fixed", void 0), X(this, "max", void 0), X(this, "min", void 0), X(this, "interval", void 0), X(this, "minRange", void 0), X(this, "maxRange", void 0), X(this, "order", void 0), X(this, "marks", void 0), X(this, "included", void 0), X(this, "process", void 0), X(this, "adsorb", void 0), X(this, "dotOptions", void 0), X(this, "onError", void 0), X(this, "cacheRangeDir", {}), this.data = e3.data, this.max = e3.max, this.min = e3.min, this.interval = e3.interval, this.order = e3.order, this.marks = e3.marks, this.included = e3.included, this.process = e3.process, this.adsorb = e3.adsorb, this.dotOptions = e3.dotOptions, this.onError = e3.onError, this.order ? (this.minRange = e3.minRange || 0, this.maxRange = e3.maxRange || 0, this.enableCross = e3.enableCross, this.fixed = e3.fixed) : ((e3.minRange || e3.maxRange || !e3.enableCross || e3.fixed) && this.emitError(V.ORDER), this.minRange = 0, this.maxRange = 0, this.enableCross = true, this.fixed = false), this.setValue(e3.value);
              }
              return G(t3, [{ key: "setValue", value: function(t4) {
                this.setDotsValue(Array.isArray(t4) ? I(t4) : [t4], true);
              } }, { key: "setDotsValue", value: function(t4, e3) {
                this.dotsValue = t4, e3 && this.syncDotsPos();
              } }, { key: "setDotsPos", value: function(t4) {
                var e3 = this, r3 = this.order ? I(t4).sort(function(t5, e4) {
                  return t5 - e4;
                }) : t4;
                this.dotsPos = r3, this.setDotsValue(r3.map(function(t5) {
                  return e3.getValueByPos(t5);
                }), this.adsorb);
              } }, { key: "getValueByPos", value: function(t4) {
                var e3 = this.parsePos(t4);
                if (this.included) {
                  var r3 = 100;
                  this.markList.forEach(function(n2) {
                    var i3 = Math.abs(n2.pos - t4);
                    i3 < r3 && (r3 = i3, e3 = n2.value);
                  });
                }
                return e3;
              } }, { key: "syncDotsPos", value: function() {
                var t4 = this;
                this.dotsPos = this.dotsValue.map(function(e3) {
                  return t4.parseValue(e3);
                });
              } }, { key: "markList", get: function() {
                var t4 = this;
                if (!this.marks)
                  return [];
                var e3 = function(e4, r3) {
                  var n2 = t4.parseValue(e4);
                  return z({ pos: n2, value: e4, label: e4, active: t4.isActiveByPos(n2) }, r3);
                };
                return true === this.marks ? this.getValues().map(function(t5) {
                  return e3(t5);
                }) : "[object Object]" === Object.prototype.toString.call(this.marks) ? Object.keys(this.marks).sort(function(t5, e4) {
                  return +t5 - +e4;
                }).map(function(r3) {
                  var n2 = t4.marks[r3];
                  return e3(r3, "string" !== typeof n2 ? n2 : { label: n2 });
                }) : Array.isArray(this.marks) ? this.marks.map(function(t5) {
                  return e3(t5);
                }) : "function" === typeof this.marks ? this.getValues().map(function(e4) {
                  return { value: e4, result: t4.marks(e4) };
                }).filter(function(t5) {
                  var e4 = t5.result;
                  return !!e4;
                }).map(function(t5) {
                  var r3 = t5.value, n2 = t5.result;
                  return e3(r3, n2);
                }) : [];
              } }, { key: "getRecentDot", value: function(t4) {
                var e3 = this.dotsPos.map(function(e4) {
                  return Math.abs(e4 - t4);
                });
                return e3.indexOf(Math.min.apply(Math, I(e3)));
              } }, { key: "getIndexByValue", value: function(t4) {
                return this.data ? this.data.indexOf(t4) : new j(+t4).minus(this.min).divide(this.interval).toNumber();
              } }, { key: "getValueByIndex", value: function(t4) {
                return t4 < 0 ? t4 = 0 : t4 > this.total && (t4 = this.total), this.data ? this.data[t4] : new j(t4).multiply(this.interval).plus(this.min).toNumber();
              } }, { key: "setDotPos", value: function(t4, e3) {
                t4 = this.getValidPos(t4, e3).pos;
                var r3 = t4 - this.dotsPos[e3];
                if (r3) {
                  var n2 = new Array(this.dotsPos.length);
                  this.fixed ? n2 = this.getFixedChangePosArr(r3, e3) : this.minRange || this.maxRange ? n2 = this.getLimitRangeChangePosArr(t4, r3, e3) : n2[e3] = r3, this.setDotsPos(this.dotsPos.map(function(t5, e4) {
                    return t5 + (n2[e4] || 0);
                  }));
                }
              } }, { key: "getFixedChangePosArr", value: function(t4, e3) {
                var r3 = this;
                return this.dotsPos.forEach(function(n2, i3) {
                  if (i3 !== e3) {
                    var o2 = r3.getValidPos(n2 + t4, i3), a2 = o2.pos, s2 = o2.inRange;
                    s2 || (t4 = Math.min(Math.abs(a2 - n2), Math.abs(t4)) * (t4 < 0 ? -1 : 1));
                  }
                }), this.dotsPos.map(function(e4) {
                  return t4;
                });
              } }, { key: "getLimitRangeChangePosArr", value: function(t4, e3, r3) {
                var n2 = this, i3 = [{ index: r3, changePos: e3 }], o2 = e3;
                return [this.minRange, this.maxRange].forEach(function(a2, s2) {
                  if (!a2)
                    return false;
                  var l2 = 0 === s2, u2 = e3 > 0, c2 = 0;
                  c2 = l2 ? u2 ? 1 : -1 : u2 ? -1 : 1;
                  var d2 = function(t5, e4) {
                    var r4 = Math.abs(t5 - e4);
                    return l2 ? r4 < n2.minRangeDir : r4 > n2.maxRangeDir;
                  }, h3 = r3 + c2, f2 = n2.dotsPos[h3], p3 = t4;
                  while (n2.isPos(f2) && d2(f2, p3)) {
                    var m2 = n2.getValidPos(f2 + o2, h3), v2 = m2.pos;
                    i3.push({ index: h3, changePos: v2 - f2 }), h3 += c2, p3 = v2, f2 = n2.dotsPos[h3];
                  }
                }), this.dotsPos.map(function(t5, e4) {
                  var r4 = i3.filter(function(t6) {
                    return t6.index === e4;
                  });
                  return r4.length ? r4[0].changePos : 0;
                });
              } }, { key: "isPos", value: function(t4) {
                return "number" === typeof t4;
              } }, { key: "getValidPos", value: function(t4, e3) {
                var r3 = this.valuePosRange[e3], n2 = true;
                return t4 < r3[0] ? (t4 = r3[0], n2 = false) : t4 > r3[1] && (t4 = r3[1], n2 = false), { pos: t4, inRange: n2 };
              } }, { key: "parseValue", value: function(t4) {
                if (this.data)
                  t4 = this.data.indexOf(t4);
                else if ("number" === typeof t4 || "string" === typeof t4) {
                  if (t4 = +t4, t4 < this.min)
                    return this.emitError(V.MIN), 0;
                  if (t4 > this.max)
                    return this.emitError(V.MAX), 0;
                  if ("number" !== typeof t4 || t4 !== t4)
                    return this.emitError(V.VALUE), 0;
                  t4 = new j(t4).minus(this.min).divide(this.interval).toNumber();
                }
                var e3 = new j(t4).multiply(this.gap).toNumber();
                return e3 < 0 ? 0 : e3 > 100 ? 100 : e3;
              } }, { key: "parsePos", value: function(t4) {
                var e3 = Math.round(t4 / this.gap);
                return this.getValueByIndex(e3);
              } }, { key: "isActiveByPos", value: function(t4) {
                return this.processArray.some(function(e3) {
                  var r3 = C2(e3, 2), n2 = r3[0], i3 = r3[1];
                  return t4 >= n2 && t4 <= i3;
                });
              } }, { key: "getValues", value: function() {
                if (this.data)
                  return this.data;
                for (var t4 = [], e3 = 0; e3 <= this.total; e3++)
                  t4.push(new j(e3).multiply(this.interval).plus(this.min).toNumber());
                return t4;
              } }, { key: "getRangeDir", value: function(t4) {
                return t4 ? new j(t4).divide(new j(this.data ? this.data.length - 1 : this.max).minus(this.data ? 0 : this.min).toNumber()).multiply(100).toNumber() : 100;
              } }, { key: "emitError", value: function(t4) {
                this.onError && this.onError(t4, q[t4]);
              } }, { key: "processArray", get: function() {
                if (this.process) {
                  if ("function" === typeof this.process)
                    return this.process(this.dotsPos);
                  if (1 === this.dotsPos.length)
                    return [[0, this.dotsPos[0]]];
                  if (this.dotsPos.length > 1)
                    return [[Math.min.apply(Math, I(this.dotsPos)), Math.max.apply(Math, I(this.dotsPos))]];
                }
                return [];
              } }, { key: "total", get: function() {
                var t4 = 0;
                return t4 = this.data ? this.data.length - 1 : new j(this.max).minus(this.min).divide(this.interval).toNumber(), t4 - Math.floor(t4) !== 0 ? (this.emitError(V.INTERVAL), 0) : t4;
              } }, { key: "gap", get: function() {
                return 100 / this.total;
              } }, { key: "minRangeDir", get: function() {
                return this.cacheRangeDir[this.minRange] ? this.cacheRangeDir[this.minRange] : this.cacheRangeDir[this.minRange] = this.getRangeDir(this.minRange);
              } }, { key: "maxRangeDir", get: function() {
                return this.cacheRangeDir[this.maxRange] ? this.cacheRangeDir[this.maxRange] : this.cacheRangeDir[this.maxRange] = this.getRangeDir(this.maxRange);
              } }, { key: "getDotRange", value: function(t4, e3, r3) {
                if (!this.dotOptions)
                  return r3;
                var n2 = Array.isArray(this.dotOptions) ? this.dotOptions[t4] : this.dotOptions;
                return n2 && void 0 !== n2[e3] ? this.parseValue(n2[e3]) : r3;
              } }, { key: "valuePosRange", get: function() {
                var t4 = this, e3 = this.dotsPos, r3 = [];
                return e3.forEach(function(n2, i3) {
                  r3.push([Math.max(t4.minRange ? t4.minRangeDir * i3 : 0, t4.enableCross ? 0 : e3[i3 - 1] || 0, t4.getDotRange(i3, "min", 0)), Math.min(t4.minRange ? 100 - t4.minRangeDir * (e3.length - 1 - i3) : 100, t4.enableCross ? 100 : e3[i3 + 1] || 100, t4.getDotRange(i3, "max", 100))]);
                }), r3;
              } }, { key: "dotsIndex", get: function() {
                var t4 = this;
                return this.dotsValue.map(function(e3) {
                  return t4.getIndexByValue(e3);
                });
              } }]), t3;
            }();
            function Y(t3, e3) {
              if (!(t3 instanceof e3))
                throw new TypeError("Cannot call a class as a function");
            }
            function K(t3, e3) {
              for (var r3 = 0; r3 < e3.length; r3++) {
                var n2 = e3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
              }
            }
            function J(t3, e3, r3) {
              return e3 && K(t3.prototype, e3), r3 && K(t3, r3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
            }
            function Q(t3, e3, r3) {
              return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
            }
            var tt = function() {
              function t3(e3) {
                Y(this, t3), Q(this, "map", void 0), Q(this, "states", 0), this.map = e3;
              }
              return J(t3, [{ key: "add", value: function(t4) {
                this.states |= t4;
              } }, { key: "delete", value: function(t4) {
                this.states &= ~t4;
              } }, { key: "toggle", value: function(t4) {
                this.has(t4) ? this.delete(t4) : this.add(t4);
              } }, { key: "has", value: function(t4) {
                return !!(this.states & t4);
              } }]), t3;
            }();
            n(631);
            function et(t3) {
              return it(t3) || nt(t3) || dt(t3) || rt();
            }
            function rt() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function nt(t3) {
              if ("undefined" !== typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
                return Array.from(t3);
            }
            function it(t3) {
              if (Array.isArray(t3))
                return ht(t3);
            }
            function ot(t3) {
              return ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
                return typeof t4;
              } : function(t4) {
                return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
              }, ot(t3);
            }
            function at(t3, e3) {
              var r3 = Object.keys(t3);
              if (Object.getOwnPropertySymbols) {
                var n2 = Object.getOwnPropertySymbols(t3);
                e3 && (n2 = n2.filter(function(e4) {
                  return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
                })), r3.push.apply(r3, n2);
              }
              return r3;
            }
            function st(t3) {
              for (var e3 = 1; e3 < arguments.length; e3++) {
                var r3 = null != arguments[e3] ? arguments[e3] : {};
                e3 % 2 ? at(Object(r3), true).forEach(function(e4) {
                  lt(t3, e4, r3[e4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r3)) : at(Object(r3)).forEach(function(e4) {
                  Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r3, e4));
                });
              }
              return t3;
            }
            function lt(t3, e3, r3) {
              return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
            }
            function ut(t3, e3) {
              return pt(t3) || ft(t3, e3) || dt(t3, e3) || ct();
            }
            function ct() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function dt(t3, e3) {
              if (t3) {
                if ("string" === typeof t3)
                  return ht(t3, e3);
                var r3 = Object.prototype.toString.call(t3).slice(8, -1);
                return "Object" === r3 && t3.constructor && (r3 = t3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? ht(t3, e3) : void 0;
              }
            }
            function ht(t3, e3) {
              (null == e3 || e3 > t3.length) && (e3 = t3.length);
              for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
                n2[r3] = t3[r3];
              return n2;
            }
            function ft(t3, e3) {
              var r3 = null == t3 ? null : "undefined" !== typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
              if (null != r3) {
                var n2, i3, o2 = [], a2 = true, s2 = false;
                try {
                  for (r3 = r3.call(t3); !(a2 = (n2 = r3.next()).done); a2 = true)
                    if (o2.push(n2.value), e3 && o2.length === e3)
                      break;
                } catch (l2) {
                  s2 = true, i3 = l2;
                } finally {
                  try {
                    a2 || null == r3["return"] || r3["return"]();
                  } finally {
                    if (s2)
                      throw i3;
                  }
                }
                return o2;
              }
            }
            function pt(t3) {
              if (Array.isArray(t3))
                return t3;
            }
            var mt = { None: 0, Drag: 2, Focus: 4 }, vt = 4, yt = (0, o.defineComponent)({ name: "VueSlider", components: { VueSliderDot: m, VueSliderMark: k }, emits: ["change", "drag-start", "dragging", "drag-end", "error", "update:modelValue"], data: function() {
              return { control: null, states: new tt(mt), scale: 1, focusDotIndex: 0 };
            }, props: { modelValue: { type: [Number, String, Array], default: 0 }, silent: { type: Boolean, default: false }, direction: { type: String, default: "ltr", validator: function(t3) {
              return ["ltr", "rtl", "ttb", "btt"].indexOf(t3) > -1;
            } }, width: { type: [Number, String] }, height: { type: [Number, String] }, dotSize: { type: [Number, Array], default: 14 }, contained: { type: Boolean, default: false }, min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, interval: { type: Number, default: 1 }, disabled: { type: Boolean, default: false }, clickable: { type: Boolean, default: true }, dragOnClick: { type: Boolean, default: false }, duration: { type: Number, default: 0.5 }, data: { type: [Object, Array] }, dataValue: { type: String, default: "value" }, dataLabel: { type: String, default: "label" }, lazy: { type: Boolean, default: false }, tooltip: { type: String, default: "active", validator: function(t3) {
              return ["none", "always", "focus", "hover", "active"].indexOf(t3) > -1;
            } }, tooltipPlacement: { type: [String, Array], validator: function(t3) {
              return (Array.isArray(t3) ? t3 : [t3]).every(function(t4) {
                return ["top", "right", "bottom", "left"].indexOf(t4) > -1;
              });
            } }, tooltipFormatter: { type: [String, Array, Function] }, useKeyboard: { type: Boolean, default: true }, keydownHook: { type: Function }, enableCross: { type: Boolean, default: true }, fixed: { type: Boolean, default: false }, order: { type: Boolean, default: true }, minRange: { type: Number }, maxRange: { type: Number }, marks: { type: [Boolean, Object, Array, Function], default: false }, process: { type: [Boolean, Function], default: true }, zoom: { type: Number }, included: { type: Boolean }, adsorb: { type: Boolean }, hideLabel: { type: Boolean }, dotOptions: { type: [Object, Array] }, dotAttrs: { type: Object }, railStyle: { type: Object }, processStyle: { type: Object }, dotStyle: { type: Object }, tooltipStyle: { type: Object }, stepStyle: { type: Object }, stepActiveStyle: { type: Object }, labelStyle: { type: Object }, labelActiveStyle: { type: Object } }, computed: { isHorizontal: function() {
              return "ltr" === this.direction || "rtl" === this.direction;
            }, isReverse: function() {
              return "rtl" === this.direction || "btt" === this.direction;
            }, tailSize: function() {
              return S((this.isHorizontal ? this.height : this.width) || vt);
            }, containerClasses: function() {
              return ["vue-slider", ["vue-slider-".concat(this.direction)], { "vue-slider-disabled": this.disabled }];
            }, containerStyles: function() {
              var t3 = Array.isArray(this.dotSize) ? this.dotSize : [this.dotSize, this.dotSize], e3 = ut(t3, 2), r3 = e3[0], n2 = e3[1], i3 = this.width ? S(this.width) : this.isHorizontal ? "auto" : S(vt), o2 = this.height ? S(this.height) : this.isHorizontal ? S(vt) : "auto";
              return { padding: this.contained ? "".concat(n2 / 2, "px ").concat(r3 / 2, "px") : this.isHorizontal ? "".concat(n2 / 2, "px 0") : "0 ".concat(r3 / 2, "px"), width: i3, height: o2 };
            }, processArray: function() {
              var t3 = this;
              return this.control.processArray.map(function(e3, r3) {
                var n2, i3 = ut(e3, 3), o2 = i3[0], a2 = i3[1], s2 = i3[2];
                if (o2 > a2) {
                  var l2 = [a2, o2];
                  o2 = l2[0], a2 = l2[1];
                }
                var u2 = t3.isHorizontal ? "width" : "height";
                return { start: o2, end: a2, index: r3, style: st(st((n2 = {}, lt(n2, t3.isHorizontal ? "height" : "width", "100%"), lt(n2, t3.isHorizontal ? "top" : "left", 0), lt(n2, t3.mainDirection, "".concat(o2, "%")), lt(n2, u2, "".concat(a2 - o2, "%")), lt(n2, "transitionProperty", "".concat(u2, ",").concat(t3.mainDirection)), lt(n2, "transitionDuration", "".concat(t3.animateTime, "s")), n2), t3.processStyle), s2) };
              });
            }, dotBaseStyle: function() {
              var t3, e3 = Array.isArray(this.dotSize) ? this.dotSize : [this.dotSize, this.dotSize], r3 = ut(e3, 2), n2 = r3[0], i3 = r3[1];
              return t3 = this.isHorizontal ? lt({ transform: "translate(".concat(this.isReverse ? "50%" : "-50%", ", -50%)"), WebkitTransform: "translate(".concat(this.isReverse ? "50%" : "-50%", ", -50%)"), top: "50%" }, "ltr" === this.direction ? "left" : "right", "0") : lt({ transform: "translate(-50%, ".concat(this.isReverse ? "50%" : "-50%", ")"), WebkitTransform: "translate(-50%, ".concat(this.isReverse ? "50%" : "-50%", ")"), left: "50%" }, "btt" === this.direction ? "bottom" : "top", "0"), st({ width: "".concat(n2, "px"), height: "".concat(i3, "px") }, t3);
            }, mainDirection: function() {
              switch (this.direction) {
                case "ltr":
                  return "left";
                case "rtl":
                  return "right";
                case "btt":
                  return "bottom";
                case "ttb":
                  return "top";
                default:
                  return "left";
              }
            }, tooltipDirections: function() {
              var t3 = this.tooltipPlacement || (this.isHorizontal ? "top" : "left");
              return Array.isArray(t3) ? t3 : this.dots.map(function() {
                return t3;
              });
            }, dots: function() {
              var t3 = this;
              return this.control.dotsPos.map(function(e3, r3) {
                return st({ pos: e3, index: r3, value: t3.control.dotsValue[r3], focus: t3.states.has(mt.Focus) && t3.focusDotIndex === r3, disabled: t3.disabled, style: t3.dotStyle }, (Array.isArray(t3.dotOptions) ? t3.dotOptions[r3] : t3.dotOptions) || {});
              });
            }, animateTime: function() {
              return this.states.has(mt.Drag) ? 0 : this.duration;
            }, canSort: function() {
              return this.order && !this.minRange && !this.maxRange && !this.fixed && this.enableCross;
            }, sliderData: function() {
              var t3 = this;
              return this.isObjectArrayData(this.data) ? this.data.map(function(e3) {
                return e3[t3.dataValue];
              }) : this.isObjectData(this.data) ? Object.keys(this.data) : this.data;
            }, sliderMarks: function() {
              var t3 = this;
              return this.marks ? this.marks : this.isObjectArrayData(this.data) ? function(e3) {
                var r3 = { label: e3 };
                return t3.data.some(function(n2) {
                  return n2[t3.dataValue] === e3 && (r3.label = n2[t3.dataLabel], true);
                }), r3;
              } : this.isObjectData(this.data) ? this.data : void 0;
            }, sliderTooltipFormatter: function() {
              var t3 = this;
              if (this.tooltipFormatter)
                return this.tooltipFormatter;
              if (this.isObjectArrayData(this.data))
                return function(e4) {
                  var r3 = "" + e4;
                  return t3.data.some(function(n2) {
                    return n2[t3.dataValue] === e4 && (r3 = n2[t3.dataLabel], true);
                  }), r3;
                };
              if (this.isObjectData(this.data)) {
                var e3 = this.data;
                return function(t4) {
                  return e3[t4];
                };
              }
            }, isNotSync: function() {
              var t3 = this.control.dotsValue;
              return Array.isArray(this.modelValue) ? this.modelValue.length !== t3.length || this.modelValue.some(function(e3, r3) {
                return e3 !== t3[r3];
              }) : this.modelValue !== t3[0];
            }, dragRange: function() {
              var t3 = this.dots[this.focusDotIndex - 1], e3 = this.dots[this.focusDotIndex + 1];
              return [t3 ? t3.pos : -1 / 0, e3 ? e3.pos : 1 / 0];
            } }, watch: { modelValue: function() {
              this.control && !this.states.has(mt.Drag) && this.isNotSync && this.control.setValue(this.modelValue);
            } }, methods: { isObjectData: function(t3) {
              return !!t3 && "[object Object]" === Object.prototype.toString.call(t3);
            }, isObjectArrayData: function(t3) {
              return !!t3 && Array.isArray(t3) && t3.length > 0 && "object" === ot(t3[0]);
            }, bindEvent: function() {
              document.addEventListener("touchmove", this.dragMove, { passive: false }), document.addEventListener("touchend", this.dragEnd, { passive: false }), document.addEventListener("mousedown", this.blurHandle), document.addEventListener("mousemove", this.dragMove), document.addEventListener("mouseup", this.dragEnd), document.addEventListener("mouseleave", this.dragEnd), document.addEventListener("keydown", this.keydownHandle);
            }, unbindEvent: function() {
              document.removeEventListener("touchmove", this.dragMove), document.removeEventListener("touchend", this.dragEnd), document.removeEventListener("mousedown", this.blurHandle), document.removeEventListener("mousemove", this.dragMove), document.removeEventListener("mouseup", this.dragEnd), document.removeEventListener("mouseleave", this.dragEnd), document.removeEventListener("keydown", this.keydownHandle);
            }, setScale: function() {
              this.scale = new j(Math.floor(this.isHorizontal ? this.$el.offsetWidth : this.$el.offsetHeight)).multiply(this.zoom || 1).divide(100).toNumber();
            }, initControl: function() {
              var t3 = this;
              this.control = new Z({ value: this.modelValue, data: this.sliderData, enableCross: this.enableCross, fixed: this.fixed, max: this.max, min: this.min, interval: this.interval, minRange: this.minRange, maxRange: this.maxRange, order: this.order, marks: this.sliderMarks, included: this.included, process: this.process, adsorb: this.adsorb, dotOptions: this.dotOptions, onError: this.emitError }), ["data", "enableCross", "fixed", "max", "min", "interval", "minRange", "maxRange", "order", "marks", "process", "adsorb", "included", "dotOptions"].forEach(function(e3) {
                t3.$watch(e3, function(r3) {
                  if ("data" === e3 && Array.isArray(t3.control.data) && Array.isArray(r3) && t3.control.data.length === r3.length && r3.every(function(e4, r4) {
                    return e4 === t3.control.data[r4];
                  }))
                    return false;
                  switch (e3) {
                    case "data":
                    case "dataLabel":
                    case "dataValue":
                      t3.control.data = t3.sliderData;
                      break;
                    case "mark":
                      t3.control.marks = t3.sliderMarks;
                      break;
                    default:
                      t3.control[e3] = r3;
                  }
                  ["data", "max", "min", "interval"].indexOf(e3) > -1 && t3.control.syncDotsPos();
                });
              });
            }, syncValueByPos: function() {
              var t3 = this.control.dotsValue;
              if (this.isDiff(t3, Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue])) {
                var e3 = 1 === t3.length ? t3[0] : et(t3);
                this.$emit("change", e3, this.focusDotIndex), this.$emit("update:modelValue", e3);
              }
            }, isDiff: function(t3, e3) {
              return t3.length !== e3.length || t3.some(function(t4, r3) {
                return t4 !== e3[r3];
              });
            }, emitError: function(t3, e3) {
              this.silent || console.error("[VueSlider error]: ".concat(e3)), this.$emit("error", t3, e3);
            }, dragStartOnProcess: function(t3) {
              if (this.dragOnClick) {
                this.setScale();
                var e3 = this.getPosByEvent(t3), r3 = this.control.getRecentDot(e3);
                if (this.dots[r3].disabled)
                  return;
                this.dragStart(r3), this.control.setDotPos(e3, this.focusDotIndex), this.lazy || this.syncValueByPos();
              }
            }, dragStart: function(t3) {
              this.focusDotIndex = t3, this.setScale(), this.states.add(mt.Drag), this.states.add(mt.Focus), this.$emit("drag-start", this.focusDotIndex);
            }, dragMove: function(t3) {
              if (!this.states.has(mt.Drag))
                return false;
              t3.preventDefault();
              var e3 = this.getPosByEvent(t3);
              this.isCrossDot(e3), this.control.setDotPos(e3, this.focusDotIndex), this.lazy || this.syncValueByPos();
              var r3 = this.control.dotsValue;
              this.$emit("dragging", 1 === r3.length ? r3[0] : et(r3), this.focusDotIndex);
            }, isCrossDot: function(t3) {
              if (this.canSort) {
                var e3 = this.focusDotIndex, r3 = t3;
                if (r3 > this.dragRange[1] ? (r3 = this.dragRange[1], this.focusDotIndex++) : r3 < this.dragRange[0] && (r3 = this.dragRange[0], this.focusDotIndex--), e3 !== this.focusDotIndex) {
                  var n2 = this.$refs["dot-".concat(this.focusDotIndex)];
                  n2 && n2.$el && n2.$el.focus(), this.control.setDotPos(r3, e3);
                }
              }
            }, dragEnd: function(t3) {
              var e3 = this;
              if (!this.states.has(mt.Drag))
                return false;
              setTimeout(function() {
                e3.lazy && e3.syncValueByPos(), e3.included && e3.isNotSync ? e3.control.setValue(e3.modelValue) : e3.control.syncDotsPos(), e3.states.delete(mt.Drag), e3.useKeyboard && !("targetTouches" in t3) || e3.states.delete(mt.Focus), e3.$emit("drag-end", e3.focusDotIndex);
              });
            }, blurHandle: function(t3) {
              if (!this.states.has(mt.Focus) || !this.$refs.container || this.$refs.container.contains(t3.target))
                return false;
              this.states.delete(mt.Focus);
            }, clickHandle: function(t3) {
              if (!this.clickable || this.disabled)
                return false;
              if (!this.states.has(mt.Drag)) {
                this.setScale();
                var e3 = this.getPosByEvent(t3);
                this.setValueByPos(e3);
              }
            }, focus: function(t3) {
              var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              t3.disabled || (this.states.add(mt.Focus), this.focusDotIndex = e3);
            }, blur: function() {
              this.states.delete(mt.Focus);
            }, getValue: function() {
              var t3 = this.control.dotsValue;
              return 1 === t3.length ? t3[0] : t3;
            }, getIndex: function() {
              var t3 = this.control.dotsIndex;
              return 1 === t3.length ? t3[0] : t3;
            }, setValue: function(t3) {
              this.control.setValue(Array.isArray(t3) ? et(t3) : [t3]), this.syncValueByPos();
            }, setIndex: function(t3) {
              var e3 = this, r3 = Array.isArray(t3) ? t3.map(function(t4) {
                return e3.control.getValueByIndex(t4);
              }) : this.control.getValueByIndex(t3);
              this.setValue(r3);
            }, setValueByPos: function(t3) {
              var e3 = this, r3 = this.control.getRecentDot(t3);
              if (this.disabled || this.dots[r3].disabled)
                return false;
              this.focusDotIndex = r3, this.control.setDotPos(t3, r3), this.syncValueByPos(), this.useKeyboard && this.states.add(mt.Focus), setTimeout(function() {
                e3.included && e3.isNotSync ? e3.control.setValue(e3.modelValue) : e3.control.syncDotsPos();
              });
            }, keydownHandle: function(t3) {
              var e3 = this;
              if (!this.useKeyboard || !this.states.has(mt.Focus))
                return false;
              var r3 = this.included && this.marks, n2 = w(t3, { direction: this.direction, max: r3 ? this.control.markList.length - 1 : this.control.total, min: 0, hook: this.keydownHook });
              if (n2) {
                t3.preventDefault();
                var i3 = -1, o2 = 0;
                r3 ? (this.control.markList.some(function(t4, r4) {
                  return t4.value === e3.control.dotsValue[e3.focusDotIndex] && (i3 = n2(r4), true);
                }), i3 < 0 ? i3 = 0 : i3 > this.control.markList.length - 1 && (i3 = this.control.markList.length - 1), o2 = this.control.markList[i3].pos) : (i3 = n2(this.control.getIndexByValue(this.control.dotsValue[this.focusDotIndex])), o2 = this.control.parseValue(this.control.getValueByIndex(i3))), this.isCrossDot(o2), this.control.setDotPos(o2, this.focusDotIndex), this.syncValueByPos();
              }
            }, getPosByEvent: function(t3) {
              return P(t3, this.$el, this.isReverse, this.zoom)[this.isHorizontal ? "x" : "y"] / this.scale;
            }, renderSlot: function(t3, e3, r3) {
              var n2 = this.$slots[t3];
              return n2 ? n2(e3) : r3;
            } }, created: function() {
              this.initControl();
            }, mounted: function() {
              this.bindEvent();
            }, beforeUnmount: function() {
              this.unbindEvent();
            } });
            const bt = (0, f.Z)(yt, [["render", l]]);
            var gt = bt;
            gt.VueSliderMark = k, gt.VueSliderDot = m;
            var kt = gt, St = kt;
          }(), i2 = i2["default"], i2;
        }();
      });
    })(vueSliderComponent_umd_min);
    const VueSlider = /* @__PURE__ */ getDefaultExportFromCjs(vueSliderComponent_umd_min.exports);
    const _sfc_main$E = /* @__PURE__ */ defineComponent({
      __name: "Slider",
      setup(__props) {
        const props = __props;
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref$1(VueSlider), mergeProps({ tooltip: "none" }, props), null, 16);
        };
      }
    });
    const Slider_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$y = { class: "label" };
    const _hoisted_2$n = ["value"];
    const _sfc_main$D = /* @__PURE__ */ defineComponent({
      __name: "SliderItem",
      props: {
        label: null,
        type: null,
        wrapperClass: null,
        modelValue: null
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const props = __props;
        const __$temp_1 = props, label = toRef(__$temp_1, "label"), wrapperClass = toRef(__$temp_1, "wrapperClass"), type2 = toRef(__$temp_1, "type", "text"), modelValue = toRef(__$temp_1, "modelValue");
        let value = computed({
          get: () => modelValue.value,
          set: (val) => {
            emit("update:model-value", val);
          }
        });
        const handleChange = (e) => {
          const elem = e.target;
          if (elem.value.length > 4) {
            elem.value = elem.value.slice(0, 4);
          } else {
            value.value = parseFloat(elem.value) || 0;
          }
        };
        const handleDragEnd = () => {
          emitter.emit("saveHistory");
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["item", wrapperClass.value])
          }, [
            createBaseVNode("div", _hoisted_1$y, toDisplayString(label.value), 1),
            createBaseVNode("div", {
              class: normalizeClass(["value", `value-type-${type2.value}`])
            }, [
              type2.value === "angle" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "angle-point",
                style: normalizeStyle({ transform: `rotate(${value.value - 90}deg)` })
              }, null, 4)) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "text",
                value: value.value,
                onChange: handleChange
              }, null, 40, _hoisted_2$n)
            ], 2),
            createVNode(_sfc_main$E, mergeProps({ class: "slider" }, _ctx.$attrs, {
              modelValue: value.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event),
              contained: true,
              max: Math.max(_ctx.$attrs.max || 0, value.value),
              onDragEnd: handleDragEnd
            }), null, 16, ["modelValue", "max"]),
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 2);
        };
      }
    });
    const SliderItem_vue_vue_type_style_index_0_scoped_0d19e3ad_lang = "";
    const SliderItem = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-0d19e3ad"]]);
    const _sfc_main$C = /* @__PURE__ */ defineComponent({
      __name: "ContainerGroup",
      props: {
        node: null,
        container: null
      },
      setup(__props) {
        const showFilterCode = ref(false);
        const presetShadow = computed(() => [
          "0 2px 2px 0 rgba(0,0,0,0.16), 0 0 0 1px rgba(0,0,0,0.08)",
          "0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.2)",
          "0 2px 5px 0 rgba(0,0,0,0.26), 0 2px 10px 0 rgba(0,0,0,0.16)",
          "5px 5px 50px 10px rgba(158,155,158,0.15)",
          "0 6px 6px rgba(10,16,20,.15), 0 0 52px rgba(10,16,20,.12)",
          "0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.2)"
        ]);
        const blur = computed({
          get() {
            var _a, _b;
            return parseFloat(((_b = (_a = __props.container.filter) == null ? void 0 : _a.match(/blur\((\d+)px\)/)) == null ? void 0 : _b[1]) || "") || 0;
          },
          set(val) {
            if (val > 0) {
              __props.container.filter = `blur(${val}px)`;
            } else {
              __props.container.filter = "";
            }
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "container",
            class: "container-group",
            "can-advanced": true,
            "default-collapsed": false
          }, {
            default: withCtx(({ showAdvanced }) => [
              createVNode(SliderItem, {
                label: _ctx.$t("opacity"),
                modelValue: __props.container.opacity,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => __props.container.opacity = $event),
                min: 0,
                max: 1,
                interval: 0.01
              }, null, 8, ["label", "modelValue", "interval"]),
              createVNode(SelectItem, {
                label: _ctx.$t("overflow"),
                options: { visible: _ctx.$t("visible"), hidden: _ctx.$t("hidden"), scroll: _ctx.$t("scroll"), auto: _ctx.$t("auto") },
                modelValue: __props.container.overflow,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => __props.container.overflow = $event)
              }, null, 8, ["label", "options", "modelValue"]),
              createVNode(SelectItem, {
                label: _ctx.$t("cursor"),
                options: {
                  inherit: _ctx.$t("inherit"),
                  auto: _ctx.$t("auto"),
                  default: _ctx.$t("default"),
                  pointer: _ctx.$t("pointer"),
                  move: _ctx.$t("move"),
                  text: _ctx.$t("text"),
                  wait: _ctx.$t("wait"),
                  help: _ctx.$t("help"),
                  "not-allowed": _ctx.$t("notAllowed")
                },
                modelValue: __props.container.cursor,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => __props.container.cursor = $event)
              }, null, 8, ["label", "options", "modelValue"]),
              createVNode(SliderItem, {
                label: _ctx.$t("filterBlur"),
                modelValue: blur.value,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => blur.value = $event),
                min: 0,
                max: 20,
                interval: 1,
                onDblclick: _cache[4] || (_cache[4] = ($event) => showFilterCode.value = !showFilterCode.value)
              }, null, 8, ["label", "modelValue"]),
              showFilterCode.value ? (openBlock(), createBlock(InputItem, {
                key: 0,
                label: _ctx.$t("filterCode"),
                modelValue: __props.container.filter,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => __props.container.filter = $event)
              }, null, 8, ["label", "modelValue"])) : createCommentVNode("", true),
              createVNode(PreviewItem, {
                label: _ctx.$t("shadow"),
                modelValue: __props.container.boxShadow,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => __props.container.boxShadow = $event),
                options: presetShadow.value
              }, {
                default: withCtx(({ item: shadow, active }) => [
                  createBaseVNode("div", {
                    class: normalizeClass(["inner", { active }]),
                    style: normalizeStyle({ boxShadow: shadow })
                  }, null, 6)
                ]),
                _: 1
              }, 8, ["label", "modelValue", "options"]),
              showAdvanced ? (openBlock(), createBlock(InputItem, {
                key: 1,
                label: _ctx.$t("customShadow"),
                modelValue: __props.container.boxShadow,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => __props.container.boxShadow = $event)
              }, null, 8, ["label", "modelValue"])) : createCommentVNode("", true)
            ]),
            _: 1
          });
        };
      }
    });
    const ContainerGroup_vue_vue_type_style_index_0_scoped_a2fa5fb8_lang = "";
    const ContainerGroup = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__scopeId", "data-v-a2fa5fb8"]]);
    const _hoisted_1$x = ["onClick"];
    const _sfc_main$B = /* @__PURE__ */ defineComponent({
      __name: "PositionTable",
      props: {
        modelValue: null,
        options: null,
        size: { default: 88 }
      },
      emits: ["update:model-value"],
      setup(__props, { emit }) {
        const handleClick = (key) => {
          emit("update:model-value", key);
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: "position-table",
            style: normalizeStyle({ width: `${__props.size}px`, height: `${__props.size}px` })
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (key) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(["position-item", { active: key === __props.modelValue }]),
                key,
                onClick: () => handleClick(key)
              }, null, 10, _hoisted_1$x);
            }), 128))
          ], 4);
        };
      }
    });
    const PositionTable_vue_vue_type_style_index_0_scoped_f301904b_lang = "";
    const PositionTable = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__scopeId", "data-v-f301904b"]]);
    const _hoisted_1$w = { class: "item" };
    const _hoisted_2$m = { class: "label" };
    const _hoisted_3$k = {
      key: 0,
      class: "item"
    };
    const _hoisted_4$a = { class: "item" };
    const _sfc_main$A = /* @__PURE__ */ defineComponent({
      __name: "BackgroundGroup",
      props: {
        node: null,
        background: null
      },
      setup(__props) {
        const updateBackgroundType = (type2) => {
          __props.background.backgroundType = type2;
          if (type2 === "gradient") {
            __props.background.backgroundGradient = [
              {
                color: "#fff",
                percentage: 0
              },
              {
                color: "#000",
                percentage: 100
              }
            ];
          }
        };
        const handleAddColor = () => {
          __props.background.backgroundGradient.push({
            color: __props.background.backgroundGradient[__props.background.backgroundGradient.length - 1].color,
            percentage: 100
          });
        };
        const deleteColor = (index2) => {
          if (__props.background.backgroundGradient.length <= 2)
            return;
          __props.background.backgroundGradient.splice(index2, 1);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "background",
            class: "background-group",
            "can-advanced": false,
            "default-collapsed": false
          }, {
            default: withCtx(() => [
              createVNode(SelectItem, {
                "model-value": __props.background.backgroundType,
                label: _ctx.$t("background"),
                options: {
                  none: _ctx.$t("backgroundTypeNone"),
                  color: _ctx.$t("backgroundTypeColor"),
                  image: _ctx.$t("backgroundTypeImage"),
                  gradient: _ctx.$t("backgroundTypeGradient")
                },
                "onUpdate:modelValue": updateBackgroundType
              }, null, 8, ["model-value", "label", "options"]),
              __props.background.backgroundType === "color" ? (openBlock(), createBlock(ColorItem, {
                key: 0,
                "model-value": __props.background.backgroundColor,
                label: _ctx.$t("backgroundColor"),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = (color) => __props.background.backgroundColor = color)
              }, null, 8, ["model-value", "label"])) : createCommentVNode("", true),
              __props.background.backgroundType === "image" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createVNode(ImageItem, {
                  label: _ctx.$t("backgroundLink"),
                  "model-value": __props.background.backgroundImage,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (image) => __props.background.backgroundImage = image)
                }, null, 8, ["label", "model-value"]),
                createVNode(TabsItemVue, {
                  label: _ctx.$t("backgroundSize"),
                  data: {
                    cover: _ctx.$t("backgroundSizeCover"),
                    contain: _ctx.$t("backgroundSizeContain"),
                    auto: _ctx.$t("backgroundSizeAuto")
                  },
                  modelValue: __props.background.backgroundSize,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => __props.background.backgroundSize = $event)
                }, null, 8, ["label", "data", "modelValue"]),
                createBaseVNode("div", _hoisted_1$w, [
                  createBaseVNode("div", _hoisted_2$m, toDisplayString(_ctx.$t("backgroundPosition")), 1),
                  createVNode(PositionTable, {
                    modelValue: __props.background.backgroundPosition,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => __props.background.backgroundPosition = $event),
                    options: [
                      "left top",
                      "top",
                      "right top",
                      "left",
                      "center",
                      "right",
                      "left bottom",
                      "bottom",
                      "right bottom"
                    ]
                  }, null, 8, ["modelValue"])
                ]),
                createVNode(SelectItem, {
                  label: _ctx.$t("backgroundRepeat"),
                  options: {
                    repeat: _ctx.$t("backgroundRepeatRepeat"),
                    "repeat-x": _ctx.$t("backgroundRepeatRepeatX"),
                    "repeat-y": _ctx.$t("backgroundRepeatRepeatY"),
                    "no-repeat": _ctx.$t("backgroundRepeatNoRepeat")
                  },
                  modelValue: __props.background.backgroundRepeat,
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => __props.background.backgroundRepeat = $event)
                }, null, 8, ["label", "options", "modelValue"]),
                createVNode(SwitchItem, {
                  label: _ctx.$t("fixedBackground"),
                  "model-value": __props.background.backgroundAttachment === "fixed",
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = (value) => __props.background.backgroundAttachment = value ? "fixed" : "scroll")
                }, null, 8, ["label", "model-value"])
              ], 64)) : createCommentVNode("", true),
              __props.background.backgroundType === "gradient" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createVNode(SliderItem, {
                  label: _ctx.$t("angle"),
                  type: "angle",
                  modelValue: __props.background.backgroundGradientAngle,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => __props.background.backgroundGradientAngle = $event),
                  min: 0,
                  max: 360,
                  interval: 1
                }, null, 8, ["label", "modelValue"]),
                __props.background.backgroundGradient.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$k, [
                  createVNode(_sfc_main$E, {
                    width: "100%",
                    "model-value": __props.background.backgroundGradient.map((item) => item.percentage),
                    min: 0,
                    max: 100,
                    contained: true,
                    "dot-options": __props.background.backgroundGradient.map((item) => ({
                      disabled: false,
                      style: { background: unref$1(getColor)(item.color) }
                    })),
                    process: (dotsPos) => dotsPos.slice(0, -1).map((_, i2) => [
                      dotsPos[i2],
                      dotsPos[i2 + 1],
                      {
                        background: `linear-gradient(90deg, ${unref$1(getColor)(__props.background.backgroundGradient[i2].color)}, ${unref$1(getColor)(__props.background.backgroundGradient[i2 + 1].color)})`
                      }
                    ]),
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = (values) => {
                      __props.background.backgroundGradient.forEach((item, index2) => {
                        item.percentage = values[index2];
                      });
                    })
                  }, null, 8, ["model-value", "dot-options", "process"])
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.background.backgroundGradient, (color, index2) => {
                  return openBlock(), createBlock(ColorItem, {
                    "model-value": color.color,
                    label: _ctx.$t("colorIndex", index2 + 1),
                    "onUpdate:modelValue": (color2) => __props.background.backgroundGradient[index2].color = color2
                  }, {
                    default: withCtx(() => [
                      createVNode(Icon$1, {
                        class: normalizeClass(["delete-btn", { disabled: __props.background.backgroundGradient.length <= 2 }]),
                        type: "circle",
                        name: "line",
                        size: 8,
                        onClick: ($event) => deleteColor(index2)
                      }, null, 8, ["class", "onClick"])
                    ]),
                    _: 2
                  }, 1032, ["model-value", "label", "onUpdate:modelValue"]);
                }), 256)),
                createBaseVNode("div", _hoisted_4$a, [
                  createBaseVNode("div", {
                    class: "full-btn add-color-btn",
                    onClick: handleAddColor
                  }, toDisplayString(_ctx.$t("addColor")), 1)
                ])
              ], 64)) : createCommentVNode("", true)
            ]),
            _: 1
          });
        };
      }
    });
    const BackgroundGroup_vue_vue_type_style_index_0_scoped_1f94ddfa_lang = "";
    const BackgroundGroup = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__scopeId", "data-v-1f94ddfa"]]);
    const _hoisted_1$v = {
      key: 1,
      class: "item position-item"
    };
    const _hoisted_2$l = { class: "input-wrap" };
    const _hoisted_3$j = {
      key: 0,
      class: "position-center"
    };
    const _hoisted_4$9 = {
      key: 1,
      class: "position-input"
    };
    const _hoisted_5$9 = { class: "position-input-label" };
    const _hoisted_6$8 = {
      key: 2,
      class: "position-input"
    };
    const _hoisted_7$6 = { class: "position-input-label" };
    const _hoisted_8$5 = {
      key: 3,
      class: "position-input"
    };
    const _hoisted_9$5 = { class: "position-input-label" };
    const _hoisted_10$4 = {
      key: 4,
      class: "position-input"
    };
    const _hoisted_11$3 = { class: "position-input-label" };
    const _sfc_main$z = /* @__PURE__ */ defineComponent({
      __name: "PositionGroup",
      props: {
        node: null,
        position: null
      },
      setup(__props) {
        const pageStore = usePageStore();
        storeToRefs(pageStore);
        const displayStore = useDisplayStore();
        const { setLockDragSetPosition } = displayStore;
        const { lockDragSetPosition } = storeToRefs(displayStore);
        const positionMap2 = {
          static: $t("static"),
          absolute: $t("absolute"),
          fixed: $t("fixed")
        };
        const positionValue = computed(() => {
          let values2 = [];
          if (__props.position.left !== "auto")
            values2.push("left");
          if (__props.position.right !== "auto")
            values2.push("right");
          if (__props.position.top !== "auto")
            values2.push("top");
          if (__props.position.bottom !== "auto")
            values2.push("bottom");
          return values2.length === 0 ? "center" : values2.join(" ");
        });
        const values = computed(() => {
          return {
            left: __props.position.left === "auto" ? "" : __props.position.left,
            right: __props.position.right === "auto" ? "" : __props.position.right,
            top: __props.position.top === "auto" ? "" : __props.position.top,
            bottom: __props.position.bottom === "auto" ? "" : __props.position.bottom,
            center: __props.position.left === "auto" && __props.position.right === "auto" && __props.position.top === "auto" && __props.position.bottom === "auto"
          };
        });
        const handlePositionChange = (value) => {
          var _a;
          __props.position.position = value;
          if (value !== "static") {
            const props = useConfigProps(__props.node);
            if ((_a = props.spacing) == null ? void 0 : _a.margin) {
              props.spacing.margin = [0, 0, 0, 0];
            }
            openDragMode();
          } else {
            closeDragMode();
          }
        };
        const handleLockChange = () => {
          const isLock = !lockDragSetPosition.value;
          setLockDragSetPosition(isLock);
          if (!isLock) {
            openDragMode();
          } else {
            closeDragMode();
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "position",
            class: "position-group",
            "default-collapsed": false
          }, {
            default: withCtx(() => [
              createVNode(TabsItemVue, {
                label: unref$1($t)("direction"),
                data: positionMap2,
                "model-value": __props.position.position,
                "onUpdate:modelValue": handlePositionChange
              }, null, 8, ["label", "model-value"]),
              __props.position.position === "fixed" ? (openBlock(), createBlock(Tip, {
                key: 0,
                type: "warning",
                message: unref$1($t)("fixedTip")
              }, null, 8, ["message"])) : createCommentVNode("", true),
              __props.position.position !== "static" ? (openBlock(), createElementBlock("div", _hoisted_1$v, [
                createVNode(PositionTable, {
                  size: 80,
                  "model-value": positionValue.value,
                  options: [
                    "left top",
                    "top",
                    "right top",
                    "left",
                    "center",
                    "right",
                    "left bottom",
                    "bottom",
                    "right bottom"
                  ],
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = (key) => {
                    __props.position.left = key.includes("left") ? "0px" : "auto";
                    __props.position.right = key.includes("right") ? "0px" : "auto";
                    __props.position.top = key.includes("top") ? "0px" : "auto";
                    __props.position.bottom = key.includes("bottom") ? "0px" : "auto";
                  })
                }, null, 8, ["model-value"]),
                createBaseVNode("div", _hoisted_2$l, [
                  values.value.center ? (openBlock(), createElementBlock("div", _hoisted_3$j, toDisplayString(unref$1($t)("alwaysCenter")), 1)) : createCommentVNode("", true),
                  values.value.left ? (openBlock(), createElementBlock("div", _hoisted_4$9, [
                    createBaseVNode("span", _hoisted_5$9, toDisplayString(unref$1($t)("left")), 1),
                    createVNode(Input, {
                      type: "number",
                      suffix: ["px", "%"],
                      "model-value": values.value.left,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = (val) => __props.position.left = val)
                    }, null, 8, ["model-value"])
                  ])) : createCommentVNode("", true),
                  values.value.right ? (openBlock(), createElementBlock("div", _hoisted_6$8, [
                    createBaseVNode("span", _hoisted_7$6, toDisplayString(unref$1($t)("right")), 1),
                    createVNode(Input, {
                      type: "number",
                      suffix: ["px", "%"],
                      "model-value": values.value.right,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = (val) => __props.position.right = val)
                    }, null, 8, ["model-value"])
                  ])) : createCommentVNode("", true),
                  values.value.top ? (openBlock(), createElementBlock("div", _hoisted_8$5, [
                    createBaseVNode("span", _hoisted_9$5, toDisplayString(unref$1($t)("top")), 1),
                    createVNode(Input, {
                      type: "number",
                      suffix: ["px", "%"],
                      "model-value": values.value.top,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = (val) => __props.position.top = val)
                    }, null, 8, ["model-value"])
                  ])) : createCommentVNode("", true),
                  values.value.bottom ? (openBlock(), createElementBlock("div", _hoisted_10$4, [
                    createBaseVNode("span", _hoisted_11$3, toDisplayString(unref$1($t)("bottom")), 1),
                    createVNode(Input, {
                      type: "number",
                      suffix: ["px", "%"],
                      "model-value": values.value.bottom,
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = (val) => __props.position.bottom = val)
                    }, null, 8, ["model-value"])
                  ])) : createCommentVNode("", true)
                ]),
                createVNode(Icon$1, {
                  class: normalizeClass(["lock-icon", { active: unref$1(lockDragSetPosition) }]),
                  name: unref$1(lockDragSetPosition) ? "lock" : "unlock",
                  size: 14,
                  onClick: handleLockChange
                }, null, 8, ["class", "name"])
              ])) : createCommentVNode("", true),
              createVNode(SliderItem, {
                label: unref$1($t)("zIndex"),
                modelValue: __props.position.zIndex,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => __props.position.zIndex = $event),
                min: 0,
                max: 999
              }, null, 8, ["label", "modelValue"])
            ]),
            _: 1
          });
        };
      }
    });
    const PositionGroup_vue_vue_type_style_index_0_scoped_efb6de14_lang = "";
    const PositionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-efb6de14"]]);
    const _sfc_main$y = /* @__PURE__ */ defineComponent({
      __name: "EventGroup",
      props: {
        node: null,
        event: null
      },
      setup(__props) {
        const displayStore = useDisplayStore();
        const { lockScriptTrigger } = storeToRefs(displayStore);
        const { setLockScriptTrigger } = displayStore;
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "event",
            class: "event-group",
            "default-collapsed": false,
            "can-advanced": true
          }, {
            default: withCtx(({ showAdvanced }) => [
              createVNode(SelectItem, {
                label: _ctx.$t("eventTriggerType"),
                options: { tap: _ctx.$t("eventTap"), mousedown: _ctx.$t("eventMouseDown"), touchstart: _ctx.$t("eventTouchStart") },
                modelValue: __props.event.type,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => __props.event.type = $event)
              }, null, 8, ["label", "options", "modelValue"]),
              createVNode(TabsItemVue, {
                data: { link: _ctx.$t("link"), scrollTo: _ctx.$t("scrollTo"), func: _ctx.$t("function") },
                modelValue: __props.event.action,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => __props.event.action = $event)
              }, null, 8, ["data", "modelValue"]),
              __props.event.action === "link" ? (openBlock(), createBlock(InputItem, {
                key: 0,
                label: _ctx.$t("link"),
                type: "textarea",
                rows: 2,
                placeholder: _ctx.$t("linkPlaceholder"),
                "model-value": __props.event.link || "",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = (value) => __props.event.link = value)
              }, null, 8, ["label", "placeholder", "model-value"])) : createCommentVNode("", true),
              __props.event.action === "scrollTo" ? (openBlock(), createBlock(InputItem, {
                key: 1,
                label: _ctx.$t("scrollTo"),
                placeholder: _ctx.$t("scrollToPlaceholder"),
                type: "textarea",
                rows: 2,
                "model-value": __props.event.scrollTarget,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = (value) => __props.event.scrollTarget = value)
              }, null, 8, ["label", "placeholder", "model-value"])) : createCommentVNode("", true),
              __props.event.action === "func" ? (openBlock(), createBlock(InputItem, {
                key: 2,
                label: _ctx.$t("function"),
                type: "textarea",
                tip: _ctx.$t("functionTip"),
                placeholder: _ctx.$t("functionPlaceholder"),
                "model-value": __props.event.execFunction || "",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = (value) => __props.event.execFunction = value)
              }, {
                "label-suffix": withCtx(() => [
                  createVNode(Icon$1, {
                    class: normalizeClass(["lock-icon", { active: unref$1(lockScriptTrigger) }]),
                    name: unref$1(lockScriptTrigger) ? "lock" : "unlock",
                    size: 14,
                    type: "btn",
                    active: unref$1(lockScriptTrigger),
                    onClick: _cache[4] || (_cache[4] = ($event) => unref$1(setLockScriptTrigger)(!unref$1(lockScriptTrigger)))
                  }, null, 8, ["class", "name", "active"])
                ]),
                _: 1
              }, 8, ["label", "tip", "placeholder", "model-value"])) : createCommentVNode("", true),
              showAdvanced ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                createVNode(SwitchItem, {
                  label: _ctx.$t("stopPropagation"),
                  modelValue: __props.event.stopPropagation,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => __props.event.stopPropagation = $event)
                }, null, 8, ["label", "modelValue"]),
                __props.event.action === "link" ? (openBlock(), createBlock(SwitchItem, {
                  key: 0,
                  label: _ctx.$t("openNewTab"),
                  modelValue: __props.event.openNewTab,
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => __props.event.openNewTab = $event)
                }, null, 8, ["label", "modelValue"])) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true)
            ]),
            _: 1
          });
        };
      }
    });
    const EventGroup_vue_vue_type_style_index_0_scoped_7ee55010_lang = "";
    const EventGroup = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-7ee55010"]]);
    const getDefaultCommon = (initConfig) => Object.assign({
      hide: false
    }, initConfig);
    const getDefaultBasic = (component, initConfig) => {
      let obj = {};
      if (isSomeBasicType(component, "Text", obj)) {
        obj = {
          text: "Sample Text",
          whiteSpace: "pre-line"
        };
      }
      if (isSomeBasicType(component, "Image", obj)) {
        obj = {
          src: "",
          objectFit: "fill"
        };
      }
      if (isSomeBasicType(component, "Icon", obj)) {
        obj = {
          name: "home",
          size: "1rem",
          color: "$primary",
          prefixClass: "fa-",
          extraClass: "",
          styleLink: DefaultIconStyleLink
        };
      }
      return Object.assign(obj, initConfig);
    };
    const getDefaultSize = (type2 = "component", initConfig) => Object.assign(type2 === "component" ? {
      width: "10vw",
      height: "10vw",
      minWidth: "auto",
      minHeight: "auto",
      maxHeight: "none",
      maxWidth: "none"
    } : {
      width: "",
      height: "100%",
      minWidth: "",
      minHeight: "50px",
      maxHeight: "none",
      maxWidth: ""
    }, initConfig || null);
    const getDefaultLayout = (initConfig) => Object.assign({
      direction: "row",
      justify: "center",
      align: "center",
      wrap: "nowrap",
      reverse: false
    }, initConfig);
    const getDefaultFont = (initConfig) => Object.assign({
      fontSize: "1rem",
      lineHeight: "126%",
      color: "$primary",
      fontWeight: "normal",
      fontStyle: "normal",
      textDecoration: "none",
      textAlign: "left",
      textShadow: "",
      fontFamily: ""
    }, initConfig);
    const getDefaultSpacing = (initConfig) => Object.assign({
      margin: [0, 0, 0, 0],
      padding: [0, 0, 0, 0]
    }, initConfig);
    const getDefaultBorder = (initConfig) => Object.assign({
      borderWidth: new Array(4).fill("0px"),
      borderStyle: new Array(4).fill("solid"),
      borderColor: new Array(4).fill("$primary"),
      borderRadius: "0px"
    }, initConfig);
    const getDefaultBackground = (initConfig) => Object.assign({
      backgroundType: "none",
      backgroundColor: "#FFFFFF",
      backgroundImage: "",
      backgroundSize: "auto",
      backgroundPosition: "center",
      backgroundRepeat: "no-repeat",
      backgroundGradientAngle: 180,
      backgroundGradient: [],
      backgroundAttachment: "scroll"
    }, initConfig);
    const getDefaultContainer = (initConfig) => Object.assign({
      overflow: "visible",
      boxShadow: "",
      opacity: 1,
      cursor: "inherit",
      filter: ""
    }, initConfig);
    const getDefaultPosition = (initConfig) => Object.assign({
      position: "static",
      left: "0px",
      right: "auto",
      top: "0px",
      bottom: "auto",
      zIndex: 0
    }, initConfig);
    const getDefaultEvent = (initConfig) => Object.assign({
      type: "tap",
      action: "link",
      stopPropagation: true,
      link: "",
      openNewTab: true,
      execFunction: "",
      scrollTarget: ""
    }, initConfig);
    const getDefaultAnimation = (initConfig) => Object.assign({
      animationList: []
    }, initConfig);
    const getDefaultAnimationItem = (name, initConfig) => {
      return {
        name,
        trigger: "scrollIntoView",
        duration: 1,
        delay: 0,
        timingFunction: "ease",
        fillMode: "both",
        direction: "alternate",
        settings: getDefaultAnimationSettings(name),
        ...initConfig
      };
    };
    const getDefaultAnimationSettings = (name) => {
      if (name === "fade") {
        return {
          fade: {
            opacity: 0.5
          }
        };
      }
      if (name.startsWith("slide")) {
        return {
          slide: {
            offset: 20,
            opacity: 1
          }
        };
      }
      if (name.startsWith("zoom")) {
        return {
          zoom: {
            zoom: 0.5,
            opacity: 1
          }
        };
      }
      if (name.startsWith("rotate")) {
        return {
          rotate: {
            angle: 180,
            opacity: 1
          }
        };
      }
      return {};
    };
    const getDefaultEffect = (initConfig) => Object.assign({
      effectList: []
    }, initConfig);
    const getDefaultEffectItem = (target) => {
      return {
        target,
        targetType: "self",
        name: "",
        duration: 0.5,
        timingFunction: "ease",
        styles: {}
      };
    };
    const _hoisted_1$u = { class: "text" };
    const _sfc_main$x = /* @__PURE__ */ defineComponent({
      __name: "Btn",
      props: {
        text: null,
        size: { default: "md" },
        type: { default: "btn" },
        color: { default: "primary" },
        icon: null,
        disabled: { type: Boolean },
        isBlock: { type: Boolean }
      },
      setup(__props) {
        const handleClick = (e) => {
          if (__props.disabled) {
            e.stopImmediatePropagation();
            return;
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              "btn",
              `size-${__props.size}`,
              `${__props.color}`,
              `btn-type-${__props.type}`,
              { disabled: __props.disabled, "btn-block": __props.isBlock }
            ]),
            role: "button",
            onClick: handleClick
          }, [
            __props.icon ? (openBlock(), createBlock(Icon$1, {
              key: 0,
              class: "btn-icon",
              name: __props.icon,
              size: 14
            }, null, 8, ["name"])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_1$u, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(__props.text), 1)
              ], true)
            ])
          ], 2);
        };
      }
    });
    const Btn_vue_vue_type_style_index_0_scoped_3c988efa_lang = "";
    const Btn = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__scopeId", "data-v-3c988efa"]]);
    const _hoisted_1$t = { class: "collapse-content" };
    const _hoisted_2$k = { class: "collapse-name" };
    const _hoisted_3$i = { class: "collapse-main" };
    const _sfc_main$w = /* @__PURE__ */ defineComponent({
      __name: "CollapseItem",
      props: {
        name: null,
        collapsed: { type: Boolean },
        tag: null,
        tagType: { default: "default" }
      },
      setup(__props) {
        const tags = computed(() => !__props.tag ? [] : Array.isArray(__props.tag) ? __props.tag : [__props.tag]);
        return (_ctx, _cache) => {
          const _directive_collapse = resolveDirective("collapse");
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["item column collapse-item", { active: __props.collapsed }])
          }, [
            createBaseVNode("div", _hoisted_1$t, [
              createBaseVNode("div", {
                class: "collapse-header",
                onClick: _cache[1] || (_cache[1] = () => _ctx.$emit("collapse", !__props.collapsed))
              }, [
                createBaseVNode("div", _hoisted_2$k, [
                  renderSlot(_ctx.$slots, "name", {}, () => [
                    createTextVNode(toDisplayString(__props.name), 1)
                  ], true)
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList(tags.value, (item) => {
                  return withDirectives((openBlock(), createElementBlock("div", {
                    class: normalizeClass(["collapse-tag", `collapse-tag-${__props.tagType}`])
                  }, toDisplayString(item), 3)), [
                    [vShow, item]
                  ]);
                }), 256)),
                createVNode(Icon$1, {
                  class: "close-btn",
                  name: "close",
                  size: 18,
                  onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("delete"), ["stop"]))
                })
              ]),
              withDirectives((openBlock(), createElementBlock("div", _hoisted_3$i, [
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ])), [
                [_directive_collapse, __props.collapsed]
              ])
            ])
          ], 2);
        };
      }
    });
    const CollapseItem_vue_vue_type_style_index_0_scoped_4a036dbe_lang = "";
    const CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-4a036dbe"]]);
    const _hoisted_1$s = { class: "item" };
    const _hoisted_2$j = { class: "inner-text" };
    const _hoisted_3$h = { class: "item" };
    const _sfc_main$v = /* @__PURE__ */ defineComponent({
      __name: "AnimationGroup",
      props: {
        node: null,
        animation: null
      },
      setup(__props) {
        let collapsedIndex = ref(0);
        const handleAddAnimation = () => {
          __props.animation.animationList.push(getDefaultAnimationItem("fade"));
          collapsedIndex.value = __props.animation.animationList.length - 1;
        };
        const animationNameList = [
          "fade",
          "slide-up",
          "slide-down",
          "slide-left",
          "slide-right",
          "zoom-in",
          "zoom-out",
          "rotate-x",
          "rotate-y"
        ];
        const animationNameMap = {
          fade: $t("fade"),
          "slide-up": $t("slideUp"),
          "slide-down": $t("slideDown"),
          "slide-left": $t("slideLeft"),
          "slide-right": $t("slideRight"),
          "zoom-in": $t("zoomIn"),
          "zoom-out": $t("zoomOut"),
          "rotate-x": $t("rotateX"),
          "rotate-y": $t("rotateY")
        };
        const animationTriggerMap = {
          hover: $t("animationTriggerHover"),
          click: $t("animationTriggerClick"),
          scrollIntoView: $t("animationTriggerScrollIntoView"),
          always: $t("animationTriggerAlways")
        };
        const timingFunction = {
          ease: $t("ease"),
          "ease-in": $t("easeIn"),
          "ease-out": $t("easeOut"),
          "ease-in-out": $t("easeInOut"),
          linear: $t("linear")
        };
        const fillModeMap = {
          forwards: $t("animationFillModeForwards"),
          backwards: $t("animationFillModeBackwards"),
          both: $t("animationFillModeBoth"),
          none: $t("animationFillModeNone")
        };
        const directionMap = {
          normal: $t("animationDirectionNormal"),
          reverse: $t("animationDirectionReverse"),
          alternate: $t("animationDirectionAlternate"),
          "alternate-reverse": $t("animationDirectionAlternateReverse")
        };
        const handleChangeAnimationName = (name, index2) => {
          __props.animation.animationList[index2].settings = getDefaultAnimationSettings(name);
          __props.animation.animationList[index2].name = name;
        };
        const handleChangeAnimationTrigger = (trigger2, index2) => {
          __props.animation.animationList[index2].trigger = trigger2;
          __props.animation.animationList[index2].direction = isOneCount(trigger2) ? "normal" : "alternate-reverse";
        };
        const isOneCount = (trigger2) => ["scrollIntoView", "click"].includes(trigger2);
        let showAdvancedSettings = ref(false);
        let showCodeInput = ref(false);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            "group-name": "animation",
            class: "animation-group",
            "can-advanced": false,
            "default-collapsed": false
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$s, [
                createVNode(Tip, {
                  type: "warning",
                  message: unref$1($t)("animationTip"),
                  block: ""
                }, null, 8, ["message"])
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.animation.animationList, (item, index2) => {
                return openBlock(), createBlock(CollapseItem, {
                  class: "animation-item",
                  key: index2,
                  collapsed: index2 === collapsedIndex.value,
                  name: animationTriggerMap[item.trigger],
                  tag: index2 !== collapsedIndex.value ? animationNameMap[item.name] : "",
                  onDelete: () => __props.animation.animationList.splice(index2, 1),
                  onCollapse: () => collapsedIndex.value = collapsedIndex.value === index2 ? -1 : index2
                }, {
                  default: withCtx(() => [
                    createVNode(SelectItem, {
                      label: unref$1($t)("eventTriggerType"),
                      options: animationTriggerMap,
                      "model-value": item.trigger,
                      "onUpdate:modelValue": (val) => handleChangeAnimationTrigger(val, index2),
                      onDblclick: _cache[0] || (_cache[0] = ($event) => showAdvancedSettings.value = !showAdvancedSettings.value)
                    }, null, 8, ["label", "model-value", "onUpdate:modelValue"]),
                    createVNode(PreviewItem, {
                      label: unref$1($t)("animation"),
                      options: animationNameList,
                      "model-value": item.name,
                      "hide-advanced": true,
                      "onUpdate:modelValue": (val) => val && handleChangeAnimationName(val, index2)
                    }, {
                      default: withCtx(({ item: name, active }) => [
                        createBaseVNode("div", {
                          class: normalizeClass(["inner-box", { active }]),
                          style: normalizeStyle({
                            animation: `${name} 1s infinite ${isOneCount(item.trigger) ? "normal" : "alternate-reverse"}`
                          })
                        }, null, 6),
                        createBaseVNode("div", _hoisted_2$j, toDisplayString(animationNameMap[name]), 1)
                      ]),
                      _: 2
                    }, 1032, ["label", "model-value", "onUpdate:modelValue"]),
                    item.settings ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      item.settings.fade ? (openBlock(), createBlock(SliderItem, {
                        key: 0,
                        label: unref$1($t)("opacity"),
                        min: 0,
                        max: 1,
                        interval: 0.01,
                        modelValue: item.settings.fade.opacity,
                        "onUpdate:modelValue": ($event) => item.settings.fade.opacity = $event
                      }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true),
                      item.settings.slide ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createVNode(SliderItem, {
                          label: unref$1($t)("animationOffset"),
                          min: 0,
                          max: 100,
                          interval: 1,
                          modelValue: item.settings.slide.offset,
                          "onUpdate:modelValue": ($event) => item.settings.slide.offset = $event
                        }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                        createVNode(SliderItem, {
                          label: unref$1($t)("opacity"),
                          min: 0,
                          max: 1,
                          interval: 0.01,
                          modelValue: item.settings.slide.opacity,
                          "onUpdate:modelValue": ($event) => item.settings.slide.opacity = $event
                        }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"])
                      ], 64)) : createCommentVNode("", true),
                      item.settings.zoom ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                        createVNode(SliderItem, {
                          label: unref$1($t)("zoom"),
                          min: 0,
                          max: 1,
                          interval: 0.01,
                          modelValue: item.settings.zoom.zoom,
                          "onUpdate:modelValue": ($event) => item.settings.zoom.zoom = $event
                        }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"]),
                        createVNode(SliderItem, {
                          label: unref$1($t)("opacity"),
                          min: 0,
                          max: 1,
                          interval: 0.01,
                          modelValue: item.settings.zoom.opacity,
                          "onUpdate:modelValue": ($event) => item.settings.zoom.opacity = $event
                        }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"])
                      ], 64)) : createCommentVNode("", true),
                      item.settings.rotate ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                        createVNode(SliderItem, {
                          label: unref$1($t)("zoom"),
                          min: 0,
                          max: 360,
                          interval: 10,
                          modelValue: item.settings.rotate.angle,
                          "onUpdate:modelValue": ($event) => item.settings.rotate.angle = $event
                        }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                        createVNode(SliderItem, {
                          label: unref$1($t)("opacity"),
                          min: 0,
                          max: 1,
                          interval: 0.01,
                          modelValue: item.settings.rotate.opacity,
                          "onUpdate:modelValue": ($event) => item.settings.rotate.opacity = $event
                        }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"])
                      ], 64)) : createCommentVNode("", true)
                    ], 64)) : createCommentVNode("", true),
                    createVNode(SliderItem, {
                      label: unref$1($t)("duration"),
                      min: 0,
                      max: 5,
                      interval: 0.05,
                      modelValue: item.duration,
                      "onUpdate:modelValue": ($event) => item.duration = $event
                    }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"]),
                    createVNode(SliderItem, {
                      label: unref$1($t)("delay"),
                      min: 0,
                      max: 5,
                      interval: 0.05,
                      modelValue: item.delay,
                      "onUpdate:modelValue": ($event) => item.delay = $event
                    }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"]),
                    showAdvancedSettings.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createVNode(SelectItem, {
                        label: unref$1($t)("timing"),
                        options: timingFunction,
                        modelValue: item.timingFunction,
                        "onUpdate:modelValue": ($event) => item.timingFunction = $event,
                        onDblclick: _cache[1] || (_cache[1] = ($event) => showCodeInput.value = !showCodeInput.value)
                      }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                      showCodeInput.value ? (openBlock(), createBlock(InputItem, {
                        key: 0,
                        label: unref$1($t)("timingCode"),
                        modelValue: item.timingFunction,
                        "onUpdate:modelValue": ($event) => item.timingFunction = $event
                      }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true),
                      createVNode(SelectItem, {
                        label: unref$1($t)("fillMode"),
                        options: fillModeMap,
                        modelValue: item.fillMode,
                        "onUpdate:modelValue": ($event) => item.fillMode = $event
                      }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                      createVNode(SelectItem, {
                        label: unref$1($t)("direction"),
                        options: directionMap,
                        modelValue: item.direction,
                        "onUpdate:modelValue": ($event) => item.direction = $event
                      }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])
                    ], 64)) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["collapsed", "name", "tag", "onDelete", "onCollapse"]);
              }), 128)),
              createBaseVNode("div", _hoisted_3$h, [
                createVNode(Btn, {
                  type: "text",
                  "is-block": true,
                  icon: "plus",
                  onClick: handleAddAnimation
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref$1($t)("addAnimation")), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          });
        };
      }
    });
    const AnimationGroup_vue_vue_type_style_index_0_scoped_2303e230_lang = "";
    const AnimationGroup = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-2303e230"]]);
    const getFormPropsByType = (type2) => {
      switch (type2) {
        case "text":
          return {
            component: InputItem,
            props: {
              type: "textarea",
              realTime: true
            }
          };
        case "color":
        case "borderColor":
        case "backgroundColor":
          return {
            component: ColorItem,
            props: {
              type: "color"
            }
          };
        case "fontSize":
          return {
            component: InputItem,
            props: {
              type: "number",
              suffix: ["px", "rem", "vw"]
            }
          };
        case "opacity":
          return {
            component: SliderItem,
            props: {
              min: 0,
              max: 1,
              interval: 0.01
            }
          };
        case "image":
          return {
            component: ImageItem,
            props: {}
          };
        case "hide":
          return {
            component: SwitchItem,
            props: {}
          };
        case "tip":
          return {
            component: Tip,
            props: {}
          };
        case "backgroundSize":
          return {
            component: TabsItemVue,
            props: {
              data: { cover: "Cover", contain: "Contain", auto: "Auto" }
            }
          };
        case "size":
          return {
            component: InputItem,
            props: {
              type: "number",
              suffix: ["px", "%", "rem", "vw", "auto", "stretch"]
            }
          };
        case "duration":
        case "delay":
          return {
            component: SliderItem,
            props: {
              min: 0,
              max: 5,
              interval: 0.05
            }
          };
        case "blur":
          return {
            component: SliderItem,
            props: {
              min: 0,
              max: 20,
              interval: 1
            }
          };
        default:
          return {
            component: null,
            props: {}
          };
      }
    };
    const getEffectMapByNode = (node, isSelf) => {
      if (!node)
        return {};
      const nodeGroups = ComponentPropsGroup[node.component];
      let map = {};
      (nodeGroups || []).map((group) => getEffectShowItemByGroup(group, node)).filter(Boolean).forEach((obj) => {
        map = { ...map, ...obj };
      });
      map = !isSelf ? {
        ...map,
        hide: allEffectMap["hide"]
      } : map;
      return map;
    };
    const allEffectMap = {
      color: {
        label: $t("fontColor"),
        ...getFormPropsByType("color"),
        defaultValue: DefaultColor
      },
      fontSize: {
        label: $t("fontSize"),
        ...getFormPropsByType("fontSize"),
        defaultValue: "16px"
      },
      borderColor: {
        label: $t("borderColor"),
        ...getFormPropsByType("borderColor"),
        defaultValue: DefaultColor
      },
      backgroundColor: {
        label: $t("backgroundColor"),
        ...getFormPropsByType("backgroundColor"),
        defaultValue: DefaultColor
      },
      opacity: {
        label: $t("opacity"),
        ...getFormPropsByType("opacity"),
        defaultValue: 1
      },
      hide: {
        label: $t("hidden"),
        ...getFormPropsByType("hide"),
        defaultValue: true
      },
      blur: {
        label: $t("filterBlur"),
        ...getFormPropsByType("blur"),
        defaultValue: 0
      }
    };
    const getEffectShowItemByGroup = (groupType, node) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const props = useConfigProps(node);
      switch (groupType) {
        case "font":
          return {
            color: Object.assign({}, allEffectMap["color"], {
              label: $t("fontColor"),
              defaultValue: (_b = (_a = props.font) == null ? void 0 : _a.color) != null ? _b : DefaultColor
            }),
            fontSize: Object.assign({}, allEffectMap["fontSize"], {
              label: $t("fontSize"),
              defaultValue: (_d = (_c = props.font) == null ? void 0 : _c.fontSize) != null ? _d : "18px"
            })
          };
        case "border": {
          const border = props.border;
          return {
            borderColor: Object.assign({}, allEffectMap["borderColor"], {
              defaultValue: Array.isArray(border == null ? void 0 : border.borderColor) ? border == null ? void 0 : border.borderColor[0] : (border == null ? void 0 : border.borderColor) || DefaultColor
            })
          };
        }
        case "background": {
          const background = props.background;
          return (background == null ? void 0 : background.backgroundType) === "color" || (background == null ? void 0 : background.backgroundType) === "none" ? {
            backgroundColor: Object.assign({}, allEffectMap["backgroundColor"], {
              defaultValue: (_e = background == null ? void 0 : background.backgroundColor) != null ? _e : DefaultColor
            })
          } : null;
        }
        case "container": {
          return {
            opacity: Object.assign({}, allEffectMap["opacity"], {
              defaultValue: (_g = (_f = props.container) == null ? void 0 : _f.opacity) != null ? _g : 1
            }),
            blur: Object.assign({}, allEffectMap["blur"], {
              defaultValue: 0
            })
          };
        }
        case "basic": {
          if (isSomeBasicType("Icon", node.component, props.basic)) {
            const basic = props.basic;
            return {
              fontSize: Object.assign({}, allEffectMap["fontSize"], {
                label: $t("iconSize"),
                defaultValue: (_h = basic == null ? void 0 : basic.size) != null ? _h : "18px"
              }),
              color: Object.assign({}, allEffectMap["color"], {
                label: $t("iconColor"),
                defaultValue: (_i = basic == null ? void 0 : basic.color) != null ? _i : DefaultColor
              })
            };
          }
          return null;
        }
        default:
          return null;
      }
    };
    const _withScopeId$3 = (n) => (pushScopeId("data-v-548c6003"), n = n(), popScopeId(), n);
    const _hoisted_1$r = { key: 0 };
    const _hoisted_2$i = { key: 1 };
    const _hoisted_3$g = { class: "highlight" };
    const _hoisted_4$8 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
    const _hoisted_5$8 = { key: 2 };
    const _hoisted_6$7 = {
      class: /* @__PURE__ */ normalizeClass(["select-target-item"])
    };
    const _hoisted_7$5 = ["data-text"];
    const _hoisted_8$4 = ["onClick"];
    const _hoisted_9$4 = { class: "label" };
    const _hoisted_10$3 = { class: "item" };
    const _sfc_main$u = /* @__PURE__ */ defineComponent({
      __name: "EffectGroup",
      props: {
        node: null,
        effect: null
      },
      setup(__props) {
        const pageStore = usePageStore();
        const { getAllChildNode, getTagsByNode, nameMap } = pageStore;
        storeToRefs(pageStore);
        let collapsedIndex = ref(0);
        const handleAddEffect = () => {
          __props.effect.effectList.push(getDefaultEffectItem(__props.node.name));
          collapsedIndex.value = __props.effect.effectList.length - 1;
        };
        const getEffectMap = computed(() => (target, targetType) => {
          return targetType === "tag" ? allEffectMap : getEffectMapByNode(nameMap[target], targetType === "self") || {};
        });
        const getEffectLabel = (target, targetType) => Object.fromEntries(Object.entries(getEffectMap.value(target, targetType)).map(([key, item]) => [key, item.label]));
        const handleNameChange = (val, item) => {
          item.name = val;
          handleSetStyle("hover", "delete", item);
          handleSetStyle("active", "delete", item);
        };
        const handleTargetChange = (key, item) => {
          const obj = effectTargetMap.value[key];
          item.target = obj.target;
          item.targetType = obj.type;
          item.name = "";
          handleSetStyle("hover", "delete", item);
          handleSetStyle("active", "delete", item);
        };
        const handleSetStyle = (styleType, operation, item) => {
          if (operation === "add") {
            item.styles[styleType] = getEffectMap.value(item.target, item.targetType)[item.name].defaultValue;
          } else {
            delete item.styles[styleType];
          }
        };
        const effectTargetMap = computed(() => {
          let obj = {
            ["%" + __props.node.name]: {
              target: __props.node.name,
              title: __props.node.name,
              type: "self"
            }
          };
          getTagsByNode(__props.node.children || []).forEach((tag) => {
            obj[tag] = {
              target: tag,
              title: tag,
              type: "tag"
            };
          });
          return obj;
        });
        const actionMap = computed(() => [
          {
            name: "hover",
            label: $t("hover")
          },
          {
            name: "active",
            label: $t("active")
          }
        ]);
        const timingFunction = {
          ease: $t("ease"),
          "ease-in": $t("easeIn"),
          "ease-out": $t("easeOut"),
          "ease-in-out": $t("easeInOut"),
          linear: $t("linear")
        };
        let showTimingCode = ref(false);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            title: unref$1($t)("effect"),
            "group-name": "effect",
            class: "effect-group",
            "can-advanced": false,
            "default-collapsed": false
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.effect.effectList, (item, index2) => {
                return openBlock(), createBlock(CollapseItem, {
                  class: "animation-item",
                  key: index2,
                  collapsed: index2 === collapsedIndex.value || !item.name,
                  tag: index2 === collapsedIndex.value ? "" : Object.keys(item.styles).length ? Object.keys(item.styles) : "",
                  "tag-type": Object.keys(item.styles).length ? "theme" : "red",
                  onDelete: () => __props.effect.effectList.splice(index2, 1),
                  onCollapse: () => collapsedIndex.value = collapsedIndex.value === index2 ? -1 : index2
                }, {
                  name: withCtx(() => [
                    !item.name ? (openBlock(), createElementBlock("span", _hoisted_1$r, toDisplayString(unref$1($t)("chooseAStyle")), 1)) : item.target && item.target !== __props.node.name ? (openBlock(), createElementBlock("span", _hoisted_2$i, [
                      createBaseVNode("span", _hoisted_3$g, [
                        createTextVNode(toDisplayString(item.target), 1),
                        _hoisted_4$8
                      ]),
                      createBaseVNode("span", null, toDisplayString(item.name), 1)
                    ])) : (openBlock(), createElementBlock("span", _hoisted_5$8, toDisplayString(item.name), 1))
                  ]),
                  default: withCtx(() => [
                    Object.keys(effectTargetMap.value).length > 1 ? (openBlock(), createBlock(SelectItem, {
                      key: 0,
                      label: unref$1($t)("target"),
                      options: effectTargetMap.value,
                      "model-value": item.target,
                      "onUpdate:modelValue": ($event) => handleTargetChange($event, item)
                    }, {
                      item: withCtx((data2) => {
                        var _a, _b;
                        return [
                          createBaseVNode("div", _hoisted_6$7, [
                            createBaseVNode("div", {
                              class: normalizeClass(["type-tag", (_a = data2.item) == null ? void 0 : _a.type])
                            }, toDisplayString((_b = data2.item) == null ? void 0 : _b.type), 3),
                            createTextVNode(" " + toDisplayString(data2.item.title), 1)
                          ])
                        ];
                      }),
                      _: 2
                    }, 1032, ["label", "options", "model-value", "onUpdate:modelValue"])) : createCommentVNode("", true),
                    createVNode(SelectItem, {
                      label: unref$1($t)("style"),
                      options: getEffectLabel(item.target, item.targetType),
                      "model-value": item.name,
                      "onUpdate:modelValue": ($event) => handleNameChange($event, item)
                    }, null, 8, ["label", "options", "model-value", "onUpdate:modelValue"]),
                    item.name ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      item.target == __props.node.name ? (openBlock(), createBlock(SliderItem, {
                        key: 0,
                        label: unref$1($t)("duration"),
                        min: 0,
                        max: 5,
                        interval: 0.05,
                        modelValue: item.duration,
                        "onUpdate:modelValue": ($event) => item.duration = $event
                      }, null, 8, ["label", "interval", "modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true),
                      item.target == __props.node.name ? (openBlock(), createBlock(SelectItem, {
                        key: 1,
                        label: unref$1($t)("timing"),
                        options: timingFunction,
                        modelValue: item.timingFunction,
                        "onUpdate:modelValue": ($event) => item.timingFunction = $event,
                        onDblclick: _cache[0] || (_cache[0] = ($event) => showTimingCode.value = !showTimingCode.value)
                      }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true),
                      showTimingCode.value ? (openBlock(), createBlock(InputItem, {
                        key: 2,
                        label: unref$1($t)("timingCode"),
                        modelValue: item.timingFunction,
                        "onUpdate:modelValue": ($event) => item.timingFunction = $event
                      }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true),
                      createBaseVNode("hr", {
                        class: "divider",
                        "data-text": unref$1($t)("action")
                      }, null, 8, _hoisted_7$5),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(actionMap.value, (obj) => {
                        var _a;
                        return openBlock(), createElementBlock(Fragment, {
                          key: obj.name
                        }, [
                          item.styles[obj.name] !== void 0 && ((_a = getEffectMap.value(item.target, item.targetType)) == null ? void 0 : _a[item.name]) ? (openBlock(), createBlock(resolveDynamicComponent(getEffectMap.value(item.target, item.targetType)[item.name].component), mergeProps({
                            key: 0,
                            label: obj.label,
                            "model-value": item.styles[obj.name]
                          }, getEffectMap.value(item.target, item.targetType)[item.name].props, {
                            "onUpdate:modelValue": ($event) => item.styles[obj.name] = $event
                          }), {
                            default: withCtx(() => [
                              createVNode(Icon$1, {
                                class: normalizeClass(["delete-btn"]),
                                type: "circle",
                                name: "line",
                                size: 8,
                                onClick: ($event) => handleSetStyle(obj.name, "delete", item)
                              }, null, 8, ["onClick"])
                            ]),
                            _: 2
                          }, 1040, ["label", "model-value", "onUpdate:modelValue"])) : (openBlock(), createElementBlock("div", {
                            key: 1,
                            class: "item",
                            onClick: ($event) => handleSetStyle(obj.name, "add", item)
                          }, [
                            createBaseVNode("div", _hoisted_9$4, toDisplayString(obj.label), 1),
                            createVNode(Icon$1, {
                              class: "add-btn",
                              name: "plus",
                              size: 16,
                              type: "circle"
                            })
                          ], 8, _hoisted_8$4))
                        ], 64);
                      }), 128))
                    ], 64)) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["collapsed", "tag", "tag-type", "onDelete", "onCollapse"]);
              }), 128)),
              createBaseVNode("div", _hoisted_10$3, [
                createVNode(Btn, {
                  type: "text",
                  "is-block": true,
                  icon: "plus",
                  onClick: handleAddEffect
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref$1($t)("addEffect")), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 8, ["title"]);
        };
      }
    });
    const EffectGroup_vue_vue_type_style_index_0_scoped_548c6003_lang = "";
    const EffectGroup = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-548c6003"]]);
    const _sfc_main$t = /* @__PURE__ */ defineComponent({
      __name: "CustomGroup",
      setup(__props) {
        const { node, title, titleEn, icon, data: data2, defaultCollapsed = false } = useAttrs();
        const dataRef = reactive(data2);
        const getComponentData = (type2) => getFormPropsByType(type2);
        const getValue2 = (sourceValue) => get(node, sourceValue);
        const setValue = (sourceValue, value) => {
          const list = Array.isArray(sourceValue) ? sourceValue : [sourceValue];
          while (list.length) {
            const v = list.shift();
            if (v.includes("config.all.")) {
              list.unshift(v.replace("config.all.", "config.props."), v.replace("config.all.", "config.mobile."));
            } else {
              set(node, v, value);
            }
          }
          emitter.emit("saveHistory");
        };
        const showTitle = computed(() => lang === "en" && titleEn || title);
        const getLabel = computed(() => (item) => lang === "en" && item.labelEn || item.label);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Group, {
            title: showTitle.value,
            icon: unref$1(icon),
            class: "basic-group",
            "default-collapsed": unref$1(defaultCollapsed)
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(dataRef, (item) => {
                return openBlock(), createBlock(resolveDynamicComponent(getComponentData(item.type).component), mergeProps({
                  "model-value": item.sourceValue ? getValue2(item.sourceValue) : "",
                  label: getLabel.value(item)
                }, {
                  ...getComponentData(item.type).props,
                  ...item.props
                }, {
                  "onUpdate:modelValue": (val) => item.targetValue ? setValue(item.targetValue, val) : null
                }), null, 16, ["model-value", "label", "onUpdate:modelValue"]);
              }), 256))
            ]),
            _: 1
          }, 8, ["title", "icon", "default-collapsed"]);
        };
      }
    });
    const CustomGroup_vue_vue_type_style_index_0_scoped_35a2e251_lang = "";
    const CustomGroup = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-35a2e251"]]);
    const _hoisted_1$q = {
      key: 0,
      class: "config-group"
    };
    const _sfc_main$s = /* @__PURE__ */ defineComponent({
      __name: "ConfigGroup",
      props: {
        groupType: null,
        index: null,
        minimize: { type: Boolean }
      },
      setup(__props) {
        var _a;
        const pageStore = usePageStore();
        const { activeNode } = storeToRefs(pageStore);
        const componentNameMap = {
          common: null,
          basic: BasicGroup,
          size: SizeGroup,
          font: FontGroup,
          spacing: SpacingGroup,
          position: PositionGroup,
          layout: LayoutGroup,
          border: BorderGroup,
          background: BackgroundGroup,
          container: ContainerGroup,
          event: EventGroup,
          effect: EffectGroup,
          animation: AnimationGroup,
          custom: CustomGroup
        };
        const ignoreGroup = ((_a = activeNode.value) == null ? void 0 : _a.type) === "section" ? ["position"] : [];
        const bindProps = computed(() => {
          var _a2, _b;
          return ((_a2 = activeNode.value) == null ? void 0 : _a2.isModule) ? (_b = activeNode.value.moduleConfig) == null ? void 0 : _b[__props.index] : { [__props.groupType]: useGroupConfig(activeNode.value, __props.groupType) };
        });
        const iconName = computed(() => {
          var _a2;
          return ((_a2 = bindProps.value) == null ? void 0 : _a2.icon) || groupIconMap[__props.groupType] || defaultGroupIcon;
        });
        const showTitle = computed(() => {
          var _a2, _b, _c;
          return ((_a2 = bindProps.value) == null ? void 0 : _a2.title) ? lang === "en" && ((_b = bindProps.value) == null ? void 0 : _b.titleEn) || ((_c = bindProps.value) == null ? void 0 : _c.title) : groupTitleMap[__props.groupType];
        });
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return unref$1(activeNode) && componentNameMap[__props.groupType] && !unref$1(ignoreGroup).includes(__props.groupType) ? (openBlock(), createElementBlock("div", _hoisted_1$q, [
            !__props.minimize ? (openBlock(), createBlock(resolveDynamicComponent(componentNameMap[__props.groupType]), mergeProps({
              key: 0,
              node: unref$1(activeNode)
            }, bindProps.value), null, 16, ["node"])) : (openBlock(), createBlock(_sfc_main$X, {
              key: 1,
              type: "pure",
              "show-group": __props.groupType,
              "popper-class": "group-dropdown",
              "is-menu": "",
              placement: "left-start"
            }, {
              default: withCtx(({ shown }) => [
                withDirectives((openBlock(), createElementBlock("div", {
                  class: normalizeClass(["config-group-mini-item", { active: shown }])
                }, [
                  createVNode(Icon$1, {
                    name: iconName.value,
                    size: 16
                  }, null, 8, ["name"])
                ], 2)), [
                  [_directive_tooltip, { content: showTitle.value, placement: "left", disabled: !showTitle.value }]
                ])
              ]),
              content: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(componentNameMap[__props.groupType]), mergeProps({
                  node: unref$1(activeNode),
                  minimize: true
                }, bindProps.value), null, 16, ["node"]))
              ]),
              _: 1
            }, 8, ["show-group"]))
          ])) : createCommentVNode("", true);
        };
      }
    });
    const ConfigGroup_vue_vue_type_style_index_0_scoped_d70e7bc7_lang = "";
    const ConfigGroup_vue_vue_type_style_index_1_lang = "";
    const ConfigGroup = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-d70e7bc7"]]);
    const validNameReg = /[^0-9a-zA-Z\u4e00-\u9fa5_-]/g;
    const isValidName = (name) => {
      return !validNameReg.test(name);
    };
    const getUnValidChar = (name) => {
      const matchObj = name.match(validNameReg);
      return (matchObj == null ? void 0 : matchObj.length) ? [...new Set(matchObj)] : null;
    };
    var vueTagsInput = { exports: {} };
    (function(module2, exports2) {
      !function(A2, t) {
        module2.exports = t(require$$0$1);
      }(window, function(A2) {
        return function(A3) {
          var t = {};
          function e(n) {
            if (t[n])
              return t[n].exports;
            var i2 = t[n] = { i: n, l: false, exports: {} };
            return A3[n].call(i2.exports, i2, i2.exports, e), i2.l = true, i2.exports;
          }
          return e.m = A3, e.c = t, e.d = function(A4, t2, n) {
            e.o(A4, t2) || Object.defineProperty(A4, t2, { enumerable: true, get: n });
          }, e.r = function(A4) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(A4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(A4, "__esModule", { value: true });
          }, e.t = function(A4, t2) {
            if (1 & t2 && (A4 = e(A4)), 8 & t2)
              return A4;
            if (4 & t2 && "object" == typeof A4 && A4 && A4.__esModule)
              return A4;
            var n = /* @__PURE__ */ Object.create(null);
            if (e.r(n), Object.defineProperty(n, "default", { enumerable: true, value: A4 }), 2 & t2 && "string" != typeof A4)
              for (var i2 in A4)
                e.d(n, i2, function(t3) {
                  return A4[t3];
                }.bind(null, i2));
            return n;
          }, e.n = function(A4) {
            var t2 = A4 && A4.__esModule ? function() {
              return A4.default;
            } : function() {
              return A4;
            };
            return e.d(t2, "a", t2), t2;
          }, e.o = function(A4, t2) {
            return Object.prototype.hasOwnProperty.call(A4, t2);
          }, e.p = "/dist/", e(e.s = 7);
        }([function(t, e) {
          t.exports = A2;
        }, function(A3, t, e) {
          var n = e(9);
          n.__esModule && (n = n.default), "string" == typeof n && (n = [[A3.i, n, ""]]), n.locals && (A3.exports = n.locals);
          (0, e(5).default)("2847aebd", n, false, {});
        }, function(A3, t, e) {
          A3.exports = function(A4) {
            var t2 = [];
            return t2.toString = function() {
              return this.map(function(t3) {
                var e2 = function(A5, t4) {
                  var e3 = A5[1] || "", n = A5[3];
                  if (!n)
                    return e3;
                  if (t4 && "function" == typeof btoa) {
                    var i2 = (o = n, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o)))) + " */"), a = n.sources.map(function(A6) {
                      return "/*# sourceURL=" + n.sourceRoot + A6 + " */";
                    });
                    return [e3].concat(a).concat([i2]).join("\n");
                  }
                  var o;
                  return [e3].join("\n");
                }(t3, A4);
                return t3[2] ? "@media " + t3[2] + "{" + e2 + "}" : e2;
              }).join("");
            }, t2.i = function(A5, e2) {
              "string" == typeof A5 && (A5 = [[null, A5, ""]]);
              for (var n = {}, i2 = 0; i2 < this.length; i2++) {
                var a = this[i2][0];
                null != a && (n[a] = true);
              }
              for (i2 = 0; i2 < A5.length; i2++) {
                var o = A5[i2];
                null != o[0] && n[o[0]] || (e2 && !o[2] ? o[2] = e2 : e2 && (o[2] = "(" + o[2] + ") and (" + e2 + ")"), t2.push(o));
              }
            }, t2;
          };
        }, function(A3, t, e) {
          var n = e(11);
          n.__esModule && (n = n.default), "string" == typeof n && (n = [[A3.i, n, ""]]), n.locals && (A3.exports = n.locals);
          (0, e(5).default)("150d3839", n, false, {});
        }, function(A3, t) {
          A3.exports = "data:application/vnd.ms-fontobject;base64,aAUAAMQEAAABAAIAAAAAAAAAAAAAAAAAAAABAJABAAAAAExQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAUdPJHwAAAAAAAAAAAAAAAAAAAAAAAA4AaQBjAG8AbQBvAG8AbgAAAA4AUgBlAGcAdQBsAGEAcgAAABYAVgBlAHIAcwBpAG8AbgAgADEALgAwAAAADgBpAGMAbwBtAG8AbwBuAAAAAAAAAQAAAAsAgAADADBPUy8yDxIFrAAAALwAAABgY21hcBdW0okAAAEcAAAAVGdhc3AAAAAQAAABcAAAAAhnbHlmpZ+jMAAAAXgAAAD8aGVhZA/FmAgAAAJ0AAAANmhoZWEHgAPIAAACrAAAACRobXR4EgABvgAAAtAAAAAcbG9jYQCSAOIAAALsAAAAEG1heHAACQAfAAAC/AAAACBuYW1lmUoJ+wAAAxwAAAGGcG9zdAADAAAAAASkAAAAIAADA4ABkAAFAAACmQLMAAAAjwKZAswAAAHrADMBCQAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAEAAAOkCA8D/wABAA8AAQAAAAAEAAAAAAAAAAAAAACAAAAAAAAMAAAADAAAAHAABAAMAAAAcAAMAAQAAABwABAA4AAAACgAIAAIAAgABACDpAv/9//8AAAAAACDpAP/9//8AAf/jFwQAAwABAAAAAAAAAAAAAAABAAH//wAPAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAVgEBA74CgQAcAAABMhceARcWFwcmJy4BJyYjIgYHFyERFzY3PgE3NgIWSkNDbykpF2QQIB9VMzQ5P3AtnP6AmB0iIkspKAJVFxhSODlCIDMrKz4REislmgGAmhkVFBwICAABANYAgQMqAtUACwAAAQcXBycHJzcnNxc3Ayru7jzu7jzu7jzu7gKZ7u487u487u487u4AAQCSAIEDgAK9AAUAACUBFwEnNwGAAcQ8/gDuPPkBxDz+AO48AAAAAAEAAAAAAAAfydNRXw889QALBAAAAAAA1nUqGwAAAADWdSobAAAAAAO+AtUAAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAAA74AAQAAAAAAAAAAAAAAAAAAAAcEAAAAAAAAAAAAAAACAAAABAAAVgQAANYEAACSAAAAAAAKABQAHgBQAGoAfgABAAAABwAdAAEAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEABwAAAAEAAAAAAAIABwBgAAEAAAAAAAMABwA2AAEAAAAAAAQABwB1AAEAAAAAAAUACwAVAAEAAAAAAAYABwBLAAEAAAAAAAoAGgCKAAMAAQQJAAEADgAHAAMAAQQJAAIADgBnAAMAAQQJAAMADgA9AAMAAQQJAAQADgB8AAMAAQQJAAUAFgAgAAMAAQQJAAYADgBSAAMAAQQJAAoANACkaWNvbW9vbgBpAGMAbwBtAG8AbwBuVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwaWNvbW9vbgBpAGMAbwBtAG8AbwBuaWNvbW9vbgBpAGMAbwBtAG8AbwBuUmVndWxhcgBSAGUAZwB1AGwAYQByaWNvbW9vbgBpAGMAbwBtAG8AbwBuRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==";
        }, function(A3, t, e) {
          function n(A4, t2) {
            for (var e2 = [], n2 = {}, i3 = 0; i3 < t2.length; i3++) {
              var a2 = t2[i3], o2 = a2[0], r2 = { id: A4 + ":" + i3, css: a2[1], media: a2[2], sourceMap: a2[3] };
              n2[o2] ? n2[o2].parts.push(r2) : e2.push(n2[o2] = { id: o2, parts: [r2] });
            }
            return e2;
          }
          e.r(t), e.d(t, "default", function() {
            return g;
          });
          var i2 = "undefined" != typeof document;
          if ("undefined" != typeof DEBUG && DEBUG && !i2)
            throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
          var a = {}, o = i2 && (document.head || document.getElementsByTagName("head")[0]), r = null, s = 0, c = false, l = function() {
          }, u = null, d = "undefined" != typeof navigator && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
          function g(A4, t2, e2, i3) {
            c = e2, u = i3 || {};
            var o2 = n(A4, t2);
            return p2(o2), function(t3) {
              for (var e3 = [], i4 = 0; i4 < o2.length; i4++) {
                var r2 = o2[i4];
                (s2 = a[r2.id]).refs--, e3.push(s2);
              }
              t3 ? p2(o2 = n(A4, t3)) : o2 = [];
              for (i4 = 0; i4 < e3.length; i4++) {
                var s2;
                if (0 === (s2 = e3[i4]).refs) {
                  for (var c2 = 0; c2 < s2.parts.length; c2++)
                    s2.parts[c2]();
                  delete a[s2.id];
                }
              }
            };
          }
          function p2(A4) {
            for (var t2 = 0; t2 < A4.length; t2++) {
              var e2 = A4[t2], n2 = a[e2.id];
              if (n2) {
                n2.refs++;
                for (var i3 = 0; i3 < n2.parts.length; i3++)
                  n2.parts[i3](e2.parts[i3]);
                for (; i3 < e2.parts.length; i3++)
                  n2.parts.push(m(e2.parts[i3]));
                n2.parts.length > e2.parts.length && (n2.parts.length = e2.parts.length);
              } else {
                var o2 = [];
                for (i3 = 0; i3 < e2.parts.length; i3++)
                  o2.push(m(e2.parts[i3]));
                a[e2.id] = { id: e2.id, refs: 1, parts: o2 };
              }
            }
          }
          function f() {
            var A4 = document.createElement("style");
            return A4.type = "text/css", o.appendChild(A4), A4;
          }
          function m(A4) {
            var t2, e2, n2 = document.querySelector('style[data-vue-ssr-id~="' + A4.id + '"]');
            if (n2) {
              if (c)
                return l;
              n2.parentNode.removeChild(n2);
            }
            if (d) {
              var i3 = s++;
              n2 = r || (r = f()), t2 = h2.bind(null, n2, i3, false), e2 = h2.bind(null, n2, i3, true);
            } else
              n2 = f(), t2 = v.bind(null, n2), e2 = function() {
                n2.parentNode.removeChild(n2);
              };
            return t2(A4), function(n3) {
              if (n3) {
                if (n3.css === A4.css && n3.media === A4.media && n3.sourceMap === A4.sourceMap)
                  return;
                t2(A4 = n3);
              } else
                e2();
            };
          }
          var C2, B2 = (C2 = [], function(A4, t2) {
            return C2[A4] = t2, C2.filter(Boolean).join("\n");
          });
          function h2(A4, t2, e2, n2) {
            var i3 = e2 ? "" : n2.css;
            if (A4.styleSheet)
              A4.styleSheet.cssText = B2(t2, i3);
            else {
              var a2 = document.createTextNode(i3), o2 = A4.childNodes;
              o2[t2] && A4.removeChild(o2[t2]), o2.length ? A4.insertBefore(a2, o2[t2]) : A4.appendChild(a2);
            }
          }
          function v(A4, t2) {
            var e2 = t2.css, n2 = t2.media, i3 = t2.sourceMap;
            if (n2 && A4.setAttribute("media", n2), u.ssrId && A4.setAttribute("data-vue-ssr-id", t2.id), i3 && (e2 += "\n/*# sourceURL=" + i3.sources[0] + " */", e2 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(i3)))) + " */"), A4.styleSheet)
              A4.styleSheet.cssText = e2;
            else {
              for (; A4.firstChild; )
                A4.removeChild(A4.firstChild);
              A4.appendChild(document.createTextNode(e2));
            }
          }
        }, function(A3, t, e) {
          var n = Array.isArray, i2 = Object.keys, a = Object.prototype.hasOwnProperty;
          A3.exports = function A4(t2, e2) {
            if (t2 === e2)
              return true;
            if (t2 && e2 && "object" == typeof t2 && "object" == typeof e2) {
              var o, r, s, c = n(t2), l = n(e2);
              if (c && l) {
                if ((r = t2.length) != e2.length)
                  return false;
                for (o = r; 0 != o--; )
                  if (!A4(t2[o], e2[o]))
                    return false;
                return true;
              }
              if (c != l)
                return false;
              var u = t2 instanceof Date, d = e2 instanceof Date;
              if (u != d)
                return false;
              if (u && d)
                return t2.getTime() == e2.getTime();
              var g = t2 instanceof RegExp, p2 = e2 instanceof RegExp;
              if (g != p2)
                return false;
              if (g && p2)
                return t2.toString() == e2.toString();
              var f = i2(t2);
              if ((r = f.length) !== i2(e2).length)
                return false;
              for (o = r; 0 != o--; )
                if (!a.call(e2, f[o]))
                  return false;
              for (o = r; 0 != o--; )
                if (!A4(t2[s = f[o]], e2[s]))
                  return false;
              return true;
            }
            return t2 != t2 && e2 != e2;
          };
        }, function(A3, t, e) {
          A3.exports = e(15);
        }, function(A3, t, e) {
          e(1);
        }, function(A3, t, e) {
          (A3.exports = e(2)(true)).push([A3.i, ".ti-tag-input[data-v-69648ea0]{background-color:transparent;color:inherit;border:none;padding:0px;margin:0px;display:flex;top:0px;position:absolute;width:100%;line-height:inherit}.ti-tag-input[data-v-69648ea0]::-ms-clear{display:none}input[data-v-69648ea0]:focus{outline:none}input[disabled][data-v-69648ea0]{background-color:transparent}\n", "", { version: 3, sources: ["C:/Users/abcsi/Documents/repos/vue-tags-input/vue-tags-input/tag-input.vue"], names: [], mappings: "AAAA,+BAAc,4BAA4B,CAAC,aAAa,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,iBAAiB,CAAC,UAAU,CAAC,mBAAmB,CAAC,0CAAyB,YAAY,CAAC,6BAAY,YAAY,CAAC,iCAAgB,4BAA4B", file: "tag-input.vue?vue&type=style&index=0&id=69648ea0&lang=css&scoped=true", sourcesContent: [".ti-tag-input{background-color:transparent;color:inherit;border:none;padding:0px;margin:0px;display:flex;top:0px;position:absolute;width:100%;line-height:inherit}.ti-tag-input::-ms-clear{display:none}input:focus{outline:none}input[disabled]{background-color:transparent}\n"] }]);
        }, function(A3, t, e) {
          e(3);
        }, function(A3, t, e) {
          t = A3.exports = e(2)(true);
          var n = e(12), i2 = n(e(4)), a = n(e(4) + "#iefix"), o = n(e(13)), r = n(e(14));
          t.push([A3.i, "@font-face{font-family:'icomoon';src:url(" + i2 + ");src:url(" + a + ') format("embedded-opentype"),url(' + o + ') format("truetype"),url(' + r + `) format("woff");font-weight:normal;font-style:normal}[class^="ti-icon-"][data-v-2fbda277],[class*=" ti-icon-"][data-v-2fbda277]{font-family:'icomoon' !important;speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.ti-icon-check[data-v-2fbda277]:before{content:"\\e902"}.ti-icon-close[data-v-2fbda277]:before{content:"\\e901"}.ti-icon-undo[data-v-2fbda277]:before{content:"\\e900"}ul[data-v-2fbda277]{margin:0px;padding:0px;list-style-type:none}*[data-v-2fbda277],*[data-v-2fbda277]:before,*[data-v-2fbda277]:after{box-sizing:border-box}input[data-v-2fbda277]:focus{outline:none}input[disabled][data-v-2fbda277]{background-color:transparent}.vue-tags-input[data-v-2fbda277]{max-width:450px;position:relative;background-color:#fff}div.vue-tags-input.disabled[data-v-2fbda277]{opacity:0.5}div.vue-tags-input.disabled *[data-v-2fbda277]{cursor:default}.ti-input[data-v-2fbda277]{border:1px solid #ccc;display:flex;padding:4px;flex-wrap:wrap}.ti-tags[data-v-2fbda277]{display:flex;flex-wrap:wrap;width:100%;line-height:1em}.ti-tag[data-v-2fbda277]{background-color:#5C6BC0;color:#fff;border-radius:2px;display:flex;padding:3px 5px;margin:2px;font-size:.85em}.ti-tag[data-v-2fbda277]:focus{outline:none}.ti-tag .ti-content[data-v-2fbda277]{display:flex;align-items:center}.ti-tag .ti-tag-center[data-v-2fbda277]{position:relative}.ti-tag span[data-v-2fbda277]{line-height:.85em}.ti-tag span.ti-hidden[data-v-2fbda277]{padding-left:14px;visibility:hidden;height:0px;white-space:pre}.ti-tag .ti-actions[data-v-2fbda277]{margin-left:2px;display:flex;align-items:center;font-size:1.15em}.ti-tag .ti-actions i[data-v-2fbda277]{cursor:pointer}.ti-tag[data-v-2fbda277]:last-child{margin-right:4px}.ti-tag.ti-invalid[data-v-2fbda277],.ti-tag.ti-tag.ti-deletion-mark[data-v-2fbda277]{background-color:#e54d42}.ti-new-tag-input-wrapper[data-v-2fbda277]{display:flex;flex:1 0 auto;padding:3px 5px;margin:2px;font-size:.85em}.ti-new-tag-input-wrapper input[data-v-2fbda277]{flex:1 0 auto;min-width:100px;border:none;padding:0px;margin:0px}.ti-new-tag-input[data-v-2fbda277]{line-height:initial}.ti-autocomplete[data-v-2fbda277]{border:1px solid #ccc;border-top:none;position:absolute;width:100%;background-color:#fff;z-index:20}.ti-item>div[data-v-2fbda277]{cursor:pointer;padding:3px 6px;width:100%}.ti-selected-item[data-v-2fbda277]{background-color:#5C6BC0;color:#fff}
`, "", { version: 3, sources: ["C:/Users/abcsi/Documents/repos/vue-tags-input/vue-tags-input/vue-tags-input.scss"], names: [], mappings: "AAAA,WAAW,qBAAqB,CAAC,iCAA4C,CAAC,2JAAmM,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,2EAAyC,gCAAgC,CAAC,UAAU,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,mBAAmB,CAAC,aAAa,CAAC,kCAAkC,CAAC,iCAAiC,CAAC,uCAAsB,eAAe,CAAC,uCAAsB,eAAe,CAAC,sCAAqB,eAAe,CAAC,oBAAG,UAAU,CAAC,WAAW,CAAC,oBAAoB,CAAC,sEAAmB,qBAAqB,CAAC,6BAAY,YAAY,CAAC,iCAAgB,4BAA4B,CAAC,iCAAgB,eAAe,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,6CAA4B,WAAW,CAAC,+CAA8B,cAAc,CAAC,2BAAU,qBAAqB,CAAC,YAAY,CAAC,WAAW,CAAC,cAAc,CAAC,0BAAS,YAAY,CAAC,cAAc,CAAC,UAAU,CAAC,eAAe,CAAC,yBAAQ,wBAAwB,CAAC,UAAU,CAAC,iBAAiB,CAAC,YAAY,CAAC,eAAe,CAAC,UAAU,CAAC,eAAe,CAAC,+BAAc,YAAY,CAAC,qCAAoB,YAAY,CAAC,kBAAkB,CAAC,wCAAuB,iBAAiB,CAAC,8BAAa,iBAAiB,CAAC,wCAAuB,iBAAiB,CAAC,iBAAiB,CAAC,UAAU,CAAC,eAAe,CAAC,qCAAoB,eAAe,CAAC,YAAY,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,uCAAsB,cAAc,CAAC,oCAAmB,gBAAgB,CAAC,qFAAmD,wBAAwB,CAAC,2CAA0B,YAAY,CAAC,aAAa,CAAC,eAAe,CAAC,UAAU,CAAC,eAAe,CAAC,iDAAgC,aAAa,CAAC,eAAe,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC,mCAAkB,mBAAmB,CAAC,kCAAiB,qBAAqB,CAAC,eAAe,CAAC,iBAAiB,CAAC,UAAU,CAAC,qBAAqB,CAAC,UAAU,CAAC,8BAAa,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,mCAAkB,wBAAwB,CAAC,UAAU", file: "vue-tags-input.scss?vue&type=style&index=0&id=2fbda277&lang=scss&scoped=true", sourcesContent: [`@font-face{font-family:'icomoon';src:url("./assets/fonts/icomoon.eot?7grlse");src:url("./assets/fonts/icomoon.eot?7grlse#iefix") format("embedded-opentype"),url("./assets/fonts/icomoon.ttf?7grlse") format("truetype"),url("./assets/fonts/icomoon.woff?7grlse") format("woff");font-weight:normal;font-style:normal}[class^="ti-icon-"],[class*=" ti-icon-"]{font-family:'icomoon' !important;speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.ti-icon-check:before{content:"\\e902"}.ti-icon-close:before{content:"\\e901"}.ti-icon-undo:before{content:"\\e900"}ul{margin:0px;padding:0px;list-style-type:none}*,*:before,*:after{box-sizing:border-box}input:focus{outline:none}input[disabled]{background-color:transparent}.vue-tags-input{max-width:450px;position:relative;background-color:#fff}div.vue-tags-input.disabled{opacity:0.5}div.vue-tags-input.disabled *{cursor:default}.ti-input{border:1px solid #ccc;display:flex;padding:4px;flex-wrap:wrap}.ti-tags{display:flex;flex-wrap:wrap;width:100%;line-height:1em}.ti-tag{background-color:#5C6BC0;color:#fff;border-radius:2px;display:flex;padding:3px 5px;margin:2px;font-size:.85em}.ti-tag:focus{outline:none}.ti-tag .ti-content{display:flex;align-items:center}.ti-tag .ti-tag-center{position:relative}.ti-tag span{line-height:.85em}.ti-tag span.ti-hidden{padding-left:14px;visibility:hidden;height:0px;white-space:pre}.ti-tag .ti-actions{margin-left:2px;display:flex;align-items:center;font-size:1.15em}.ti-tag .ti-actions i{cursor:pointer}.ti-tag:last-child{margin-right:4px}.ti-tag.ti-invalid,.ti-tag.ti-tag.ti-deletion-mark{background-color:#e54d42}.ti-new-tag-input-wrapper{display:flex;flex:1 0 auto;padding:3px 5px;margin:2px;font-size:.85em}.ti-new-tag-input-wrapper input{flex:1 0 auto;min-width:100px;border:none;padding:0px;margin:0px}.ti-new-tag-input{line-height:initial}.ti-autocomplete{border:1px solid #ccc;border-top:none;position:absolute;width:100%;background-color:#fff;z-index:20}.ti-item>div{cursor:pointer;padding:3px 6px;width:100%}.ti-selected-item{background-color:#5C6BC0;color:#fff}
`] }]);
        }, function(A3, t, e) {
          A3.exports = function(A4, t2) {
            return "string" != typeof A4 ? A4 : (/^['"].*['"]$/.test(A4) && (A4 = A4.slice(1, -1)), /["'() \t\n]/.test(A4) || t2 ? '"' + A4.replace(/"/g, '\\"').replace(/\n/g, "\\n") + '"' : A4);
          };
        }, function(A3, t) {
          A3.exports = "data:font/ttf;base64,AAEAAAALAIAAAwAwT1MvMg8SBawAAAC8AAAAYGNtYXAXVtKJAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZqWfozAAAAF4AAAA/GhlYWQPxZgIAAACdAAAADZoaGVhB4ADyAAAAqwAAAAkaG10eBIAAb4AAALQAAAAHGxvY2EAkgDiAAAC7AAAABBtYXhwAAkAHwAAAvwAAAAgbmFtZZlKCfsAAAMcAAABhnBvc3QAAwAAAAAEpAAAACAAAwOAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpAgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6QL//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAFYBAQO+AoEAHAAAATIXHgEXFhcHJicuAScmIyIGBxchERc2Nz4BNzYCFkpDQ28pKRdkECAfVTM0OT9wLZz+gJgdIiJLKSgCVRcYUjg5QiAzKys+ERIrJZoBgJoZFRQcCAgAAQDWAIEDKgLVAAsAAAEHFwcnByc3JzcXNwMq7u487u487u487u4Cme7uPO7uPO7uPO7uAAEAkgCBA4ACvQAFAAAlARcBJzcBgAHEPP4A7jz5AcQ8/gDuPAAAAAABAAAAAAAAH8nTUV8PPPUACwQAAAAAANZ1KhsAAAAA1nUqGwAAAAADvgLVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAO+AAEAAAAAAAAAAAAAAAAAAAAHBAAAAAAAAAAAAAAAAgAAAAQAAFYEAADWBAAAkgAAAAAACgAUAB4AUABqAH4AAQAAAAcAHQABAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGljb21vb24AaQBjAG8AbQBvAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGljb21vb24AaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmljb21vb24AaQBjAG8AbQBvAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
        }, function(A3, t) {
          A3.exports = "data:font/woff;base64,d09GRgABAAAAAAUQAAsAAAAABMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFrGNtYXAAAAFoAAAAVAAAAFQXVtKJZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAPwAAAD8pZ+jMGhlYWQAAALAAAAANgAAADYPxZgIaGhlYQAAAvgAAAAkAAAAJAeAA8hobXR4AAADHAAAABwAAAAcEgABvmxvY2EAAAM4AAAAEAAAABAAkgDibWF4cAAAA0gAAAAgAAAAIAAJAB9uYW1lAAADaAAAAYYAAAGGmUoJ+3Bvc3QAAATwAAAAIAAAACAAAwAAAAMDgAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QIDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkC//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQBWAQEDvgKBABwAAAEyFx4BFxYXByYnLgEnJiMiBgcXIREXNjc+ATc2AhZKQ0NvKSkXZBAgH1UzNDk/cC2c/oCYHSIiSykoAlUXGFI4OUIgMysrPhESKyWaAYCaGRUUHAgIAAEA1gCBAyoC1QALAAABBxcHJwcnNyc3FzcDKu7uPO7uPO7uPO7uApnu7jzu7jzu7jzu7gABAJIAgQOAAr0ABQAAJQEXASc3AYABxDz+AO48+QHEPP4A7jwAAAAAAQAAAAAAAB/J01FfDzz1AAsEAAAAAADWdSobAAAAANZ1KhsAAAAAA74C1QAAAAgAAgAAAAAAAAABAAADwP/AAAAEAAAAAAADvgABAAAAAAAAAAAAAAAAAAAABwQAAAAAAAAAAAAAAAIAAAAEAABWBAAA1gQAAJIAAAAAAAoAFAAeAFAAagB+AAEAAAAHAB0AAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAGAAAQAAAAAAAwAHADYAAQAAAAAABAAHAHUAAQAAAAAABQALABUAAQAAAAAABgAHAEsAAQAAAAAACgAaAIoAAwABBAkAAQAOAAcAAwABBAkAAgAOAGcAAwABBAkAAwAOAD0AAwABBAkABAAOAHwAAwABBAkABQAWACAAAwABBAkABgAOAFIAAwABBAkACgA0AKRpY29tb29uAGkAYwBvAG0AbwBvAG5WZXJzaW9uIDEuMABWAGUAcgBzAGkAbwBuACAAMQAuADBpY29tb29uAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG5SZWd1bGFyAFIAZQBnAHUAbABhAHJpY29tb29uAGkAYwBvAG0AbwBvAG5Gb250IGdlbmVyYXRlZCBieSBJY29Nb29uLgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        }, function(A3, t, e) {
          e.r(t), e.d(t, "VueTagsInput", function() {
            return T;
          }), e.d(t, "createClasses", function() {
            return B2;
          }), e.d(t, "createTag", function() {
            return h2;
          }), e.d(t, "createTags", function() {
            return v;
          }), e.d(t, "TagInput", function() {
            return w;
          });
          var n = e(0), i2 = Object(n.withScopeId)("data-v-2fbda277");
          Object(n.pushScopeId)("data-v-2fbda277");
          var a = { class: "ti-input" }, o = { key: 0, class: "ti-tags" }, r = { class: "ti-content" }, s = { key: 0, class: "ti-tag-left" }, c = { key: 1, class: "ti-tag-right" }, l = { class: "ti-actions" }, u = { class: "ti-new-tag-input-wrapper" };
          Object(n.popScopeId)();
          var d = i2(function(A4, t2, e2, i3, d2, g2) {
            var p3 = Object(n.resolveComponent)("tag-input");
            return Object(n.openBlock)(), Object(n.createBlock)("div", { class: ["vue-tags-input", [{ "ti-disabled": A4.disabled }, { "ti-focus": A4.focused }, A4.$attrs.class]], style: A4.$attrs.style }, [Object(n.createVNode)("div", a, [A4.tagsCopy ? (Object(n.openBlock)(), Object(n.createBlock)("ul", o, [(Object(n.openBlock)(true), Object(n.createBlock)(n.Fragment, null, Object(n.renderList)(A4.tagsCopy, function(t3, e3) {
              return Object(n.openBlock)(), Object(n.createBlock)("li", { key: e3, style: t3.style, class: [[{ "ti-editing": A4.tagsEditStatus[e3] }, t3.tiClasses, t3.classes, { "ti-deletion-mark": A4.isMarked(e3) }], "ti-tag"], tabindex: "0", onClick: function(n2) {
                return A4.$emit("tag-clicked", { tag: t3, index: e3 });
              } }, [Object(n.createVNode)("div", r, [A4.$slots["tag-left"] ? (Object(n.openBlock)(), Object(n.createBlock)("div", s, [Object(n.renderSlot)(A4.$slots, "tag-left", { tag: t3, index: e3, edit: A4.tagsEditStatus[e3], performSaveEdit: A4.performSaveTag, performDelete: A4.performDeleteTag, performCancelEdit: A4.cancelEdit, performOpenEdit: A4.performEditTag, deletionMark: A4.isMarked(e3) }, void 0, true)])) : Object(n.createCommentVNode)("v-if", true), Object(n.createVNode)("div", { ref: A4.setTagCenter, class: "ti-tag-center" }, [A4.$slots["tag-center"] ? Object(n.createCommentVNode)("v-if", true) : (Object(n.openBlock)(), Object(n.createBlock)("span", { key: 0, class: { "ti-hidden": A4.tagsEditStatus[e3] }, onClick: function(t4) {
                return A4.performEditTag(e3);
              } }, Object(n.toDisplayString)(t3.text), 11, ["onClick"])), A4.$slots["tag-center"] ? Object(n.createCommentVNode)("v-if", true) : (Object(n.openBlock)(), Object(n.createBlock)(p3, { key: 1, scope: { edit: A4.tagsEditStatus[e3], maxlength: A4.maxlength, tag: t3, index: e3, validateTag: A4.createChangedTag, performCancelEdit: A4.cancelEdit, performSaveEdit: A4.performSaveTag } }, null, 8, ["scope"])), Object(n.renderSlot)(A4.$slots, "tag-center", { tag: t3, index: e3, maxlength: A4.maxlength, edit: A4.tagsEditStatus[e3], performSaveEdit: A4.performSaveTag, performDelete: A4.performDeleteTag, performCancelEdit: A4.cancelEdit, validateTag: A4.createChangedTag, performOpenEdit: A4.performEditTag, deletionMark: A4.isMarked(e3) }, void 0, true)], 512), A4.$slots["tag-right"] ? (Object(n.openBlock)(), Object(n.createBlock)("div", c, [Object(n.renderSlot)(A4.$slots, "tag-right", { tag: t3, index: e3, edit: A4.tagsEditStatus[e3], performSaveEdit: A4.performSaveTag, performDelete: A4.performDeleteTag, performCancelEdit: A4.cancelEdit, performOpenEdit: A4.performEditTag, deletionMark: A4.isMarked(e3) }, void 0, true)])) : Object(n.createCommentVNode)("v-if", true)]), Object(n.createVNode)("div", l, [Object(n.createCommentVNode)(" dont use v-if and v-else here -> different event calling on click?! "), A4.$slots["tag-actions"] ? Object(n.createCommentVNode)("v-if", true) : Object(n.withDirectives)((Object(n.openBlock)(), Object(n.createBlock)("i", { key: 0, class: "ti-icon-undo", onClick: function(t4) {
                return A4.cancelEdit(e3);
              } }, null, 8, ["onClick"])), [[n.vShow, A4.tagsEditStatus[e3]]]), A4.$slots["tag-actions"] ? Object(n.createCommentVNode)("v-if", true) : Object(n.withDirectives)((Object(n.openBlock)(), Object(n.createBlock)("i", { key: 1, class: "ti-icon-close", onClick: function(t4) {
                return A4.performDeleteTag(e3);
              } }, null, 8, ["onClick"])), [[n.vShow, !A4.tagsEditStatus[e3]]]), A4.$slots["tag-actions"] ? Object(n.renderSlot)(A4.$slots, "tag-actions", { key: 2, tag: t3, index: e3, edit: A4.tagsEditStatus[e3], performSaveEdit: A4.performSaveTag, performDelete: A4.performDeleteTag, performCancelEdit: A4.cancelEdit, performOpenEdit: A4.performEditTag, deletionMark: A4.isMarked(e3) }, void 0, true) : Object(n.createCommentVNode)("v-if", true)])], 14, ["onClick"]);
            }), 128)), Object(n.createVNode)("li", u, [Object(n.createVNode)("input", Object(n.mergeProps)({ ref: "newTagInput" }, A4.$attrs, { class: [[A4.createClasses(A4.newTag, A4.tags, A4.validation, A4.isDuplicate)], "ti-new-tag-input"], placeholder: A4.placeholder, value: A4.newTag, maxlength: A4.maxlength, disabled: A4.disabled, type: "text", size: "1", onKeydown: [t2[1] || (t2[1] = function(t3) {
              return A4.performAddTags(A4.filteredAutocompleteItems[A4.selectedItem] || A4.newTag, t3);
            }), t2[3] || (t2[3] = Object(n.withKeys)(function() {
              return A4.invokeDelete && A4.invokeDelete.apply(A4, arguments);
            }, ["delete"])), t2[4] || (t2[4] = Object(n.withKeys)(function() {
              return A4.performBlur && A4.performBlur.apply(A4, arguments);
            }, ["tab"])), t2[5] || (t2[5] = Object(n.withKeys)(function(t3) {
              return A4.selectItem(t3, "before");
            }, ["up"])), t2[6] || (t2[6] = Object(n.withKeys)(function(t3) {
              return A4.selectItem(t3, "after");
            }, ["down"]))], onPaste: t2[2] || (t2[2] = function() {
              return A4.addTagsFromPaste && A4.addTagsFromPaste.apply(A4, arguments);
            }), onInput: t2[7] || (t2[7] = function() {
              return A4.updateNewTag && A4.updateNewTag.apply(A4, arguments);
            }), onFocus: t2[8] || (t2[8] = function(t3) {
              return A4.focused = true;
            }), onClick: t2[9] || (t2[9] = function(t3) {
              return !A4.addOnlyFromAutocomplete && (A4.selectedItem = null);
            }) }), null, 16, ["placeholder", "value", "maxlength", "disabled"])])])) : Object(n.createCommentVNode)("v-if", true)]), Object(n.renderSlot)(A4.$slots, "between-elements", {}, void 0, true), A4.autocompleteOpen ? (Object(n.openBlock)(), Object(n.createBlock)("div", { key: 0, class: "ti-autocomplete", onMouseout: t2[10] || (t2[10] = function(t3) {
              return A4.selectedItem = null;
            }) }, [Object(n.renderSlot)(A4.$slots, "autocomplete-header", {}, void 0, true), Object(n.createVNode)("ul", null, [(Object(n.openBlock)(true), Object(n.createBlock)(n.Fragment, null, Object(n.renderList)(A4.filteredAutocompleteItems, function(t3, e3) {
              return Object(n.openBlock)(), Object(n.createBlock)("li", { key: e3, style: t3.style, class: [[t3.tiClasses, t3.classes, { "ti-selected-item": A4.isSelected(e3) }], "ti-item"], onMouseover: function(t4) {
                return !A4.disabled && (A4.selectedItem = e3);
              } }, [A4.$slots["autocomplete-item"] ? Object(n.renderSlot)(A4.$slots, "autocomplete-item", { key: 1, item: t3, index: e3, performAdd: function(t4) {
                return A4.performAddTags(t4, void 0, "autocomplete");
              }, selected: A4.isSelected(e3) }, void 0, true) : (Object(n.openBlock)(), Object(n.createBlock)("div", { key: 0, onClick: function(e4) {
                return A4.performAddTags(t3, void 0, "autocomplete");
              } }, Object(n.toDisplayString)(t3.text), 9, ["onClick"]))], 46, ["onMouseover"]);
            }), 128))]), Object(n.renderSlot)(A4.$slots, "autocomplete-footer", {}, void 0, true)], 32)) : Object(n.createCommentVNode)("v-if", true)], 6);
          }), g = e(6), p2 = e.n(g), f = function(A4, t2) {
            return t2.filter(function(t3) {
              var e2 = A4.text;
              return "string" == typeof t3.rule ? !new RegExp(t3.rule).test(e2) : t3.rule instanceof RegExp ? !t3.rule.test(e2) : "[object Function]" === {}.toString.call(t3.rule) ? t3.rule(A4) : void 0;
            }).map(function(A5) {
              return A5.classes;
            });
          }, m = function(A4) {
            return JSON.parse(JSON.stringify(A4));
          }, C2 = function(A4, t2) {
            for (var e2 = 0; e2 < A4.length; ) {
              if (t2(A4[e2], e2, A4))
                return e2;
              e2++;
            }
            return -1;
          }, B2 = function(A4, t2) {
            var e2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], n2 = arguments.length > 3 ? arguments[3] : void 0;
            void 0 === A4.text && (A4 = { text: A4 });
            var i3 = f(A4, e2), a2 = C2(t2, function(t3) {
              return t3 === A4;
            }), o2 = m(t2), r2 = -1 !== a2 ? o2.splice(a2, 1)[0] : m(A4), s2 = n2 ? n2(o2, r2) : -1 !== o2.map(function(A5) {
              return A5.text;
            }).indexOf(r2.text);
            return s2 && i3.push("ti-duplicate"), 0 === i3.length ? i3.push("ti-valid") : i3.push("ti-invalid"), i3;
          }, h2 = function(A4) {
            void 0 === A4.text && (A4 = { text: A4 });
            for (var t2 = m(A4), e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), i3 = 1; i3 < e2; i3++)
              n2[i3 - 1] = arguments[i3];
            return t2.tiClasses = B2.apply(void 0, [A4].concat(n2)), t2;
          }, v = function(A4) {
            for (var t2 = arguments.length, e2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
              e2[n2 - 1] = arguments[n2];
            return A4.map(function(t3) {
              return h2.apply(void 0, [t3, A4].concat(e2));
            });
          }, b = Object(n.withScopeId)("data-v-69648ea0")(function(A4, t2, e2, i3, a2, o2) {
            return e2.scope.edit ? Object(n.withDirectives)((Object(n.openBlock)(), Object(n.createBlock)("input", { key: 0, "onUpdate:modelValue": t2[1] || (t2[1] = function(A5) {
              return e2.scope.tag.text = A5;
            }), maxlength: e2.scope.maxlength, type: "text", class: "ti-tag-input", size: "1", onInput: t2[2] || (t2[2] = function(A5) {
              return e2.scope.validateTag(e2.scope.index, A5);
            }), onBlur: t2[3] || (t2[3] = function(A5) {
              return e2.scope.performCancelEdit(e2.scope.index);
            }), onKeydown: t2[4] || (t2[4] = function(A5) {
              return e2.scope.performSaveEdit(e2.scope.index, A5);
            }) }, null, 40, ["maxlength"])), [[n.vModelText, e2.scope.tag.text]]) : Object(n.createCommentVNode)("v-if", true);
          }), y = { name: "TagInput", props: { scope: { type: Object } } };
          e(8);
          y.render = b, y.__scopeId = "data-v-69648ea0";
          var w = y, x = function(A4) {
            return !A4.some(function(A5) {
              var t2 = !A5.text;
              t2 && console.warn('Missing property "text"', A5);
              var e2 = false;
              return A5.classes && (e2 = "string" != typeof A5.classes), e2 && console.warn('Property "classes" must be type of string', A5), t2 || e2;
            });
          }, k = function(A4) {
            return !A4.some(function(A5) {
              if ("number" == typeof A5) {
                var t2 = isFinite(A5) && Math.floor(A5) === A5;
                return t2 || console.warn("Only numerics are allowed for this prop. Found:", A5), !t2;
              }
              if ("string" == typeof A5) {
                var e2 = /\W|[a-z]|!\d/i.test(A5);
                return e2 || console.warn("Only alpha strings are allowed for this prop. Found:", A5), !e2;
              }
              return console.warn("Only numeric and string values are allowed. Found:", A5), false;
            });
          }, E = { modelValue: { type: String, default: "", required: true }, tags: { type: Array, default: function() {
            return [];
          }, validator: x }, autocompleteItems: { type: Array, default: function() {
            return [];
          }, validator: x }, allowEditTags: { type: Boolean, default: false }, autocompleteFilterDuplicates: { default: true, type: Boolean }, addOnlyFromAutocomplete: { type: Boolean, default: false }, autocompleteMinLength: { type: Number, default: 1 }, autocompleteAlwaysOpen: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, placeholder: { type: String, default: "Add Tag" }, addOnKey: { type: Array, default: function() {
            return [13];
          }, validator: k }, saveOnKey: { type: Array, default: function() {
            return [13];
          }, validator: k }, maxTags: { type: Number }, maxlength: { type: Number }, validation: { type: Array, default: function() {
            return [];
          }, validator: function(A4) {
            return !A4.some(function(A5) {
              var t2 = !A5.rule;
              t2 && console.warn('Property "rule" is missing', A5);
              var e2 = A5.rule && ("string" == typeof A5.rule || A5.rule instanceof RegExp || "[object Function]" === {}.toString.call(A5.rule));
              e2 || console.warn("A rule must be type of string, RegExp or function. Found:", JSON.stringify(A5.rule));
              var n2 = !A5.classes;
              n2 && console.warn('Property "classes" is missing', A5);
              var i3 = A5.type && "string" != typeof A5.type;
              return i3 && console.warn('Property "type" must be type of string. Found:', A5), !e2 || t2 || n2 || i3;
            });
          } }, separators: { type: Array, default: function() {
            return [";"];
          }, validator: function(A4) {
            return !A4.some(function(A5) {
              var t2 = "string" != typeof A5;
              return t2 && console.warn("Separators must be type of string. Found:", A5), t2;
            });
          } }, avoidAddingDuplicates: { type: Boolean, default: true }, addOnBlur: { type: Boolean, default: true }, isDuplicate: { type: Function, default: null }, addFromPaste: { type: Boolean, default: true }, deleteOnBackspace: { default: true, type: Boolean }, onBeforeAddingTag: Function, onBeforeDeletingTag: Function, onBeforeEditingTag: Function, onBeforeSavingTag: Function };
          function O(A4) {
            return (O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(A5) {
              return typeof A5;
            } : function(A5) {
              return A5 && "function" == typeof Symbol && A5.constructor === Symbol && A5 !== Symbol.prototype ? "symbol" : typeof A5;
            })(A4);
          }
          var Q = { name: "VueTagsInput", components: { TagInput: w }, props: E, emits: ["adding-duplicate", "before-adding-tag", "before-deleting-tag", "before-editing-tag", "before-saving-tag", "max-tags-reached", "saving-duplicate", "tags-changed", "tag-clicked", "update:modelValue", "update:tags"], inheritAttrs: false, data: function() {
            return { tagCenter: [], newTag: null, tagsCopy: null, tagsEditStatus: null, deletionMark: null, deletionMarkTime: null, selectedItem: null, focused: null };
          }, computed: { autocompleteOpen: function() {
            return !!this.autocompleteAlwaysOpen || null !== this.newTag && this.newTag.length >= this.autocompleteMinLength && this.filteredAutocompleteItems.length > 0 && this.focused;
          }, filteredAutocompleteItems: function() {
            var A4 = this, t2 = this.autocompleteItems.map(function(t3) {
              return h2(t3, A4.tags, A4.validation, A4.isDuplicate);
            });
            return this.autocompleteFilterDuplicates ? t2.filter(this.duplicateFilter) : t2;
          } }, methods: { createClasses: B2, getSelectedIndex: function(A4) {
            var t2 = this.filteredAutocompleteItems, e2 = this.selectedItem, n2 = t2.length - 1;
            if (0 !== t2.length)
              return null === e2 ? 0 : "before" === A4 && 0 === e2 ? n2 : "after" === A4 && e2 === n2 ? 0 : "after" === A4 ? e2 + 1 : e2 - 1;
          }, selectDefaultItem: function() {
            this.addOnlyFromAutocomplete && this.filteredAutocompleteItems.length > 0 ? this.selectedItem = 0 : this.selectedItem = null;
          }, selectItem: function(A4, t2) {
            A4.preventDefault(), this.selectedItem = this.getSelectedIndex(t2);
          }, isSelected: function(A4) {
            return this.selectedItem === A4;
          }, isMarked: function(A4) {
            return this.deletionMark === A4;
          }, setTagCenter: function(A4) {
            A4 && this.tagCenter.push(A4);
          }, invokeDelete: function() {
            var A4 = this;
            if (this.deleteOnBackspace && !(this.newTag.length > 0)) {
              var t2 = this.tagsCopy.length - 1;
              null === this.deletionMark ? (this.deletionMarkTime = setTimeout(function() {
                return A4.deletionMark = null;
              }, 1e3), this.deletionMark = t2) : this.performDeleteTag(t2);
            }
          }, addTagsFromPaste: function() {
            var A4 = this;
            this.addFromPaste && setTimeout(function() {
              return A4.performAddTags(A4.newTag);
            }, 10);
          }, performEditTag: function(A4) {
            var t2 = this;
            this.allowEditTags && (this.onBeforeAddingTag || this.editTag(A4), this.$emit("before-editing-tag", { index: A4, tag: this.tagsCopy[A4], editTag: function() {
              return t2.editTag(A4);
            } }));
          }, editTag: function(A4) {
            this.allowEditTags && (this.toggleEditMode(A4), this.focus(A4));
          }, toggleEditMode: function(A4) {
            this.allowEditTags && !this.disabled && (this.tagsEditStatus[A4] = !this.tagsEditStatus[A4]);
          }, createChangedTag: function(A4, t2) {
            var e2 = this.tagsCopy[A4];
            e2.text = t2 ? t2.target.value : this.tagsCopy[A4].text, this.tagsCopy[A4] = h2(e2, this.tagsCopy, this.validation, this.isDuplicate);
          }, focus: function(A4) {
            var t2 = this;
            this.$nextTick(function() {
              var e2 = t2.tagCenter[A4].querySelector("input.ti-tag-input");
              e2 && e2.focus();
            });
          }, quote: function(A4) {
            return A4.replace(/([()[{*+.$^\\|?])/g, "\\$1");
          }, cancelEdit: function(A4) {
            this.tags[A4] && (this.tagsCopy[A4] = m(h2(this.tags[A4], this.tags, this.validation, this.isDuplicate)), this.tagsEditStatus[A4] = false);
          }, hasForbiddingAddRule: function(A4) {
            var t2 = this;
            return A4.some(function(A5) {
              var e2 = t2.validation.find(function(t3) {
                return A5 === t3.classes;
              });
              return !!e2 && e2.disableAdd;
            });
          }, createTagTexts: function(A4) {
            var t2 = this, e2 = new RegExp(this.separators.map(function(A5) {
              return t2.quote(A5);
            }).join("|"));
            return A4.split(e2).map(function(A5) {
              return { text: A5 };
            });
          }, performDeleteTag: function(A4) {
            var t2 = this;
            this.onBeforeDeletingTag || this.deleteTag(A4), this.$emit("before-deleting-tag", { index: A4, tag: this.tagsCopy[A4], deleteTag: function() {
              return t2.deleteTag(A4);
            } });
          }, deleteTag: function(A4) {
            this.disabled || (this.deletionMark = null, clearTimeout(this.deletionMarkTime), this.tagsCopy.splice(A4, 1), this.$emit("update:tags", this.tagsCopy), this.$emit("tags-changed", this.tagsCopy));
          }, noTriggerKey: function(A4, t2) {
            var e2 = -1 !== this[t2].indexOf(A4.keyCode) || -1 !== this[t2].indexOf(A4.key);
            return e2 && A4.preventDefault(), !e2;
          }, performAddTags: function(A4, t2, e2) {
            var n2 = this;
            if (!(this.disabled || t2 && this.noTriggerKey(t2, "addOnKey"))) {
              var i3 = [];
              "object" === O(A4) && (i3 = [A4]), "string" == typeof A4 && (i3 = this.createTagTexts(A4)), (i3 = i3.filter(function(A5) {
                return A5.text.trim().length > 0;
              })).forEach(function(A5) {
                A5 = h2(A5, n2.tags, n2.validation, n2.isDuplicate), n2.onBeforeAddingTag || n2.addTag(A5, e2), n2.$emit("before-adding-tag", { tag: A5, addTag: function() {
                  return n2.addTag(A5, e2);
                } });
              });
            }
          }, duplicateFilter: function(A4) {
            return this.isDuplicate ? !this.isDuplicate(this.tagsCopy, A4) : !this.tagsCopy.find(function(t2) {
              return t2.text === A4.text;
            });
          }, addTag: function(A4) {
            var t2 = this, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "new-tag-input", n2 = this.filteredAutocompleteItems.map(function(A5) {
              return A5.text;
            });
            this.addOnlyFromAutocomplete && -1 === n2.indexOf(A4.text) || this.$nextTick(function() {
              return t2.maxTags && t2.maxTags <= t2.tagsCopy.length ? t2.$emit("max-tags-reached", A4) : t2.avoidAddingDuplicates && !t2.duplicateFilter(A4) ? t2.$emit("adding-duplicate", A4) : void (t2.hasForbiddingAddRule(A4.tiClasses) || (t2.newTag = "", t2.tagsCopy.push(A4), t2.$emit("update:tags", t2.tagsCopy), "autocomplete" === e2 && t2.$refs.newTagInput.focus(), t2.$emit("tags-changed", t2.tagsCopy)));
            });
          }, performSaveTag: function(A4, t2) {
            var e2 = this, n2 = this.tagsCopy[A4];
            this.disabled || t2 && this.noTriggerKey(t2, "addOnKey") || 0 !== n2.text.trim().length && (this["on-before-saving-tag"] || this.saveTag(A4, n2), this.$emit("before-saving-tag", { index: A4, tag: n2, saveTag: function() {
              return e2.saveTag(A4, n2);
            } }));
          }, saveTag: function(A4, t2) {
            if (this.avoidAddingDuplicates) {
              var e2 = m(this.tagsCopy), n2 = e2.splice(A4, 1)[0];
              if (this.isDuplicate ? this.isDuplicate(e2, n2) : -1 !== e2.map(function(A5) {
                return A5.text;
              }).indexOf(n2.text))
                return this.$emit("saving-duplicate", t2);
            }
            this.hasForbiddingAddRule(t2.tiClasses) || (this.tagsCopy[A4] = t2, this.toggleEditMode(A4), this.$emit("update:tags", this.tagsCopy), this.$emit("tags-changed", this.tagsCopy));
          }, tagsEqual: function() {
            var A4 = this;
            return !this.tagsCopy.some(function(t2, e2) {
              return !p2()(t2, A4.tags[e2]);
            });
          }, updateNewTag: function(A4) {
            var t2 = A4.target.value;
            this.newTag = t2, this.$emit("update:modelValue", t2);
          }, initTags: function() {
            this.tagsCopy = v(this.tags, this.validation, this.isDuplicate), this.tagsEditStatus = m(this.tags).map(function() {
              return false;
            }), this.tagsEqual() || this.$emit("update:tags", this.tagsCopy);
          }, blurredOnClick: function(A4) {
            this.$el.contains(A4.target) || this.$el.contains(document.activeElement) || this.performBlur(A4);
          }, performBlur: function() {
            this.addOnBlur && this.focused && this.performAddTags(this.newTag), this.focused = false;
          } }, watch: { modelValue: function(A4) {
            this.addOnlyFromAutocomplete || (this.selectedItem = null), this.newTag = A4;
          }, tags: { handler: function() {
            this.initTags();
          }, deep: true }, autocompleteOpen: "selectDefaultItem" }, created: function() {
            this.newTag = this.modelValue, this.initTags();
          }, mounted: function() {
            this.selectDefaultItem(), document.addEventListener("click", this.blurredOnClick);
          }, beforeUpdate: function() {
            this.tagCenter = [];
          }, unmounted: function() {
            document.removeEventListener("click", this.blurredOnClick);
          } };
          e(10);
          Q.render = d, Q.__scopeId = "data-v-2fbda277";
          var T = Q;
          T.install = function(A4) {
            return A4.component(T.name, T);
          }, "undefined" != typeof window && window.Vue && window.Vue.use(T);
          t.default = T;
        }]);
      });
    })(vueTagsInput);
    const _hoisted_1$p = { class: "tag-content" };
    const _sfc_main$r = /* @__PURE__ */ defineComponent({
      __name: "TagList",
      props: {
        tags: { default: () => [] },
        autoCompleteTags: { default: () => [] }
      },
      emits: ["change"],
      setup(__props, { emit }) {
        let tag = ref("");
        const handleTagsChange = (newTags) => {
          emit("change", newTags.map((item) => item.text));
        };
        const handleAddTag = async (obj) => {
          const invalidChar = getUnValidChar(obj.tag.text);
          if (invalidChar == null ? void 0 : invalidChar.length) {
            tag.value = tag.value.replace(new RegExp(`[${invalidChar.join("|")}]`, "g"), "");
            return;
          }
          obj.addTag();
        };
        const filteredItems = computed(() => {
          return __props.autoCompleteTags.filter((i2) => i2.toLowerCase().indexOf(tag.value.toLowerCase()) !== -1).map((i2) => ({ text: i2 }));
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$p, [
            createVNode(unref$1(vueTagsInput.exports.VueTagsInput), {
              class: "tag-input",
              modelValue: tag.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tag.value = $event),
              placeholder: _ctx.$t("addTag"),
              tags: __props.tags.map((i2) => ({ text: i2 })),
              "autocomplete-items": filteredItems.value,
              onBeforeAddingTag: handleAddTag,
              onTagsChanged: handleTagsChange
            }, null, 8, ["modelValue", "placeholder", "tags", "autocomplete-items"])
          ]);
        };
      }
    });
    const TagList_vue_vue_type_style_index_0_lang = "";
    var axios$2 = { exports: {} };
    var axios$1 = { exports: {} };
    var bind$3 = function bind3(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn.apply(thisArg, args);
      };
    };
    var bind$2 = bind$3;
    var toString = Object.prototype.toString;
    var kindOf = function(cache2) {
      return function(thing) {
        var str = toString.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type2) {
      type2 = type2.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type2;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber$1(val) {
      return typeof val === "number";
    }
    function isObject$1(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject$1(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype2 = Object.getPrototypeOf(val);
      return prototype2 === null || prototype2 === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction$1(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject$1(val) && isFunction$1(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i2 = 0, l = obj.length; i2 < l; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue2(val, key) {
        if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject$1(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
        forEach(arguments[i2], assignValue2);
      }
      return result;
    }
    function extend$2(a, b, thisArg) {
      forEach(b, function assignValue2(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind$2(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors2) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i2;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i2 = thing.length;
      if (isUndefined(i2))
        return null;
      var arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray2) {
      return function(thing) {
        return TypedArray2 && thing instanceof TypedArray2;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    var utils$b = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber: isNumber$1,
      isObject: isObject$1,
      isPlainObject: isPlainObject$1,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend$2,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
    var utils$a = utils$b;
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils$a.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils$a.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils$a.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils$a.forEach(val, function parseValue(v) {
            if (utils$a.isDate(v)) {
              v = v.toISOString();
            } else if (utils$a.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
    var utils$9 = utils$b;
    function InterceptorManager$1() {
      this.handlers = [];
    }
    InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager$1.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager$1.prototype.forEach = function forEach2(fn) {
      utils$9.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    };
    var InterceptorManager_1 = InterceptorManager$1;
    var utils$8 = utils$b;
    var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
      utils$8.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
    var utils$7 = utils$b;
    function AxiosError$2(message, code, config2, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config2 && (this.config = config2);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$7.inherits(AxiosError$2, Error, {
      toJSON: function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError$2.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError$2, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError$2.from = function(error, code, config2, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils$7.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError$2.call(axiosError, error.message, code, config2, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var AxiosError_1 = AxiosError$2;
    var transitional = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var utils$6 = utils$b;
    function toFormData$1(obj, formData) {
      formData = formData || new FormData();
      var stack2 = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$6.isDate(value)) {
          return value.toISOString();
        }
        if (utils$6.isArrayBuffer(value) || utils$6.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data2, parentKey) {
        if (utils$6.isPlainObject(data2) || utils$6.isArray(data2)) {
          if (stack2.indexOf(data2) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack2.push(data2);
          utils$6.forEach(data2, function each(value, key) {
            if (utils$6.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils$6.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils$6.endsWith(key, "[]") && (arr = utils$6.toArray(value))) {
                arr.forEach(function(el) {
                  !utils$6.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack2.pop();
        } else {
          formData.append(parentKey, convertValue(data2));
        }
      }
      build(obj);
      return formData;
    }
    var toFormData_1 = toFormData$1;
    var settle;
    var hasRequiredSettle;
    function requireSettle() {
      if (hasRequiredSettle)
        return settle;
      hasRequiredSettle = 1;
      var AxiosError2 = AxiosError_1;
      settle = function settle2(resolve2, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve2(response);
        } else {
          reject(new AxiosError2("Request failed with status code " + response.status, [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
        }
      };
      return settle;
    }
    var cookies;
    var hasRequiredCookies;
    function requireCookies() {
      if (hasRequiredCookies)
        return cookies;
      hasRequiredCookies = 1;
      var utils2 = utils$b;
      cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils2.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils2.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils2.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove2(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove2() {
          }
        };
      }();
      return cookies;
    }
    var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
    var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
    var isAbsoluteURL = isAbsoluteURL$1;
    var combineURLs = combineURLs$1;
    var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
    var parseHeaders;
    var hasRequiredParseHeaders;
    function requireParseHeaders() {
      if (hasRequiredParseHeaders)
        return parseHeaders;
      hasRequiredParseHeaders = 1;
      var utils2 = utils$b;
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      parseHeaders = function parseHeaders2(headers) {
        var parsed = {};
        var key;
        var val;
        var i2;
        if (!headers) {
          return parsed;
        }
        utils2.forEach(headers.split("\n"), function parser(line) {
          i2 = line.indexOf(":");
          key = utils2.trim(line.substr(0, i2)).toLowerCase();
          val = utils2.trim(line.substr(i2 + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
      return parseHeaders;
    }
    var isURLSameOrigin;
    var hasRequiredIsURLSameOrigin;
    function requireIsURLSameOrigin() {
      if (hasRequiredIsURLSameOrigin)
        return isURLSameOrigin;
      hasRequiredIsURLSameOrigin = 1;
      var utils2 = utils$b;
      isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }();
      return isURLSameOrigin;
    }
    var CanceledError_1;
    var hasRequiredCanceledError;
    function requireCanceledError() {
      if (hasRequiredCanceledError)
        return CanceledError_1;
      hasRequiredCanceledError = 1;
      var AxiosError2 = AxiosError_1;
      var utils2 = utils$b;
      function CanceledError2(message) {
        AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
        this.name = "CanceledError";
      }
      utils2.inherits(CanceledError2, AxiosError2, {
        __CANCEL__: true
      });
      CanceledError_1 = CanceledError2;
      return CanceledError_1;
    }
    var parseProtocol;
    var hasRequiredParseProtocol;
    function requireParseProtocol() {
      if (hasRequiredParseProtocol)
        return parseProtocol;
      hasRequiredParseProtocol = 1;
      parseProtocol = function parseProtocol2(url) {
        var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return match && match[1] || "";
      };
      return parseProtocol;
    }
    var xhr;
    var hasRequiredXhr;
    function requireXhr() {
      if (hasRequiredXhr)
        return xhr;
      hasRequiredXhr = 1;
      var utils2 = utils$b;
      var settle2 = requireSettle();
      var cookies2 = requireCookies();
      var buildURL2 = buildURL$1;
      var buildFullPath2 = buildFullPath$1;
      var parseHeaders2 = requireParseHeaders();
      var isURLSameOrigin2 = requireIsURLSameOrigin();
      var transitionalDefaults2 = transitional;
      var AxiosError2 = AxiosError_1;
      var CanceledError2 = requireCanceledError();
      var parseProtocol2 = requireParseProtocol();
      xhr = function xhrAdapter(config2) {
        return new Promise(function dispatchXhrRequest(resolve2, reject) {
          var requestData = config2.data;
          var requestHeaders = config2.headers;
          var responseType = config2.responseType;
          var onCanceled;
          function done() {
            if (config2.cancelToken) {
              config2.cancelToken.unsubscribe(onCanceled);
            }
            if (config2.signal) {
              config2.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config2.auth) {
            var username = config2.auth.username || "";
            var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath2(config2.baseURL, config2.url);
          request.open(config2.method.toUpperCase(), buildURL2(fullPath, config2.params, config2.paramsSerializer), true);
          request.timeout = config2.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config2,
              request
            };
            settle2(function _resolve(value) {
              resolve2(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config2, request));
            request = null;
          };
          request.onerror = function handleError2() {
            reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config2, request, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
            var transitional2 = config2.transitional || transitionalDefaults2;
            if (config2.timeoutErrorMessage) {
              timeoutErrorMessage = config2.timeoutErrorMessage;
            }
            reject(new AxiosError2(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED, config2, request));
            request = null;
          };
          if (utils2.isStandardBrowserEnv()) {
            var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config2.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils2.isUndefined(config2.withCredentials)) {
            request.withCredentials = !!config2.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config2.responseType;
          }
          if (typeof config2.onDownloadProgress === "function") {
            request.addEventListener("progress", config2.onDownloadProgress);
          }
          if (typeof config2.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config2.onUploadProgress);
          }
          if (config2.cancelToken || config2.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new CanceledError2() : cancel);
              request.abort();
              request = null;
            };
            config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
            if (config2.signal) {
              config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          var protocol = parseProtocol2(fullPath);
          if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
            reject(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config2));
            return;
          }
          request.send(requestData);
        });
      };
      return xhr;
    }
    var _null;
    var hasRequired_null;
    function require_null() {
      if (hasRequired_null)
        return _null;
      hasRequired_null = 1;
      _null = null;
      return _null;
    }
    var utils$5 = utils$b;
    var normalizeHeaderName = normalizeHeaderName$1;
    var AxiosError$1 = AxiosError_1;
    var transitionalDefaults = transitional;
    var toFormData = toFormData_1;
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = requireXhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = requireXhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder2) {
      if (utils$5.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$5.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder2 || JSON.stringify)(rawValue);
    }
    var defaults$4 = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data2, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
          return data2;
        }
        if (utils$5.isArrayBufferView(data2)) {
          return data2.buffer;
        }
        if (utils$5.isURLSearchParams(data2)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data2.toString();
        }
        var isObjectPayload = utils$5.isObject(data2);
        var contentType = headers && headers["Content-Type"];
        var isFileList2;
        if ((isFileList2 = utils$5.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data2);
        }
        return data2;
      }],
      transformResponse: [function transformResponse(data2) {
        var transitional2 = this.transitional || defaults$4.transitional;
        var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
          try {
            return JSON.parse(data2);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data2;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_null()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults$4.headers[method] = {};
    });
    utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults$4.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
    });
    var defaults_1 = defaults$4;
    var utils$4 = utils$b;
    var defaults$3 = defaults_1;
    var transformData$1 = function transformData2(data2, headers, fns) {
      var context = this || defaults$3;
      utils$4.forEach(fns, function transform2(fn) {
        data2 = fn.call(context, data2, headers);
      });
      return data2;
    };
    var isCancel$1;
    var hasRequiredIsCancel;
    function requireIsCancel() {
      if (hasRequiredIsCancel)
        return isCancel$1;
      hasRequiredIsCancel = 1;
      isCancel$1 = function isCancel2(value) {
        return !!(value && value.__CANCEL__);
      };
      return isCancel$1;
    }
    var utils$3 = utils$b;
    var transformData = transformData$1;
    var isCancel = requireIsCancel();
    var defaults$2 = defaults_1;
    var CanceledError = requireCanceledError();
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError();
      }
    }
    var dispatchRequest$1 = function dispatchRequest2(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = config2.headers || {};
      config2.data = transformData.call(config2, config2.data, config2.headers, config2.transformRequest);
      config2.headers = utils$3.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
      utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config2.headers[method];
      });
      var adapter = config2.adapter || defaults$2.adapter;
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(config2, response.data, response.headers, config2.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config2, reason.response.data, reason.response.headers, config2.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
    var utils$2 = utils$b;
    var mergeConfig$2 = function mergeConfig2(config1, config2) {
      config2 = config2 || {};
      var config3 = {};
      function getMergedValue(target, source) {
        if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
          return utils$2.merge(target, source);
        } else if (utils$2.isPlainObject(source)) {
          return utils$2.merge({}, source);
        } else if (utils$2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils$2.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils$2.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge2 = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge2(prop);
        utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    };
    var data;
    var hasRequiredData;
    function requireData() {
      if (hasRequiredData)
        return data;
      hasRequiredData = 1;
      data = {
        "version": "0.27.2"
      };
      return data;
    }
    var VERSION = requireData().version;
    var AxiosError = AxiosError_1;
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i2) {
      validators$1[type2] = function validator2(thing) {
        return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional2(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator2 === false) {
          throw new AxiosError(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError.ERR_DEPRECATED);
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys2 = Object.keys(options);
      var i2 = keys2.length;
      while (i2-- > 0) {
        var opt = keys2[i2];
        var validator2 = schema[opt];
        if (validator2) {
          var value = options[opt];
          var result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator$1 = {
      assertOptions,
      validators: validators$1
    };
    var utils$1 = utils$b;
    var buildURL = buildURL$1;
    var InterceptorManager = InterceptorManager_1;
    var dispatchRequest = dispatchRequest$1;
    var mergeConfig$1 = mergeConfig$2;
    var buildFullPath = buildFullPath$1;
    var validator = validator$1;
    var validators = validator.validators;
    function Axios$1(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios$1.prototype.request = function request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig$1(this.defaults, config2);
      if (config2.method) {
        config2.method = config2.method.toLowerCase();
      } else if (this.defaults.method) {
        config2.method = this.defaults.method.toLowerCase();
      } else {
        config2.method = "get";
      }
      var transitional2 = config2.transitional;
      if (transitional2 !== void 0) {
        validator.assertOptions(transitional2, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config2);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config2;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios$1.prototype.getUri = function getUri(config2) {
      config2 = mergeConfig$1(this.defaults, config2);
      var fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios$1.prototype[method] = function(url, config2) {
        return this.request(mergeConfig$1(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data2, config2) {
          return this.request(mergeConfig$1(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data: data2
          }));
        };
      }
      Axios$1.prototype[method] = generateHTTPMethod();
      Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios_1 = Axios$1;
    var CancelToken_1;
    var hasRequiredCancelToken;
    function requireCancelToken() {
      if (hasRequiredCancelToken)
        return CancelToken_1;
      hasRequiredCancelToken = 1;
      var CanceledError2 = requireCanceledError();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i2;
          var l = token._listeners.length;
          for (i2 = 0; i2 < l; i2++) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve2) {
            token.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError2(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      CancelToken_1 = CancelToken;
      return CancelToken_1;
    }
    var spread;
    var hasRequiredSpread;
    function requireSpread() {
      if (hasRequiredSpread)
        return spread;
      hasRequiredSpread = 1;
      spread = function spread2(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
      return spread;
    }
    var isAxiosError;
    var hasRequiredIsAxiosError;
    function requireIsAxiosError() {
      if (hasRequiredIsAxiosError)
        return isAxiosError;
      hasRequiredIsAxiosError = 1;
      var utils2 = utils$b;
      isAxiosError = function isAxiosError2(payload) {
        return utils2.isObject(payload) && payload.isAxiosError === true;
      };
      return isAxiosError;
    }
    var utils = utils$b;
    var bind = bind$3;
    var Axios = Axios_1;
    var mergeConfig = mergeConfig$2;
    var defaults$1 = defaults_1;
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios;
    axios.CanceledError = requireCanceledError();
    axios.CancelToken = requireCancelToken();
    axios.isCancel = requireIsCancel();
    axios.VERSION = requireData().version;
    axios.toFormData = toFormData_1;
    axios.AxiosError = AxiosError_1;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = requireSpread();
    axios.isAxiosError = requireIsAxiosError();
    axios$1.exports = axios;
    axios$1.exports.default = axios;
    (function(module2) {
      module2.exports = axios$1.exports;
    })(axios$2);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getAugmentedNamespace(n) {
      if (n.__esModule)
        return n;
      var a = Object.defineProperty({}, "__esModule", { value: true });
      Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n[k];
          }
        });
      });
      return a;
    }
    function commonjsRequire(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var lodash = { exports: {} };
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    (function(module2, exports2) {
      (function() {
        var undefined$12;
        var VERSION2 = "4.17.20";
        var LARGE_ARRAY_SIZE2 = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function";
        var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE2 = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN2 = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
        var reTrim2 = /^\s+|\s+$/g, reTrimStart2 = /^\s+/, reTrimEnd = /\s+$/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reEscapeChar2 = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags2 = /\w*$/;
        var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary2 = /^0b[01]+$/i;
        var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
        var reIsOctal2 = /^0o[0-7]+$/i;
        var reIsUint2 = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags2 = {};
        typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
        typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
        var cloneableTags2 = {};
        cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
        cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
        var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var freeProcess2 = moduleExports2 && freeGlobal2.process;
        var nodeUtil2 = function() {
          try {
            var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
        function apply2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array2, setter, iteratee, accumulator) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            var value = array2[index2];
            setter(accumulator, value, iteratee(value), array2);
          }
          return accumulator;
        }
        function arrayEach2(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (iteratee(array2[index2], index2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEachRight(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          while (length--) {
            if (iteratee(array2[length], length, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEvery(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (!predicate(array2[index2], index2, array2)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter2(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array2[index2];
            if (predicate(value, index2, array2)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          return !!length && baseIndexOf(array2, value, 0) > -1;
        }
        function arrayIncludesWith(array2, value, comparator) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (comparator(value, array2[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap2(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        function arrayPush2(array2, values) {
          var index2 = -1, length = values.length, offset2 = array2.length;
          while (++index2 < length) {
            array2[offset2 + index2] = values[index2];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array2[index2], index2, array2);
          }
          return accumulator;
        }
        function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
          var length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array2[length], length, array2);
          }
          return accumulator;
        }
        function arraySome(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string2) {
          return string2.split("");
        }
        function asciiWords(string2) {
          return string2.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array2, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (comparator(array2[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSum(array2, iteratee) / length : NAN2;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined$12 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined$12 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array2, comparer) {
          var length = array2.length;
          array2.sort(comparer);
          while (length--) {
            array2[length] = array2[length].value;
          }
          return array2;
        }
        function baseSum(array2, iteratee) {
          var result, index2 = -1, length = array2.length;
          while (++index2 < length) {
            var current = iteratee(array2[index2]);
            if (current !== undefined$12) {
              result = result === undefined$12 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes2(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap2(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseUnary2(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap2(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array2, placeholder) {
          var length = array2.length, result = 0;
          while (length--) {
            if (array2[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue2(object, key) {
          return object == null ? undefined$12 : object[key];
        }
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        function hasUnicodeWord(string2) {
          return reHasUnicodeWord.test(string2);
        }
        function iteratorToArray(iterator) {
          var data2, result = [];
          while (!(data2 = iterator.next()).done) {
            result.push(data2.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index2 = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg2(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array2, placeholder) {
          var index2 = -1, length = array2.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array2[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array2[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string2) {
          return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string2) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string2)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function unicodeWords(string2) {
          return string2.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
          var coreJsData2 = context["__core-js_shared__"];
          var funcToString2 = funcProto2.toString;
          var hasOwnProperty2 = objectProto2.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey2 = function() {
            var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
            return uid2 ? "Symbol(src)_1." + uid2 : "";
          }();
          var nativeObjectToString2 = objectProto2.toString;
          var objectCtorString2 = funcToString2.call(Object2);
          var oldDash = root2._;
          var reIsNative2 = RegExp2("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var Buffer2 = moduleExports2 ? context.Buffer : undefined$12, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : undefined$12, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$12;
          var defineProperty2 = function() {
            try {
              var func = getNative2(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : undefined$12, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
          var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
          var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$12, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$12;
          function lodash2(value) {
            if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty2.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate2 = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate2) {
                return objectCreate2(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined$12;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined$12;
          }
          lodash2.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash2
            }
          };
          lodash2.prototype = baseLodash.prototype;
          lodash2.prototype.constructor = lodash2;
          LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray2(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray2(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray2(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array2, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array2[index2];
                while (++iterIndex < iterLength) {
                  var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type2 = data2.type, computed2 = iteratee2(value);
                  if (type2 == LAZY_MAP_FLAG) {
                    value = computed2;
                  } else if (!computed2) {
                    if (type2 == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash2(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear2() {
            this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
            this.size = 0;
          }
          function hashDelete2(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet2(key) {
            var data2 = this.__data__;
            if (nativeCreate2) {
              var result2 = data2[key];
              return result2 === HASH_UNDEFINED2 ? undefined$12 : result2;
            }
            return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$12;
          }
          function hashHas2(key) {
            var data2 = this.__data__;
            return nativeCreate2 ? data2[key] !== undefined$12 : hasOwnProperty2.call(data2, key);
          }
          function hashSet2(key, value) {
            var data2 = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data2[key] = nativeCreate2 && value === undefined$12 ? HASH_UNDEFINED2 : value;
            return this;
          }
          Hash2.prototype.clear = hashClear2;
          Hash2.prototype["delete"] = hashDelete2;
          Hash2.prototype.get = hashGet2;
          Hash2.prototype.has = hashHas2;
          Hash2.prototype.set = hashSet2;
          function ListCache2(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear2() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete2(key) {
            var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data2.length - 1;
            if (index2 == lastIndex) {
              data2.pop();
            } else {
              splice2.call(data2, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet2(key) {
            var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
            return index2 < 0 ? undefined$12 : data2[index2][1];
          }
          function listCacheHas2(key) {
            return assocIndexOf2(this.__data__, key) > -1;
          }
          function listCacheSet2(key, value) {
            var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
            if (index2 < 0) {
              ++this.size;
              data2.push([key, value]);
            } else {
              data2[index2][1] = value;
            }
            return this;
          }
          ListCache2.prototype.clear = listCacheClear2;
          ListCache2.prototype["delete"] = listCacheDelete2;
          ListCache2.prototype.get = listCacheGet2;
          ListCache2.prototype.has = listCacheHas2;
          ListCache2.prototype.set = listCacheSet2;
          function MapCache2(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear2() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash2(),
              "map": new (Map2 || ListCache2)(),
              "string": new Hash2()
            };
          }
          function mapCacheDelete2(key) {
            var result2 = getMapData2(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet2(key) {
            return getMapData2(this, key).get(key);
          }
          function mapCacheHas2(key) {
            return getMapData2(this, key).has(key);
          }
          function mapCacheSet2(key, value) {
            var data2 = getMapData2(this, key), size3 = data2.size;
            data2.set(key, value);
            this.size += data2.size == size3 ? 0 : 1;
            return this;
          }
          MapCache2.prototype.clear = mapCacheClear2;
          MapCache2.prototype["delete"] = mapCacheDelete2;
          MapCache2.prototype.get = mapCacheGet2;
          MapCache2.prototype.has = mapCacheHas2;
          MapCache2.prototype.set = mapCacheSet2;
          function SetCache(values2) {
            var index2 = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache2();
            while (++index2 < length) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED2);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack2(entries) {
            var data2 = this.__data__ = new ListCache2(entries);
            this.size = data2.size;
          }
          function stackClear2() {
            this.__data__ = new ListCache2();
            this.size = 0;
          }
          function stackDelete2(key) {
            var data2 = this.__data__, result2 = data2["delete"](key);
            this.size = data2.size;
            return result2;
          }
          function stackGet2(key) {
            return this.__data__.get(key);
          }
          function stackHas2(key) {
            return this.__data__.has(key);
          }
          function stackSet2(key, value) {
            var data2 = this.__data__;
            if (data2 instanceof ListCache2) {
              var pairs = data2.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
                pairs.push([key, value]);
                this.size = ++data2.size;
                return this;
              }
              data2 = this.__data__ = new MapCache2(pairs);
            }
            data2.set(key, value);
            this.size = data2.size;
            return this;
          }
          Stack2.prototype.clear = stackClear2;
          Stack2.prototype["delete"] = stackDelete2;
          Stack2.prototype.get = stackGet2;
          Stack2.prototype.has = stackHas2;
          Stack2.prototype.set = stackSet2;
          function arrayLikeKeys2(value, inherited) {
            var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer3(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array2) {
            var length = array2.length;
            return length ? array2[baseRandom(0, length - 1)] : undefined$12;
          }
          function arraySampleSize(array2, n) {
            return shuffleSelf(copyArray2(array2), baseClamp(n, 0, array2.length));
          }
          function arrayShuffle(array2) {
            return shuffleSelf(copyArray2(array2));
          }
          function assignMergeValue2(object, key, value) {
            if (value !== undefined$12 && !eq2(object[key], value) || value === undefined$12 && !(key in object)) {
              baseAssignValue2(object, key, value);
            }
          }
          function assignValue2(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined$12 && !(key in object)) {
              baseAssignValue2(object, key, value);
            }
          }
          function assocIndexOf2(array2, key) {
            var length = array2.length;
            while (length--) {
              if (eq2(array2[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign2(object, source) {
            return object && copyObject2(source, keys2(source), object);
          }
          function baseAssignIn2(object, source) {
            return object && copyObject2(source, keysIn2(source), object);
          }
          function baseAssignValue2(object, key, value) {
            if (key == "__proto__" && defineProperty2) {
              defineProperty2(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index2 < length) {
              result2[index2] = skip ? undefined$12 : get2(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number2, lower, upper) {
            if (number2 === number2) {
              if (upper !== undefined$12) {
                number2 = number2 <= upper ? number2 : upper;
              }
              if (lower !== undefined$12) {
                number2 = number2 >= lower ? number2 : lower;
              }
            }
            return number2;
          }
          function baseClone2(value, bitmask, customizer, key, object, stack2) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack2) : customizer(value);
            }
            if (result2 !== undefined$12) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray2(value);
            if (isArr) {
              result2 = initCloneArray2(value);
              if (!isDeep) {
                return copyArray2(value, result2);
              }
            } else {
              var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
              if (isBuffer3(value)) {
                return cloneBuffer2(value, isDeep);
              }
              if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject2(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
                }
              } else {
                if (!cloneableTags2[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag2(value, tag, isDeep);
              }
            }
            stack2 || (stack2 = new Stack2());
            var stacked = stack2.get(value);
            if (stacked) {
              return stacked;
            }
            stack2.set(value, result2);
            if (isSet2(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack2));
              });
            } else if (isMap2(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack2));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
            var props = isArr ? undefined$12 : keysFunc(value);
            arrayEach2(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue2(result2, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack2));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined$12 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            return setTimeout2(function() {
              func.apply(undefined$12, args);
            }, wait);
          }
          function baseDifference(array2, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap2(values2, baseUnary2(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE2) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length) {
                var value = array2[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed2 === computed2) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed2) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed2, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array2, iteratee2, comparator) {
            var index2 = -1, length = array2.length;
            while (++index2 < length) {
              var value = array2[index2], current = iteratee2(value);
              if (current != null && (computed2 === undefined$12 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
                var computed2 = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array2, value, start, end) {
            var length = array2.length;
            start = toInteger2(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined$12 || end > length ? length : toInteger2(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array2[start++] = value;
            }
            return array2;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten2(array2, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array2.length;
            predicate || (predicate = isFlattenable2);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array2[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten2(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush2(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor2 = createBaseFor2();
          var baseForRight = createBaseFor2(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor2(object, iteratee2, keys2);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys2);
          }
          function baseFunctions(object, props) {
            return arrayFilter2(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet2(object, path) {
            path = castPath2(path, object);
            var index2 = 0, length = path.length;
            while (object != null && index2 < length) {
              object = object[toKey2(path[index2++])];
            }
            return index2 && index2 == length ? object : undefined$12;
          }
          function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
          }
          function baseGetTag2(value) {
            if (value == null) {
              return value === undefined$12 ? undefinedTag2 : nullTag2;
            }
            return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty2.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number2, start, end) {
            return number2 >= nativeMin2(start, end) && number2 < nativeMax2(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array2 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array2 = arrayMap2(array2, baseUnary2(iteratee2));
              }
              maxLength = nativeMin2(array2.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$12;
            }
            array2 = arrays[0];
            var index2 = -1, seen2 = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result2, computed2, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen2) {
                    seen2.push(computed2);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath2(path, object);
            object = parent2(object, path);
            var func = object == null ? object : object[toKey2(last(path))];
            return func == null ? undefined$12 : apply2(func, object, args);
          }
          function baseIsArguments2(value) {
            return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
          }
          function baseIsDate(value) {
            return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack2) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
            objTag = objTag == argsTag2 ? objectTag2 : objTag;
            othTag = othTag == argsTag2 ? objectTag2 : othTag;
            var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer3(object)) {
              if (!isBuffer3(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack2 || (stack2 = new Stack2());
              return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack2 || (stack2 = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack2 || (stack2 = new Stack2());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
          }
          function baseIsMap2(value) {
            return isObjectLike2(value) && getTag2(value) == mapTag2;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index2--) {
              var data2 = matchData[index2];
              if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data2 = matchData[index2];
              var key = data2[0], objValue = object[key], srcValue = data2[1];
              if (noCustomizer && data2[2]) {
                if (objValue === undefined$12 && !(key in object)) {
                  return false;
                }
              } else {
                var stack2 = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack2);
                }
                if (!(result2 === undefined$12 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative2(value) {
            if (!isObject2(value) || isMasked2(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
            return pattern.test(toSource2(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
          }
          function baseIsSet2(value) {
            return isObjectLike2(value) && getTag2(value) == setTag2;
          }
          function baseIsTypedArray2(value) {
            return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity2;
            }
            if (typeof value == "object") {
              return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys2(object) {
            if (!isPrototype2(object)) {
              return nativeKeys2(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty2.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn2(object) {
            if (!isObject2(object)) {
              return nativeKeysIn2(object);
            }
            var isProto = isPrototype2(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey2(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey2(path), srcValue);
            }
            return function(object) {
              var objValue = get2(object, path);
              return objValue === undefined$12 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge2(object, source, srcIndex, customizer, stack2) {
            if (object === source) {
              return;
            }
            baseFor2(source, function(srcValue, key) {
              stack2 || (stack2 = new Stack2());
              if (isObject2(srcValue)) {
                baseMergeDeep2(object, source, key, srcIndex, baseMerge2, customizer, stack2);
              } else {
                var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source, stack2) : undefined$12;
                if (newValue === undefined$12) {
                  newValue = srcValue;
                }
                assignMergeValue2(object, key, newValue);
              }
            }, keysIn2);
          }
          function baseMergeDeep2(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
            var objValue = safeGet2(object, key), srcValue = safeGet2(source, key), stacked = stack2.get(srcValue);
            if (stacked) {
              assignMergeValue2(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$12;
            var isCommon = newValue === undefined$12;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject2(objValue)) {
                  newValue = copyArray2(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer2(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray2(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
                newValue = objValue;
                if (isArguments2(objValue)) {
                  newValue = toPlainObject2(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject2(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack2.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
              stack2["delete"](srcValue);
            }
            assignMergeValue2(object, key, newValue);
          }
          function baseNth(array2, n) {
            var length = array2.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex2(n, length) ? array2[n] : undefined$12;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap2(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value) {
                    return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index2 = -1;
            iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap2(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick2(object, paths) {
            return basePickBy2(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy2(object, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path = paths[index2], value = baseGet2(object, path);
              if (predicate(value, path)) {
                baseSet2(result2, castPath2(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet2(object, path);
            };
          }
          function basePullAll(array2, values2, iteratee2, comparator) {
            var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen2 = array2;
            if (array2 === values2) {
              values2 = copyArray2(values2);
            }
            if (iteratee2) {
              seen2 = arrayMap2(array2, baseUnary2(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf3(seen2, computed2, fromIndex, comparator)) > -1) {
                if (seen2 !== array2) {
                  splice2.call(seen2, fromIndex, 1);
                }
                splice2.call(array2, fromIndex, 1);
              }
            }
            return array2;
          }
          function basePullAt(array2, indexes) {
            var length = array2 ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex2(index2)) {
                  splice2.call(array2, index2, 1);
                } else {
                  baseUnset(array2, index2);
                }
              }
            }
            return array2;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index2 = -1, length = nativeMax2(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string2, n) {
            var result2 = "";
            if (!string2 || n < 1 || n > MAX_SAFE_INTEGER2) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string2;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string2 += string2;
              }
            } while (n);
            return result2;
          }
          function baseRest2(func, start) {
            return setToString2(overRest2(func, start, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array2 = values(collection);
            return shuffleSelf(array2, baseClamp(n, 0, array2.length));
          }
          function baseSet2(object, path, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path = castPath2(path, object);
            var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index2 < length) {
              var key = toKey2(path[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined$12;
                if (newValue === undefined$12) {
                  newValue = isObject2(objValue) ? objValue : isIndex2(path[index2 + 1]) ? [] : {};
                }
              }
              assignValue2(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data2) {
            metaMap.set(func, data2);
            return func;
          };
          var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string2) {
            return defineProperty2(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant2(string2),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array2, start, end) {
            var index2 = -1, length = array2.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array2[index2 + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array2, value, retHighest) {
            var low = 0, high = array2 == null ? low : array2.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed2 = array2[mid];
                if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array2, value, identity2, retHighest);
          }
          function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
            var low = 0, high = array2 == null ? 0 : array2.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$12;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array2[mid]), othIsDefined = computed2 !== undefined$12, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed2 <= value : computed2 < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin2(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array2, iteratee2) {
            var index2 = -1, length = array2.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq2(computed2, seen2)) {
                var seen2 = computed2;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN2;
            }
            return +value;
          }
          function baseToString2(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray2(value)) {
              return arrayMap2(value, baseToString2) + "";
            }
            if (isSymbol2(value)) {
              return symbolToString2 ? symbolToString2.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
          }
          function baseUniq(array2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen2 = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE2) {
              var set3 = iteratee2 ? null : createSet(array2);
              if (set3) {
                return setToArray(set3);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen2 = new SetCache();
            } else {
              seen2 = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed2 === computed2) {
                  var seenIndex = seen2.length;
                  while (seenIndex--) {
                    if (seen2[seenIndex] === computed2) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen2.push(computed2);
                  }
                  result2.push(value);
                } else if (!includes2(seen2, computed2, comparator)) {
                  if (seen2 !== result2) {
                    seen2.push(computed2);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath2(path, object);
            object = parent2(object, path);
            return object == null || delete object[toKey2(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet2(object, path, updater(baseGet2(object, path)), customizer);
          }
          function baseWhile(array2, predicate, isDrop, fromRight) {
            var length = array2.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array2[index2], index2, array2)) {
            }
            return isDrop ? baseSlice(array2, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array2, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array2 = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array2, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten2(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values2[index2] : undefined$12;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject2(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity2;
          }
          function castPath2(value, object) {
            if (isArray2(value)) {
              return value;
            }
            return isKey2(value, object) ? [value] : stringToPath3(toString2(value));
          }
          var castRest = baseRest2;
          function castSlice(array2, start, end) {
            var length = array2.length;
            end = end === undefined$12 ? length : end;
            return !start && end >= length ? array2 : baseSlice(array2, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root2.clearTimeout(id);
          };
          function cloneBuffer2(buffer2, isDeep) {
            if (isDeep) {
              return buffer2.slice();
            }
            var length = buffer2.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer2.constructor(length);
            buffer2.copy(result2);
            return result2;
          }
          function cloneArrayBuffer2(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView2(dataView, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp2(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol2(symbol) {
            return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
          }
          function cloneTypedArray2(typedArray, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
              var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order = orders[index2];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset2 = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset2 + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray2(source, array2) {
            var index2 = -1, length = source.length;
            array2 || (array2 = Array2(length));
            while (++index2 < length) {
              array2[index2] = source[index2];
            }
            return array2;
          }
          function copyObject2(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$12;
              if (newValue === undefined$12) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue2(object, key, newValue);
              } else {
                assignValue2(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols2(source, object) {
            return copyObject2(source, getSymbols2(source), object);
          }
          function copySymbolsIn2(source, object) {
            return copyObject2(source, getSymbolsIn2(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner2(assigner) {
            return baseRest2(function(object, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
              if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined$12 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike2(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor2(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string2) {
              string2 = toString2(string2);
              var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$12;
              var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string2) {
              return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$12, args, holders, undefined$12, undefined$12, arity - length);
              }
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return apply2(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike2(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$12;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$12;
                if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                  wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray2(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined$12 && other === undefined$12) {
                return defaultValue;
              }
              if (value !== undefined$12) {
                result2 = value;
              }
              if (other !== undefined$12) {
                if (result2 === undefined$12) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString2(value);
                  other = baseToString2(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
              return baseRest2(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply2(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined$12 ? " " : baseToString2(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply2(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
                end = step = undefined$12;
              }
              start = toFinite2(start);
              if (end === undefined$12) {
                end = start;
                start = 0;
              } else {
                end = toFinite2(end);
              }
              step = step === undefined$12 ? start < end ? 1 : -1 : toFinite2(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber2(value);
                other = toNumber2(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined$12, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number2, precision) {
              number2 = toNumber2(number2);
              precision = precision == null ? 0 : nativeMin2(toInteger2(precision), 292);
              if (precision && nativeIsFinite(number2)) {
                var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number2);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag2(object);
              if (tag == mapTag2) {
                return mapToArray(object);
              }
              if (tag == setTag2) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined$12;
            }
            ary2 = ary2 === undefined$12 ? ary2 : nativeMax2(toInteger2(ary2), 0);
            arity = arity === undefined$12 ? arity : toInteger2(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined$12;
            }
            var data2 = isBindKey ? undefined$12 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data2) {
              mergeData(newData, data2);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined$12, newData);
            }
            var setter = data2 ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined$12 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack2.set(srcValue, objValue);
              baseMerge2(objValue, srcValue, undefined$12, customDefaultsMerge, stack2);
              stack2["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject2(value) ? undefined$12 : value;
          }
          function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack2.get(array2);
            var othStacked = stack2.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array2;
            }
            var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$12;
            stack2.set(array2, other);
            stack2.set(other, array2);
            while (++index2 < arrLength) {
              var arrValue = array2[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
              }
              if (compared !== undefined$12) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen2) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                    return seen2.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
                result2 = false;
                break;
              }
            }
            stack2["delete"](array2);
            stack2["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
            switch (tag) {
              case dataViewTag2:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag2:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag2:
              case dateTag2:
              case numberTag2:
                return eq2(+object, +other);
              case errorTag2:
                return object.name == other.name && object.message == other.message;
              case regexpTag2:
              case stringTag2:
                return object == other + "";
              case mapTag2:
                var convert = mapToArray;
              case setTag2:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack2.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack2.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
                stack2["delete"](object);
                return result2;
              case symbolTag2:
                if (symbolValueOf2) {
                  return symbolValueOf2.call(object) == symbolValueOf2.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack2.get(object);
            var othStacked = stack2.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack2.set(object, other);
            stack2.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
              }
              if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack2["delete"](object);
            stack2["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString2(overRest2(func, undefined$12, flatten), func + "");
          }
          function getAllKeys2(object) {
            return baseGetAllKeys2(object, keys2, getSymbols2);
          }
          function getAllKeysIn2(object) {
            return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
          }
          var getData = !metaMap ? noop2 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
            while (length--) {
              var data2 = array2[length], otherFunc = data2.func;
              if (otherFunc == null || otherFunc == func) {
                return data2.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash2.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData2(map2, key) {
            var data2 = map2.__data__;
            return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
          }
          function getMatchData(object) {
            var result2 = keys2(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative2(object, key) {
            var value = getValue2(object, key);
            return baseIsNative2(value) ? value : undefined$12;
          }
          function getRawTag2(value) {
            var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
            try {
              value[symToStringTag2] = undefined$12;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString2.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag2] = tag;
              } else {
                delete value[symToStringTag2];
              }
            }
            return result2;
          }
          var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
              return propertyIsEnumerable2.call(object, symbol);
            });
          };
          var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
            var result2 = [];
            while (object) {
              arrayPush2(result2, getSymbols2(object));
              object = getPrototype2(object);
            }
            return result2;
          };
          var getTag2 = baseGetTag2;
          if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
            getTag2 = function(value) {
              var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$12, ctorString = Ctor ? toSource2(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString2:
                    return dataViewTag2;
                  case mapCtorString2:
                    return mapTag2;
                  case promiseCtorString2:
                    return promiseTag2;
                  case setCtorString2:
                    return setTag2;
                  case weakMapCtorString2:
                    return weakMapTag2;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data2 = transforms[index2], size3 = data2.size;
              switch (data2.type) {
                case "drop":
                  start += size3;
                  break;
                case "dropRight":
                  end -= size3;
                  break;
                case "take":
                  end = nativeMin2(end, start + size3);
                  break;
                case "takeRight":
                  start = nativeMax2(start, end - size3);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match2 = source.match(reWrapDetails);
            return match2 ? match2[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath2(path, object);
            var index2 = -1, length = path.length, result2 = false;
            while (++index2 < length) {
              var key = toKey2(path[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
          }
          function initCloneArray2(array2) {
            var length = array2.length, result2 = new array2.constructor(length);
            if (length && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
              result2.index = array2.index;
              result2.input = array2.input;
            }
            return result2;
          }
          function initCloneObject2(object) {
            return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
          }
          function initCloneByTag2(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag2:
                return cloneArrayBuffer2(object);
              case boolTag2:
              case dateTag2:
                return new Ctor(+object);
              case dataViewTag2:
                return cloneDataView2(object, isDeep);
              case float32Tag2:
              case float64Tag2:
              case int8Tag2:
              case int16Tag2:
              case int32Tag2:
              case uint8Tag2:
              case uint8ClampedTag2:
              case uint16Tag2:
              case uint32Tag2:
                return cloneTypedArray2(object, isDeep);
              case mapTag2:
                return new Ctor();
              case numberTag2:
              case stringTag2:
                return new Ctor(object);
              case regexpTag2:
                return cloneRegExp2(object);
              case setTag2:
                return new Ctor();
              case symbolTag2:
                return cloneSymbol2(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable2(value) {
            return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
          }
          function isIndex2(value, length) {
            var type2 = typeof value;
            length = length == null ? MAX_SAFE_INTEGER2 : length;
            return !!length && (type2 == "number" || type2 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall2(value, index2, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type2 = typeof index2;
            if (type2 == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type2 == "string" && index2 in object) {
              return eq2(object[index2], value);
            }
            return false;
          }
          function isKey2(value, object) {
            if (isArray2(value)) {
              return false;
            }
            var type2 = typeof value;
            if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
              return true;
            }
            return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
          }
          function isKeyable2(value) {
            var type2 = typeof value;
            return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash2[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data2 = getData(other);
            return !!data2 && func === data2[0];
          }
          function isMasked2(func) {
            return !!maskSrcKey2 && maskSrcKey2 in func;
          }
          var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
          function isPrototype2(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined$12 || key in Object2(object));
            };
          }
          function memoizeCapped2(func) {
            var result2 = memoize2(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE2) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data2, source) {
            var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data2;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data2[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data2[3];
              data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data2[5];
              data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data2[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data2[8] = data2[8] == null ? source[8] : nativeMin2(data2[8], source[8]);
            }
            if (data2[9] == null) {
              data2[9] = source[9];
            }
            data2[0] = source[0];
            data2[1] = newBitmask;
            return data2;
          }
          function nativeKeysIn2(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString2(value) {
            return nativeObjectToString2.call(value);
          }
          function overRest2(func, start, transform22) {
            start = nativeMax2(start === undefined$12 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax2(args.length - start, 0), array2 = Array2(length);
              while (++index2 < length) {
                array2[index2] = args[start + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start + 1);
              while (++index2 < start) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start] = transform22(array2);
              return apply2(func, this, otherArgs);
            };
          }
          function parent2(object, path) {
            return path.length < 2 ? object : baseGet2(object, baseSlice(path, 0, -1));
          }
          function reorder(array2, indexes) {
            var arrLength = array2.length, length = nativeMin2(indexes.length, arrLength), oldArray = copyArray2(array2);
            while (length--) {
              var index2 = indexes[length];
              array2[length] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$12;
            }
            return array2;
          }
          function safeGet2(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut2(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString2 = shortOut2(baseSetToString2);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut2(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT2) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined$12, arguments);
            };
          }
          function shuffleSelf(array2, size3) {
            var index2 = -1, length = array2.length, lastIndex = length - 1;
            size3 = size3 === undefined$12 ? length : size3;
            while (++index2 < size3) {
              var rand = baseRandom(index2, lastIndex), value = array2[rand];
              array2[rand] = array2[index2];
              array2[index2] = value;
            }
            array2.length = size3;
            return array2;
          }
          var stringToPath3 = memoizeCapped2(function(string2) {
            var result2 = [];
            if (string2.charCodeAt(0) === 46) {
              result2.push("");
            }
            string2.replace(rePropName2, function(match2, number2, quote2, subString) {
              result2.push(quote2 ? subString.replace(reEscapeChar2, "$1") : number2 || match2);
            });
            return result2;
          });
          function toKey2(value) {
            if (typeof value == "string" || isSymbol2(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
          }
          function toSource2(func) {
            if (func != null) {
              try {
                return funcToString2.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach2(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray2(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array2, size3, guard) {
            if (guard ? isIterateeCall2(array2, size3, guard) : size3 === undefined$12) {
              size3 = 1;
            } else {
              size3 = nativeMax2(toInteger2(size3), 0);
            }
            var length = array2 == null ? 0 : array2.length;
            if (!length || size3 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array2, index2, index2 += size3);
            }
            return result2;
          }
          function compact3(array2) {
            var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array2[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat2() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array2 = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush2(isArray2(array2) ? copyArray2(array2) : [array2], baseFlatten2(args, 1));
          }
          var difference = baseRest2(function(array2, values2) {
            return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten2(values2, 1, isArrayLikeObject2, true)) : [];
          });
          var differenceBy = baseRest2(function(array2, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject2(iteratee2)) {
              iteratee2 = undefined$12;
            }
            return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten2(values2, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest2(function(array2, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject2(comparator)) {
              comparator = undefined$12;
            }
            return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten2(values2, 1, isArrayLikeObject2, true), undefined$12, comparator) : [];
          });
          function drop2(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined$12 ? 1 : toInteger2(n);
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function dropRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined$12 ? 1 : toInteger2(n);
            n = length - n;
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
          }
          function fill(array2, value, start, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall2(array2, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array2, value, start, end);
          }
          function findIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax2(length + index2, 0);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined$12) {
              index2 = toInteger2(fromIndex);
              index2 = fromIndex < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten2(array2, 1) : [];
          }
          function flattenDeep(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten2(array2, INFINITY2) : [];
          }
          function flattenDepth(array2, depth) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined$12 ? 1 : toInteger2(depth);
            return baseFlatten2(array2, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array2) {
            return array2 && array2.length ? array2[0] : undefined$12;
          }
          function indexOf2(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax2(length + index2, 0);
            }
            return baseIndexOf(array2, value, index2);
          }
          function initial(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 0, -1) : [];
          }
          var intersection = baseRest2(function(arrays) {
            var mapped = arrayMap2(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest2(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined$12;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest2(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined$12;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$12, comparator) : [];
          });
          function join(array2, separator) {
            return array2 == null ? "" : nativeJoin.call(array2, separator);
          }
          function last(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? array2[length - 1] : undefined$12;
          }
          function lastIndexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined$12) {
              index2 = toInteger2(fromIndex);
              index2 = index2 < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array2, value, index2) : baseFindIndex(array2, baseIsNaN, index2, true);
          }
          function nth(array2, n) {
            return array2 && array2.length ? baseNth(array2, toInteger2(n)) : undefined$12;
          }
          var pull = baseRest2(pullAll);
          function pullAll(array2, values2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
          }
          function pullAllBy(array2, values2, iteratee2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
          }
          function pullAllWith(array2, values2, comparator) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined$12, comparator) : array2;
          }
          var pullAt = flatRest(function(array2, indexes) {
            var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
            basePullAt(array2, arrayMap2(indexes, function(index2) {
              return isIndex2(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array2, predicate) {
            var result2 = [];
            if (!(array2 && array2.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array2.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array2[index2];
              if (predicate(value, index2, array2)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array2, indexes);
            return result2;
          }
          function reverse(array2) {
            return array2 == null ? array2 : nativeReverse.call(array2);
          }
          function slice2(array2, start, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall2(array2, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger2(start);
              end = end === undefined$12 ? length : toInteger2(end);
            }
            return baseSlice(array2, start, end);
          }
          function sortedIndex(array2, value) {
            return baseSortedIndex(array2, value);
          }
          function sortedIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index2 = baseSortedIndex(array2, value);
              if (index2 < length && eq2(array2[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array2, value) {
            return baseSortedIndex(array2, value, true);
          }
          function sortedLastIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index2 = baseSortedIndex(array2, value, true) - 1;
              if (eq2(array2[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array2) {
            return array2 && array2.length ? baseSortedUniq(array2) : [];
          }
          function sortedUniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 1, length) : [];
          }
          function take(array2, n, guard) {
            if (!(array2 && array2.length)) {
              return [];
            }
            n = guard || n === undefined$12 ? 1 : toInteger2(n);
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function takeRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined$12 ? 1 : toInteger2(n);
            n = length - n;
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest2(function(arrays) {
            return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
          });
          var unionBy = baseRest2(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject2(iteratee2)) {
              iteratee2 = undefined$12;
            }
            return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest2(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined$12;
            return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined$12, comparator);
          });
          function uniq(array2) {
            return array2 && array2.length ? baseUniq(array2) : [];
          }
          function uniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array2, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined$12;
            return array2 && array2.length ? baseUniq(array2, undefined$12, comparator) : [];
          }
          function unzip(array2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var length = 0;
            array2 = arrayFilter2(array2, function(group) {
              if (isArrayLikeObject2(group)) {
                length = nativeMax2(group.length, length);
                return true;
              }
            });
            return baseTimes2(length, function(index2) {
              return arrayMap2(array2, baseProperty(index2));
            });
          }
          function unzipWith(array2, iteratee2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var result2 = unzip(array2);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap2(result2, function(group) {
              return apply2(iteratee2, undefined$12, group);
            });
          }
          var without = baseRest2(function(array2, values2) {
            return isArrayLikeObject2(array2) ? baseDifference(array2, values2) : [];
          });
          var xor = baseRest2(function(arrays) {
            return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
          });
          var xorBy = baseRest2(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject2(iteratee2)) {
              iteratee2 = undefined$12;
            }
            return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest2(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined$12;
            return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$12, comparator);
          });
          var zip = baseRest2(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue2);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet2);
          }
          var zipWith = baseRest2(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash2(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined$12
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array2) {
              if (length && !array2.length) {
                array2.push(undefined$12);
              }
              return array2;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined$12) {
              this.__values__ = toArray2(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined$12 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent22 = this;
            while (parent22 instanceof baseLodash) {
              var clone22 = wrapperClone(parent22);
              clone22.__index__ = 0;
              clone22.__values__ = undefined$12;
              if (result2) {
                previous.__wrapped__ = clone22;
              } else {
                result2 = clone22;
              }
              var previous = clone22;
              parent22 = parent22.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined$12
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue2(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall2(collection, predicate, guard)) {
              predicate = undefined$12;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find2 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten2(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten2(map(collection, iteratee2), INFINITY2);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined$12 ? 1 : toInteger2(depth);
            return baseFlatten2(map(collection, iteratee2), depth);
          }
          function forEach2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach2 : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue2(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike2(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax2(length + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest2(function(collection, path, args) {
            var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue2(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap2 : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined$12 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall2(collection, n, guard) : n === undefined$12) {
              n = 1;
            } else {
              n = toInteger2(n);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size2(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike2(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag2(collection);
            if (tag == mapTag2 || tag == setTag2) {
              return collection.size;
            }
            return baseKeys2(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall2(collection, predicate, guard)) {
              predicate = undefined$12;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest2(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten2(iteratees, 1), []);
          });
          var now2 = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            n = toInteger2(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined$12 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n);
          }
          function before2(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            n = toInteger2(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined$12;
              }
              return result2;
            };
          }
          var bind3 = baseRest2(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind3));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest2(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined$12 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined$12 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce2(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            wait = toNumber2(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined$12;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now2();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined$12;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined$12;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined$12) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined$12;
            }
            function flush() {
              return timerId === undefined$12 ? result2 : trailingEdge(now2());
            }
            function debounced() {
              var time = now2(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined$12) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined$12) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest2(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest2(function(func, wait, args) {
            return baseDelay(func, toNumber2(wait) || 0, args);
          });
          function flip2(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize2(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize2.Cache || MapCache2)();
            return memoized;
          }
          memoize2.Cache = MapCache2;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before2(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest2(function(args) {
              var index2 = -1, length = nativeMin2(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply2(func, this, args);
            });
          });
          var partial = baseRest2(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
          });
          var partialRight = baseRest2(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            start = start === undefined$12 ? start : toInteger2(start);
            return baseRest2(func, start);
          }
          function spread2(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            start = start == null ? 0 : nativeMax2(toInteger2(start), 0);
            return baseRest2(function(args) {
              var array2 = args[start], otherArgs = castSlice(args, 0, start);
              if (array2) {
                arrayPush2(otherArgs, array2);
              }
              return apply2(func, this, otherArgs);
            });
          }
          function throttle2(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce2(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray2(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone2(value, CLONE_SYMBOLS_FLAG2);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$12;
            return baseClone2(value, CLONE_SYMBOLS_FLAG2, customizer);
          }
          function cloneDeep2(value) {
            return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$12;
            return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys2(source));
          }
          function eq2(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments2 = baseIsArguments2(function() {
            return arguments;
          }()) ? baseIsArguments2 : function(value) {
            return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike2(value) {
            return value != null && isLength2(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject2(value) {
            return isObjectLike2(value) && isArrayLike2(value);
          }
          function isBoolean2(value) {
            return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
          }
          var isBuffer3 = nativeIsBuffer2 || stubFalse2;
          var isDate2 = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
          function isElement2(value) {
            return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray2(value) || isArguments2(value))) {
              return !value.length;
            }
            var tag = getTag2(value);
            if (tag == mapTag2 || tag == setTag2) {
              return !value.size;
            }
            if (isPrototype2(value)) {
              return !baseKeys2(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty2.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$12;
            var result2 = customizer ? customizer(value, other) : undefined$12;
            return result2 === undefined$12 ? baseIsEqual(value, other, undefined$12, customizer) : !!result2;
          }
          function isError2(value) {
            if (!isObjectLike2(value)) {
              return false;
            }
            var tag = baseGetTag2(value);
            return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag2(value);
            return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger2(value);
          }
          function isLength2(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
          }
          function isObject2(value) {
            var type2 = typeof value;
            return value != null && (type2 == "object" || type2 == "function");
          }
          function isObjectLike2(value) {
            return value != null && typeof value == "object";
          }
          var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$12;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber2(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative2(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber2(value) {
            return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
          }
          function isPlainObject2(value) {
            if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
              return false;
            }
            var proto = getPrototype2(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
          }
          var isRegExp3 = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
          }
          var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
          function isString2(value) {
            return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
          }
          function isSymbol2(value) {
            return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
          }
          var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
          function isUndefined2(value) {
            return value === undefined$12;
          }
          function isWeakMap2(value) {
            return isObjectLike2(value) && getTag2(value) == weakMapTag2;
          }
          function isWeakSet2(value) {
            return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray2(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike2(value)) {
              return isString2(value) ? stringToArray(value) : copyArray2(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag2(value), func = tag == mapTag2 ? mapToArray : tag == setTag2 ? setToArray : values;
            return func(value);
          }
          function toFinite2(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber2(value);
            if (value === INFINITY2 || value === -INFINITY2) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER2;
            }
            return value === value ? value : 0;
          }
          function toInteger2(value) {
            var result2 = toFinite2(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber2(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN2;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = value.replace(reTrim2, "");
            var isBinary = reIsBinary2.test(value);
            return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
          }
          function toPlainObject2(value) {
            return copyObject2(value, keysIn2(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString2(value);
          }
          var assign2 = createAssigner2(function(object, source) {
            if (isPrototype2(source) || isArrayLike2(source)) {
              copyObject2(source, keys2(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                assignValue2(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner2(function(object, source) {
            copyObject2(source, keysIn2(source), object);
          });
          var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
            copyObject2(source, keysIn2(source), object, customizer);
          });
          var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
            copyObject2(source, keys2(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create2(prototype2, properties) {
            var result2 = baseCreate2(prototype2);
            return properties == null ? result2 : baseAssign2(result2, properties);
          }
          var defaults2 = baseRest2(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined$12;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn2(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined$12 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest2(function(args) {
            args.push(undefined$12, customDefaultsMerge);
            return apply2(mergeWith, undefined$12, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys2(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn2(object));
          }
          function get2(object, path, defaultValue) {
            var result2 = object == null ? undefined$12 : baseGet2(object, path);
            return result2 === undefined$12 ? defaultValue : result2;
          }
          function has2(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString2.call(value);
            }
            result2[value] = key;
          }, constant2(identity2));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString2.call(value);
            }
            if (hasOwnProperty2.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest2(baseInvoke);
          function keys2(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
          }
          function keysIn2(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue2(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue2(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge3 = createAssigner2(function(object, source, srcIndex) {
            baseMerge2(object, source, srcIndex);
          });
          var mergeWith = createAssigner2(function(object, source, srcIndex, customizer) {
            baseMerge2(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap2(paths, function(path) {
              path = castPath2(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject2(object, getAllKeysIn2(object), result2);
            if (isDeep) {
              result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick2 = flatRest(function(object, paths) {
            return object == null ? {} : basePick2(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap2(getAllKeysIn2(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy2(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath2(path, object);
            var index2 = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined$12;
            }
            while (++index2 < length) {
              var value = object == null ? undefined$12 : object[toKey2(path[index2])];
              if (value === undefined$12) {
                index2 = length;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set2(object, path, value) {
            return object == null ? object : baseSet2(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$12;
            return object == null ? object : baseSet2(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn2);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer3(object) || isTypedArray2(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach2 : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$12;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys2(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn2(object));
          }
          function clamp2(number2, lower, upper) {
            if (upper === undefined$12) {
              upper = lower;
              lower = undefined$12;
            }
            if (upper !== undefined$12) {
              upper = toNumber2(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined$12) {
              lower = toNumber2(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber2(number2), lower, upper);
          }
          function inRange(number2, start, end) {
            start = toFinite2(start);
            if (end === undefined$12) {
              end = start;
              start = 0;
            } else {
              end = toFinite2(end);
            }
            number2 = toNumber2(number2);
            return baseInRange(number2, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
              upper = floating = undefined$12;
            }
            if (floating === undefined$12) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined$12;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined$12;
              }
            }
            if (lower === undefined$12 && upper === undefined$12) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite2(lower);
              if (upper === undefined$12) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite2(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin2(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase2 = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize2(word) : word);
          });
          function capitalize2(string2) {
            return upperFirst(toString2(string2).toLowerCase());
          }
          function deburr(string2) {
            string2 = toString2(string2);
            return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith2(string2, target, position) {
            string2 = toString2(string2);
            target = baseToString2(target);
            var length = string2.length;
            position = position === undefined$12 ? length : baseClamp(toInteger2(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string2.slice(position, end) == target;
          }
          function escape2(string2) {
            string2 = toString2(string2);
            return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
          }
          function escapeRegExp(string2) {
            string2 = toString2(string2);
            return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar2, "\\$&") : string2;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string2, length, chars) {
            string2 = toString2(string2);
            length = toInteger2(length);
            var strLength = length ? stringSize(string2) : 0;
            if (!length || strLength >= length) {
              return string2;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string2, length, chars) {
            string2 = toString2(string2);
            length = toInteger2(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
          }
          function padStart(string2, length, chars) {
            string2 = toString2(string2);
            length = toInteger2(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
          }
          function parseInt2(string2, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string2).replace(reTrimStart2, ""), radix || 0);
          }
          function repeat2(string2, n, guard) {
            if (guard ? isIterateeCall2(string2, n, guard) : n === undefined$12) {
              n = 1;
            } else {
              n = toInteger2(n);
            }
            return baseRepeat(toString2(string2), n);
          }
          function replace2() {
            var args = arguments, string2 = toString2(args[0]);
            return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string2, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall2(string2, separator, limit)) {
              separator = limit = undefined$12;
            }
            limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string2 = toString2(string2);
            if (string2 && (typeof separator == "string" || separator != null && !isRegExp3(separator))) {
              separator = baseToString2(separator);
              if (!separator && hasUnicode(string2)) {
                return castSlice(stringToArray(string2), 0, limit);
              }
            }
            return string2.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string2, target, position) {
            string2 = toString2(string2);
            position = position == null ? 0 : baseClamp(toInteger2(position), 0, string2.length);
            target = baseToString2(target);
            return string2.slice(position, position + target.length) == target;
          }
          function template2(string2, options, guard) {
            var settings = lodash2.templateSettings;
            if (guard && isIterateeCall2(string2, options, guard)) {
              options = undefined$12;
            }
            string2 = toString2(string2);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string2.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset2 + match2.length;
              return match2;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$12, importsValues);
            });
            result2.source = source;
            if (isError2(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim2(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined$12)) {
              return string2.replace(reTrim2, "");
            }
            if (!string2 || !(chars = baseToString2(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined$12)) {
              return string2.replace(reTrimEnd, "");
            }
            if (!string2 || !(chars = baseToString2(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined$12)) {
              return string2.replace(reTrimStart2, "");
            }
            if (!string2 || !(chars = baseToString2(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string2, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger2(options.length) : length;
              omission = "omission" in options ? baseToString2(options.omission) : omission;
            }
            string2 = toString2(string2);
            var strLength = string2.length;
            if (hasUnicode(string2)) {
              var strSymbols = stringToArray(string2);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string2;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
            if (separator === undefined$12) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp3(separator)) {
              if (string2.slice(end).search(separator)) {
                var match2, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags2.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match2 = separator.exec(substring)) {
                  var newEnd = match2.index;
                }
                result2 = result2.slice(0, newEnd === undefined$12 ? end : newEnd);
              }
            } else if (string2.indexOf(baseToString2(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string2) {
            string2 = toString2(string2);
            return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string2, pattern, guard) {
            string2 = toString2(string2);
            pattern = guard ? undefined$12 : pattern;
            if (pattern === undefined$12) {
              return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
            }
            return string2.match(pattern) || [];
          }
          var attempt = baseRest2(function(func, args) {
            try {
              return apply2(func, undefined$12, args);
            } catch (e) {
              return isError2(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach2(methodNames, function(key) {
              key = toKey2(key);
              baseAssignValue2(object, key, bind3(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap2(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT2);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest2(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair = pairs[index2];
                if (apply2(pair[0], this, args)) {
                  return apply2(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone2(source, CLONE_DEEP_FLAG2));
          }
          function constant2(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity2(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
          }
          function matches2(source) {
            return baseMatches(baseClone2(source, CLONE_DEEP_FLAG2));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone2(srcValue, CLONE_DEEP_FLAG2));
          }
          var method = baseRest2(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest2(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach2(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush2([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop2() {
          }
          function nthArg(n) {
            n = toInteger2(n);
            return baseRest2(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap2);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey2(path) ? baseProperty(toKey2(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined$12 : baseGet2(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray2() {
            return [];
          }
          function stubFalse2() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger2(n);
            if (n < 1 || n > MAX_SAFE_INTEGER2) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin2(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes2(length, iteratee2);
            while (++index2 < n) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray2(value)) {
              return arrayMap2(value, toKey2);
            }
            return isSymbol2(value) ? [value] : copyArray2(stringToPath3(toString2(value)));
          }
          function uniqueId2(prefix2) {
            var id = ++idCounter;
            return toString2(prefix2) + id;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max2(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined$12;
          }
          function maxBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$12;
          }
          function mean(array2) {
            return baseMean(array2, identity2);
          }
          function meanBy(array2, iteratee2) {
            return baseMean(array2, getIteratee(iteratee2, 2));
          }
          function min2(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined$12;
          }
          function minBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$12;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round2 = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array2) {
            return array2 && array2.length ? baseSum(array2, identity2) : 0;
          }
          function sumBy(array2, iteratee2) {
            return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
          }
          lodash2.after = after;
          lodash2.ary = ary;
          lodash2.assign = assign2;
          lodash2.assignIn = assignIn;
          lodash2.assignInWith = assignInWith;
          lodash2.assignWith = assignWith;
          lodash2.at = at;
          lodash2.before = before2;
          lodash2.bind = bind3;
          lodash2.bindAll = bindAll;
          lodash2.bindKey = bindKey;
          lodash2.castArray = castArray;
          lodash2.chain = chain;
          lodash2.chunk = chunk;
          lodash2.compact = compact3;
          lodash2.concat = concat2;
          lodash2.cond = cond;
          lodash2.conforms = conforms;
          lodash2.constant = constant2;
          lodash2.countBy = countBy;
          lodash2.create = create2;
          lodash2.curry = curry;
          lodash2.curryRight = curryRight;
          lodash2.debounce = debounce2;
          lodash2.defaults = defaults2;
          lodash2.defaultsDeep = defaultsDeep;
          lodash2.defer = defer;
          lodash2.delay = delay;
          lodash2.difference = difference;
          lodash2.differenceBy = differenceBy;
          lodash2.differenceWith = differenceWith;
          lodash2.drop = drop2;
          lodash2.dropRight = dropRight;
          lodash2.dropRightWhile = dropRightWhile;
          lodash2.dropWhile = dropWhile;
          lodash2.fill = fill;
          lodash2.filter = filter;
          lodash2.flatMap = flatMap;
          lodash2.flatMapDeep = flatMapDeep;
          lodash2.flatMapDepth = flatMapDepth;
          lodash2.flatten = flatten;
          lodash2.flattenDeep = flattenDeep;
          lodash2.flattenDepth = flattenDepth;
          lodash2.flip = flip2;
          lodash2.flow = flow;
          lodash2.flowRight = flowRight;
          lodash2.fromPairs = fromPairs;
          lodash2.functions = functions;
          lodash2.functionsIn = functionsIn;
          lodash2.groupBy = groupBy;
          lodash2.initial = initial;
          lodash2.intersection = intersection;
          lodash2.intersectionBy = intersectionBy;
          lodash2.intersectionWith = intersectionWith;
          lodash2.invert = invert;
          lodash2.invertBy = invertBy;
          lodash2.invokeMap = invokeMap;
          lodash2.iteratee = iteratee;
          lodash2.keyBy = keyBy;
          lodash2.keys = keys2;
          lodash2.keysIn = keysIn2;
          lodash2.map = map;
          lodash2.mapKeys = mapKeys;
          lodash2.mapValues = mapValues;
          lodash2.matches = matches2;
          lodash2.matchesProperty = matchesProperty;
          lodash2.memoize = memoize2;
          lodash2.merge = merge3;
          lodash2.mergeWith = mergeWith;
          lodash2.method = method;
          lodash2.methodOf = methodOf;
          lodash2.mixin = mixin;
          lodash2.negate = negate;
          lodash2.nthArg = nthArg;
          lodash2.omit = omit;
          lodash2.omitBy = omitBy;
          lodash2.once = once2;
          lodash2.orderBy = orderBy;
          lodash2.over = over;
          lodash2.overArgs = overArgs;
          lodash2.overEvery = overEvery;
          lodash2.overSome = overSome;
          lodash2.partial = partial;
          lodash2.partialRight = partialRight;
          lodash2.partition = partition;
          lodash2.pick = pick2;
          lodash2.pickBy = pickBy;
          lodash2.property = property;
          lodash2.propertyOf = propertyOf;
          lodash2.pull = pull;
          lodash2.pullAll = pullAll;
          lodash2.pullAllBy = pullAllBy;
          lodash2.pullAllWith = pullAllWith;
          lodash2.pullAt = pullAt;
          lodash2.range = range;
          lodash2.rangeRight = rangeRight;
          lodash2.rearg = rearg;
          lodash2.reject = reject;
          lodash2.remove = remove2;
          lodash2.rest = rest;
          lodash2.reverse = reverse;
          lodash2.sampleSize = sampleSize;
          lodash2.set = set2;
          lodash2.setWith = setWith;
          lodash2.shuffle = shuffle;
          lodash2.slice = slice2;
          lodash2.sortBy = sortBy;
          lodash2.sortedUniq = sortedUniq;
          lodash2.sortedUniqBy = sortedUniqBy;
          lodash2.split = split;
          lodash2.spread = spread2;
          lodash2.tail = tail;
          lodash2.take = take;
          lodash2.takeRight = takeRight;
          lodash2.takeRightWhile = takeRightWhile;
          lodash2.takeWhile = takeWhile;
          lodash2.tap = tap;
          lodash2.throttle = throttle2;
          lodash2.thru = thru;
          lodash2.toArray = toArray2;
          lodash2.toPairs = toPairs;
          lodash2.toPairsIn = toPairsIn;
          lodash2.toPath = toPath;
          lodash2.toPlainObject = toPlainObject2;
          lodash2.transform = transform2;
          lodash2.unary = unary;
          lodash2.union = union;
          lodash2.unionBy = unionBy;
          lodash2.unionWith = unionWith;
          lodash2.uniq = uniq;
          lodash2.uniqBy = uniqBy;
          lodash2.uniqWith = uniqWith;
          lodash2.unset = unset;
          lodash2.unzip = unzip;
          lodash2.unzipWith = unzipWith;
          lodash2.update = update;
          lodash2.updateWith = updateWith;
          lodash2.values = values;
          lodash2.valuesIn = valuesIn;
          lodash2.without = without;
          lodash2.words = words;
          lodash2.wrap = wrap;
          lodash2.xor = xor;
          lodash2.xorBy = xorBy;
          lodash2.xorWith = xorWith;
          lodash2.zip = zip;
          lodash2.zipObject = zipObject;
          lodash2.zipObjectDeep = zipObjectDeep;
          lodash2.zipWith = zipWith;
          lodash2.entries = toPairs;
          lodash2.entriesIn = toPairsIn;
          lodash2.extend = assignIn;
          lodash2.extendWith = assignInWith;
          mixin(lodash2, lodash2);
          lodash2.add = add2;
          lodash2.attempt = attempt;
          lodash2.camelCase = camelCase2;
          lodash2.capitalize = capitalize2;
          lodash2.ceil = ceil;
          lodash2.clamp = clamp2;
          lodash2.clone = clone2;
          lodash2.cloneDeep = cloneDeep2;
          lodash2.cloneDeepWith = cloneDeepWith;
          lodash2.cloneWith = cloneWith;
          lodash2.conformsTo = conformsTo;
          lodash2.deburr = deburr;
          lodash2.defaultTo = defaultTo;
          lodash2.divide = divide;
          lodash2.endsWith = endsWith2;
          lodash2.eq = eq2;
          lodash2.escape = escape2;
          lodash2.escapeRegExp = escapeRegExp;
          lodash2.every = every;
          lodash2.find = find2;
          lodash2.findIndex = findIndex;
          lodash2.findKey = findKey;
          lodash2.findLast = findLast;
          lodash2.findLastIndex = findLastIndex;
          lodash2.findLastKey = findLastKey;
          lodash2.floor = floor;
          lodash2.forEach = forEach2;
          lodash2.forEachRight = forEachRight;
          lodash2.forIn = forIn;
          lodash2.forInRight = forInRight;
          lodash2.forOwn = forOwn;
          lodash2.forOwnRight = forOwnRight;
          lodash2.get = get2;
          lodash2.gt = gt;
          lodash2.gte = gte;
          lodash2.has = has2;
          lodash2.hasIn = hasIn;
          lodash2.head = head;
          lodash2.identity = identity2;
          lodash2.includes = includes;
          lodash2.indexOf = indexOf2;
          lodash2.inRange = inRange;
          lodash2.invoke = invoke;
          lodash2.isArguments = isArguments2;
          lodash2.isArray = isArray2;
          lodash2.isArrayBuffer = isArrayBuffer2;
          lodash2.isArrayLike = isArrayLike2;
          lodash2.isArrayLikeObject = isArrayLikeObject2;
          lodash2.isBoolean = isBoolean2;
          lodash2.isBuffer = isBuffer3;
          lodash2.isDate = isDate2;
          lodash2.isElement = isElement2;
          lodash2.isEmpty = isEmpty;
          lodash2.isEqual = isEqual;
          lodash2.isEqualWith = isEqualWith;
          lodash2.isError = isError2;
          lodash2.isFinite = isFinite2;
          lodash2.isFunction = isFunction2;
          lodash2.isInteger = isInteger;
          lodash2.isLength = isLength2;
          lodash2.isMap = isMap2;
          lodash2.isMatch = isMatch;
          lodash2.isMatchWith = isMatchWith;
          lodash2.isNaN = isNaN2;
          lodash2.isNative = isNative;
          lodash2.isNil = isNil;
          lodash2.isNull = isNull;
          lodash2.isNumber = isNumber2;
          lodash2.isObject = isObject2;
          lodash2.isObjectLike = isObjectLike2;
          lodash2.isPlainObject = isPlainObject2;
          lodash2.isRegExp = isRegExp3;
          lodash2.isSafeInteger = isSafeInteger;
          lodash2.isSet = isSet2;
          lodash2.isString = isString2;
          lodash2.isSymbol = isSymbol2;
          lodash2.isTypedArray = isTypedArray2;
          lodash2.isUndefined = isUndefined2;
          lodash2.isWeakMap = isWeakMap2;
          lodash2.isWeakSet = isWeakSet2;
          lodash2.join = join;
          lodash2.kebabCase = kebabCase;
          lodash2.last = last;
          lodash2.lastIndexOf = lastIndexOf;
          lodash2.lowerCase = lowerCase;
          lodash2.lowerFirst = lowerFirst;
          lodash2.lt = lt;
          lodash2.lte = lte;
          lodash2.max = max2;
          lodash2.maxBy = maxBy;
          lodash2.mean = mean;
          lodash2.meanBy = meanBy;
          lodash2.min = min2;
          lodash2.minBy = minBy;
          lodash2.stubArray = stubArray2;
          lodash2.stubFalse = stubFalse2;
          lodash2.stubObject = stubObject;
          lodash2.stubString = stubString;
          lodash2.stubTrue = stubTrue;
          lodash2.multiply = multiply;
          lodash2.nth = nth;
          lodash2.noConflict = noConflict;
          lodash2.noop = noop2;
          lodash2.now = now2;
          lodash2.pad = pad;
          lodash2.padEnd = padEnd;
          lodash2.padStart = padStart;
          lodash2.parseInt = parseInt2;
          lodash2.random = random;
          lodash2.reduce = reduce;
          lodash2.reduceRight = reduceRight;
          lodash2.repeat = repeat2;
          lodash2.replace = replace2;
          lodash2.result = result;
          lodash2.round = round2;
          lodash2.runInContext = runInContext2;
          lodash2.sample = sample;
          lodash2.size = size2;
          lodash2.snakeCase = snakeCase;
          lodash2.some = some;
          lodash2.sortedIndex = sortedIndex;
          lodash2.sortedIndexBy = sortedIndexBy;
          lodash2.sortedIndexOf = sortedIndexOf;
          lodash2.sortedLastIndex = sortedLastIndex;
          lodash2.sortedLastIndexBy = sortedLastIndexBy;
          lodash2.sortedLastIndexOf = sortedLastIndexOf;
          lodash2.startCase = startCase;
          lodash2.startsWith = startsWith;
          lodash2.subtract = subtract;
          lodash2.sum = sum;
          lodash2.sumBy = sumBy;
          lodash2.template = template2;
          lodash2.times = times;
          lodash2.toFinite = toFinite2;
          lodash2.toInteger = toInteger2;
          lodash2.toLength = toLength;
          lodash2.toLower = toLower;
          lodash2.toNumber = toNumber2;
          lodash2.toSafeInteger = toSafeInteger;
          lodash2.toString = toString2;
          lodash2.toUpper = toUpper;
          lodash2.trim = trim2;
          lodash2.trimEnd = trimEnd;
          lodash2.trimStart = trimStart;
          lodash2.truncate = truncate;
          lodash2.unescape = unescape2;
          lodash2.uniqueId = uniqueId2;
          lodash2.upperCase = upperCase;
          lodash2.upperFirst = upperFirst;
          lodash2.each = forEach2;
          lodash2.eachRight = forEachRight;
          lodash2.first = head;
          mixin(lodash2, function() {
            var source = {};
            baseForOwn(lodash2, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash2.VERSION = VERSION2;
          arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash2[methodName].placeholder = lodash2;
          });
          arrayEach2(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined$12 ? 1 : nativeMax2(toInteger2(n), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin2(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin2(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach2(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type2 = index2 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type2
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach2(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach2(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger2(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined$12) {
              end = toInteger2(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash2.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash2, arrayPush2([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash2.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray2(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray2(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash2[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined$12
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash2.prototype.at = wrapperAt;
          lodash2.prototype.chain = wrapperChain;
          lodash2.prototype.commit = wrapperCommit;
          lodash2.prototype.next = wrapperNext;
          lodash2.prototype.plant = wrapperPlant;
          lodash2.prototype.reverse = wrapperReverse;
          lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
          lodash2.prototype.first = lodash2.prototype.head;
          if (symIterator) {
            lodash2.prototype[symIterator] = wrapperToIterator;
          }
          return lodash2;
        };
        var _ = runInContext();
        if (freeModule2) {
          (freeModule2.exports = _)._ = _;
          freeExports2._ = _;
        } else {
          root2._ = _;
        }
      }).call(commonjsGlobal);
    })(lodash, lodash.exports);
    var screenfull$1 = { exports: {} };
    /*!
    * screenfull
    * v5.1.0 - 2020-12-24
    * (c) Sindre Sorhus; MIT License
    */
    (function(module2) {
      (function() {
        var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
        var isCommonjs = module2.exports;
        var fn = function() {
          var val;
          var fnMap = [
            [
              "requestFullscreen",
              "exitFullscreen",
              "fullscreenElement",
              "fullscreenEnabled",
              "fullscreenchange",
              "fullscreenerror"
            ],
            [
              "webkitRequestFullscreen",
              "webkitExitFullscreen",
              "webkitFullscreenElement",
              "webkitFullscreenEnabled",
              "webkitfullscreenchange",
              "webkitfullscreenerror"
            ],
            [
              "webkitRequestFullScreen",
              "webkitCancelFullScreen",
              "webkitCurrentFullScreenElement",
              "webkitCancelFullScreen",
              "webkitfullscreenchange",
              "webkitfullscreenerror"
            ],
            [
              "mozRequestFullScreen",
              "mozCancelFullScreen",
              "mozFullScreenElement",
              "mozFullScreenEnabled",
              "mozfullscreenchange",
              "mozfullscreenerror"
            ],
            [
              "msRequestFullscreen",
              "msExitFullscreen",
              "msFullscreenElement",
              "msFullscreenEnabled",
              "MSFullscreenChange",
              "MSFullscreenError"
            ]
          ];
          var i2 = 0;
          var l = fnMap.length;
          var ret = {};
          for (; i2 < l; i2++) {
            val = fnMap[i2];
            if (val && val[1] in document2) {
              for (i2 = 0; i2 < val.length; i2++) {
                ret[fnMap[0][i2]] = val[i2];
              }
              return ret;
            }
          }
          return false;
        }();
        var eventNameMap = {
          change: fn.fullscreenchange,
          error: fn.fullscreenerror
        };
        var screenfull2 = {
          request: function(element, options) {
            return new Promise(function(resolve2, reject) {
              var onFullScreenEntered = function() {
                this.off("change", onFullScreenEntered);
                resolve2();
              }.bind(this);
              this.on("change", onFullScreenEntered);
              element = element || document2.documentElement;
              var returnPromise = element[fn.requestFullscreen](options);
              if (returnPromise instanceof Promise) {
                returnPromise.then(onFullScreenEntered).catch(reject);
              }
            }.bind(this));
          },
          exit: function() {
            return new Promise(function(resolve2, reject) {
              if (!this.isFullscreen) {
                resolve2();
                return;
              }
              var onFullScreenExit = function() {
                this.off("change", onFullScreenExit);
                resolve2();
              }.bind(this);
              this.on("change", onFullScreenExit);
              var returnPromise = document2[fn.exitFullscreen]();
              if (returnPromise instanceof Promise) {
                returnPromise.then(onFullScreenExit).catch(reject);
              }
            }.bind(this));
          },
          toggle: function(element, options) {
            return this.isFullscreen ? this.exit() : this.request(element, options);
          },
          onchange: function(callback) {
            this.on("change", callback);
          },
          onerror: function(callback) {
            this.on("error", callback);
          },
          on: function(event, callback) {
            var eventName = eventNameMap[event];
            if (eventName) {
              document2.addEventListener(eventName, callback, false);
            }
          },
          off: function(event, callback) {
            var eventName = eventNameMap[event];
            if (eventName) {
              document2.removeEventListener(eventName, callback, false);
            }
          },
          raw: fn
        };
        if (!fn) {
          if (isCommonjs) {
            module2.exports = { isEnabled: false };
          } else {
            window.screenfull = { isEnabled: false };
          }
          return;
        }
        Object.defineProperties(screenfull2, {
          isFullscreen: {
            get: function() {
              return Boolean(document2[fn.fullscreenElement]);
            }
          },
          element: {
            enumerable: true,
            get: function() {
              return document2[fn.fullscreenElement];
            }
          },
          isEnabled: {
            enumerable: true,
            get: function() {
              return Boolean(document2[fn.fullscreenEnabled]);
            }
          }
        });
        if (isCommonjs) {
          module2.exports = screenfull2;
        } else {
          window.screenfull = screenfull2;
        }
      })();
    })(screenfull$1);
    screenfull$1.exports;
    function getTargetElement(target, defaultElement) {
      if (!target) {
        return defaultElement;
      }
      let targetElement;
      if (isRef$1(target)) {
        targetElement = unref$1(target);
      }
      if (typeof target === "function") {
        targetElement = target();
      }
      if (!targetElement) {
        console.error("target is not available!");
      }
      return targetElement;
    }
    function safeOnMounted(hook) {
      var _a;
      const instance = getCurrentInstance();
      if (((_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a._isMounted) || (instance == null ? void 0 : instance.isMounted) || instance._isMounted) {
        hook();
      } else {
        onMounted(hook);
      }
    }
    (function() {
      if (typeof window !== "object") {
        return;
      }
      if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
        if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
          Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
            get: function() {
              return this.intersectionRatio > 0;
            }
          });
        }
        return;
      }
      function getFrameElement(doc2) {
        try {
          return doc2.defaultView && doc2.defaultView.frameElement || null;
        } catch (e) {
          return null;
        }
      }
      var document2 = function(startDoc) {
        var doc2 = startDoc;
        var frame = getFrameElement(doc2);
        while (frame) {
          doc2 = frame.ownerDocument;
          frame = getFrameElement(doc2);
        }
        return doc2;
      }(window.document);
      var registry = [];
      var crossOriginUpdater = null;
      var crossOriginRect = null;
      function IntersectionObserverEntry(entry) {
        this.time = entry.time;
        this.target = entry.target;
        this.rootBounds = ensureDOMRect(entry.rootBounds);
        this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
        this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
        this.isIntersecting = !!entry.intersectionRect;
        var targetRect = this.boundingClientRect;
        var targetArea = targetRect.width * targetRect.height;
        var intersectionRect = this.intersectionRect;
        var intersectionArea = intersectionRect.width * intersectionRect.height;
        if (targetArea) {
          this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
        } else {
          this.intersectionRatio = this.isIntersecting ? 1 : 0;
        }
      }
      function IntersectionObserver2(callback, opt_options) {
        var options = opt_options || {};
        if (typeof callback != "function") {
          throw new Error("callback must be a function");
        }
        if (options.root && options.root.nodeType != 1 && options.root.nodeType != 9) {
          throw new Error("root must be a Document or Element");
        }
        this._checkForIntersections = throttle2(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
        this._callback = callback;
        this._observationTargets = [];
        this._queuedEntries = [];
        this._rootMarginValues = this._parseRootMargin(options.rootMargin);
        this.thresholds = this._initThresholds(options.threshold);
        this.root = options.root || null;
        this.rootMargin = this._rootMarginValues.map(function(margin) {
          return margin.value + margin.unit;
        }).join(" ");
        this._monitoringDocuments = [];
        this._monitoringUnsubscribes = [];
      }
      IntersectionObserver2.prototype.THROTTLE_TIMEOUT = 100;
      IntersectionObserver2.prototype.POLL_INTERVAL = null;
      IntersectionObserver2.prototype.USE_MUTATION_OBSERVER = true;
      IntersectionObserver2._setupCrossOriginUpdater = function() {
        if (!crossOriginUpdater) {
          crossOriginUpdater = function(boundingClientRect, intersectionRect) {
            if (!boundingClientRect || !intersectionRect) {
              crossOriginRect = getEmptyRect();
            } else {
              crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
            }
            registry.forEach(function(observer) {
              observer._checkForIntersections();
            });
          };
        }
        return crossOriginUpdater;
      };
      IntersectionObserver2._resetCrossOriginUpdater = function() {
        crossOriginUpdater = null;
        crossOriginRect = null;
      };
      IntersectionObserver2.prototype.observe = function(target) {
        var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
          return item.element == target;
        });
        if (isTargetAlreadyObserved) {
          return;
        }
        if (!(target && target.nodeType == 1)) {
          throw new Error("target must be an Element");
        }
        this._registerInstance();
        this._observationTargets.push({ element: target, entry: null });
        this._monitorIntersections(target.ownerDocument);
        this._checkForIntersections();
      };
      IntersectionObserver2.prototype.unobserve = function(target) {
        this._observationTargets = this._observationTargets.filter(function(item) {
          return item.element != target;
        });
        this._unmonitorIntersections(target.ownerDocument);
        if (this._observationTargets.length == 0) {
          this._unregisterInstance();
        }
      };
      IntersectionObserver2.prototype.disconnect = function() {
        this._observationTargets = [];
        this._unmonitorAllIntersections();
        this._unregisterInstance();
      };
      IntersectionObserver2.prototype.takeRecords = function() {
        var records = this._queuedEntries.slice();
        this._queuedEntries = [];
        return records;
      };
      IntersectionObserver2.prototype._initThresholds = function(opt_threshold) {
        var threshold = opt_threshold || [0];
        if (!Array.isArray(threshold))
          threshold = [threshold];
        return threshold.sort().filter(function(t, i2, a) {
          if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
            throw new Error("threshold must be a number between 0 and 1 inclusively");
          }
          return t !== a[i2 - 1];
        });
      };
      IntersectionObserver2.prototype._parseRootMargin = function(opt_rootMargin) {
        var marginString = opt_rootMargin || "0px";
        var margins = marginString.split(/\s+/).map(function(margin) {
          var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
          if (!parts) {
            throw new Error("rootMargin must be specified in pixels or percent");
          }
          return { value: parseFloat(parts[1]), unit: parts[2] };
        });
        margins[1] = margins[1] || margins[0];
        margins[2] = margins[2] || margins[0];
        margins[3] = margins[3] || margins[1];
        return margins;
      };
      IntersectionObserver2.prototype._monitorIntersections = function(doc2) {
        var win = doc2.defaultView;
        if (!win) {
          return;
        }
        if (this._monitoringDocuments.indexOf(doc2) != -1) {
          return;
        }
        var callback = this._checkForIntersections;
        var monitoringInterval = null;
        var domObserver = null;
        if (this.POLL_INTERVAL) {
          monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
        } else {
          addEvent(win, "resize", callback, true);
          addEvent(doc2, "scroll", callback, true);
          if (this.USE_MUTATION_OBSERVER && "MutationObserver" in win) {
            domObserver = new win.MutationObserver(callback);
            domObserver.observe(doc2, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          }
        }
        this._monitoringDocuments.push(doc2);
        this._monitoringUnsubscribes.push(function() {
          var win2 = doc2.defaultView;
          if (win2) {
            if (monitoringInterval) {
              win2.clearInterval(monitoringInterval);
            }
            removeEvent(win2, "resize", callback, true);
          }
          removeEvent(doc2, "scroll", callback, true);
          if (domObserver) {
            domObserver.disconnect();
          }
        });
        var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
        if (doc2 != rootDoc) {
          var frame = getFrameElement(doc2);
          if (frame) {
            this._monitorIntersections(frame.ownerDocument);
          }
        }
      };
      IntersectionObserver2.prototype._unmonitorIntersections = function(doc2) {
        var index2 = this._monitoringDocuments.indexOf(doc2);
        if (index2 == -1) {
          return;
        }
        var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
        var hasDependentTargets = this._observationTargets.some(function(item) {
          var itemDoc = item.element.ownerDocument;
          if (itemDoc == doc2) {
            return true;
          }
          while (itemDoc && itemDoc != rootDoc) {
            var frame2 = getFrameElement(itemDoc);
            itemDoc = frame2 && frame2.ownerDocument;
            if (itemDoc == doc2) {
              return true;
            }
          }
          return false;
        });
        if (hasDependentTargets) {
          return;
        }
        var unsubscribe = this._monitoringUnsubscribes[index2];
        this._monitoringDocuments.splice(index2, 1);
        this._monitoringUnsubscribes.splice(index2, 1);
        unsubscribe();
        if (doc2 != rootDoc) {
          var frame = getFrameElement(doc2);
          if (frame) {
            this._unmonitorIntersections(frame.ownerDocument);
          }
        }
      };
      IntersectionObserver2.prototype._unmonitorAllIntersections = function() {
        var unsubscribes = this._monitoringUnsubscribes.slice(0);
        this._monitoringDocuments.length = 0;
        this._monitoringUnsubscribes.length = 0;
        for (var i2 = 0; i2 < unsubscribes.length; i2++) {
          unsubscribes[i2]();
        }
      };
      IntersectionObserver2.prototype._checkForIntersections = function() {
        if (!this.root && crossOriginUpdater && !crossOriginRect) {
          return;
        }
        var rootIsInDom = this._rootIsInDom();
        var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
        this._observationTargets.forEach(function(item) {
          var target = item.element;
          var targetRect = getBoundingClientRect2(target);
          var rootContainsTarget = this._rootContainsTarget(target);
          var oldEntry = item.entry;
          var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);
          var rootBounds = null;
          if (!this._rootContainsTarget(target)) {
            rootBounds = getEmptyRect();
          } else if (!crossOriginUpdater || this.root) {
            rootBounds = rootRect;
          }
          var newEntry = item.entry = new IntersectionObserverEntry({
            time: now2(),
            target,
            boundingClientRect: targetRect,
            rootBounds,
            intersectionRect
          });
          if (!oldEntry) {
            this._queuedEntries.push(newEntry);
          } else if (rootIsInDom && rootContainsTarget) {
            if (this._hasCrossedThreshold(oldEntry, newEntry)) {
              this._queuedEntries.push(newEntry);
            }
          } else {
            if (oldEntry && oldEntry.isIntersecting) {
              this._queuedEntries.push(newEntry);
            }
          }
        }, this);
        if (this._queuedEntries.length) {
          this._callback(this.takeRecords(), this);
        }
      };
      IntersectionObserver2.prototype._computeTargetAndRootIntersection = function(target, targetRect, rootRect) {
        if (window.getComputedStyle(target).display == "none")
          return;
        var intersectionRect = targetRect;
        var parent2 = getParentNode2(target);
        var atRoot = false;
        while (!atRoot && parent2) {
          var parentRect = null;
          var parentComputedStyle = parent2.nodeType == 1 ? window.getComputedStyle(parent2) : {};
          if (parentComputedStyle.display == "none")
            return null;
          if (parent2 == this.root || parent2.nodeType == 9) {
            atRoot = true;
            if (parent2 == this.root || parent2 == document2) {
              if (crossOriginUpdater && !this.root) {
                if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
                  parent2 = null;
                  parentRect = null;
                  intersectionRect = null;
                } else {
                  parentRect = crossOriginRect;
                }
              } else {
                parentRect = rootRect;
              }
            } else {
              var frame = getParentNode2(parent2);
              var frameRect = frame && getBoundingClientRect2(frame);
              var frameIntersect = frame && this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
              if (frameRect && frameIntersect) {
                parent2 = frame;
                parentRect = convertFromParentRect(frameRect, frameIntersect);
              } else {
                parent2 = null;
                intersectionRect = null;
              }
            }
          } else {
            var doc2 = parent2.ownerDocument;
            if (parent2 != doc2.body && parent2 != doc2.documentElement && parentComputedStyle.overflow != "visible") {
              parentRect = getBoundingClientRect2(parent2);
            }
          }
          if (parentRect) {
            intersectionRect = computeRectIntersection(parentRect, intersectionRect);
          }
          if (!intersectionRect)
            break;
          parent2 = parent2 && getParentNode2(parent2);
        }
        return intersectionRect;
      };
      IntersectionObserver2.prototype._getRootRect = function() {
        var rootRect;
        if (this.root && !isDoc(this.root)) {
          rootRect = getBoundingClientRect2(this.root);
        } else {
          var doc2 = isDoc(this.root) ? this.root : document2;
          var html = doc2.documentElement;
          var body = doc2.body;
          rootRect = {
            top: 0,
            left: 0,
            right: html.clientWidth || body.clientWidth,
            width: html.clientWidth || body.clientWidth,
            bottom: html.clientHeight || body.clientHeight,
            height: html.clientHeight || body.clientHeight
          };
        }
        return this._expandRectByRootMargin(rootRect);
      };
      IntersectionObserver2.prototype._expandRectByRootMargin = function(rect) {
        var margins = this._rootMarginValues.map(function(margin, i2) {
          return margin.unit == "px" ? margin.value : margin.value * (i2 % 2 ? rect.width : rect.height) / 100;
        });
        var newRect = {
          top: rect.top - margins[0],
          right: rect.right + margins[1],
          bottom: rect.bottom + margins[2],
          left: rect.left - margins[3]
        };
        newRect.width = newRect.right - newRect.left;
        newRect.height = newRect.bottom - newRect.top;
        return newRect;
      };
      IntersectionObserver2.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
        var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
        var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
        if (oldRatio === newRatio)
          return;
        for (var i2 = 0; i2 < this.thresholds.length; i2++) {
          var threshold = this.thresholds[i2];
          if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
            return true;
          }
        }
      };
      IntersectionObserver2.prototype._rootIsInDom = function() {
        return !this.root || containsDeep(document2, this.root);
      };
      IntersectionObserver2.prototype._rootContainsTarget = function(target) {
        var rootDoc = this.root && (this.root.ownerDocument || this.root) || document2;
        return containsDeep(rootDoc, target) && (!this.root || rootDoc == target.ownerDocument);
      };
      IntersectionObserver2.prototype._registerInstance = function() {
        if (registry.indexOf(this) < 0) {
          registry.push(this);
        }
      };
      IntersectionObserver2.prototype._unregisterInstance = function() {
        var index2 = registry.indexOf(this);
        if (index2 != -1)
          registry.splice(index2, 1);
      };
      function now2() {
        return window.performance && performance.now && performance.now();
      }
      function throttle2(fn, timeout) {
        var timer = null;
        return function() {
          if (!timer) {
            timer = setTimeout(function() {
              fn();
              timer = null;
            }, timeout);
          }
        };
      }
      function addEvent(node, event, fn, opt_useCapture) {
        if (typeof node.addEventListener == "function") {
          node.addEventListener(event, fn, opt_useCapture || false);
        } else if (typeof node.attachEvent == "function") {
          node.attachEvent("on" + event, fn);
        }
      }
      function removeEvent(node, event, fn, opt_useCapture) {
        if (typeof node.removeEventListener == "function") {
          node.removeEventListener(event, fn, opt_useCapture || false);
        } else if (typeof node.detatchEvent == "function") {
          node.detatchEvent("on" + event, fn);
        }
      }
      function computeRectIntersection(rect1, rect2) {
        var top = Math.max(rect1.top, rect2.top);
        var bottom = Math.min(rect1.bottom, rect2.bottom);
        var left = Math.max(rect1.left, rect2.left);
        var right = Math.min(rect1.right, rect2.right);
        var width = right - left;
        var height = bottom - top;
        return width >= 0 && height >= 0 && {
          top,
          bottom,
          left,
          right,
          width,
          height
        } || null;
      }
      function getBoundingClientRect2(el) {
        var rect;
        try {
          rect = el.getBoundingClientRect();
        } catch (err) {
        }
        if (!rect)
          return getEmptyRect();
        if (!(rect.width && rect.height)) {
          rect = {
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            left: rect.left,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
          };
        }
        return rect;
      }
      function getEmptyRect() {
        return {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
      function ensureDOMRect(rect) {
        if (!rect || "x" in rect) {
          return rect;
        }
        return {
          top: rect.top,
          y: rect.top,
          bottom: rect.bottom,
          left: rect.left,
          x: rect.left,
          right: rect.right,
          width: rect.width,
          height: rect.height
        };
      }
      function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
        var top = parentIntersectionRect.top - parentBoundingRect.top;
        var left = parentIntersectionRect.left - parentBoundingRect.left;
        return {
          top,
          left,
          height: parentIntersectionRect.height,
          width: parentIntersectionRect.width,
          bottom: top + parentIntersectionRect.height,
          right: left + parentIntersectionRect.width
        };
      }
      function containsDeep(parent2, child) {
        var node = child;
        while (node) {
          if (node == parent2)
            return true;
          node = getParentNode2(node);
        }
        return false;
      }
      function getParentNode2(node) {
        var parent2 = node.parentNode;
        if (node.nodeType == 9 && node != document2) {
          return getFrameElement(node);
        }
        if (parent2 && parent2.assignedSlot) {
          parent2 = parent2.assignedSlot.parentNode;
        }
        if (parent2 && parent2.nodeType == 11 && parent2.host) {
          return parent2.host;
        }
        return parent2;
      }
      function isDoc(node) {
        return node && node.nodeType === 9;
      }
      window.IntersectionObserver = IntersectionObserver2;
      window.IntersectionObserverEntry = IntersectionObserverEntry;
    })();
    const aliasKeyCodeMap = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      up: 38,
      left: 37,
      right: 39,
      down: 40,
      delete: [8, 46]
    };
    const aliasKeyMap = {
      esc: "Escape",
      tab: "Tab",
      enter: "Enter",
      space: " ",
      up: ["Up", "ArrowUp"],
      left: ["Left", "ArrowLeft"],
      right: ["Right", "ArrowRight"],
      down: ["Down", "ArrowDown"],
      delete: ["Backspace", "Delete"]
    };
    const modifierKey = {
      ctrl: (event) => event.ctrlKey,
      shift: (event) => event.shiftKey,
      alt: (event) => event.altKey,
      meta: (event) => event.metaKey
    };
    const noop$3 = () => {
    };
    function isType(obj) {
      return Object.prototype.toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
    }
    function genFilterKey(event, keyFilter) {
      const type2 = isType(keyFilter);
      if (type2 === "number") {
        return event.keyCode === keyFilter;
      }
      const genArr = keyFilter.split(".");
      let genLen = 0;
      for (const key of genArr) {
        const genModifier = modifierKey[key];
        const aliasKey = aliasKeyMap[key];
        const aliasKeyCode = aliasKeyCodeMap[key];
        if (genModifier && genModifier(event) || (aliasKey && isType(aliasKey) === "array" ? aliasKey.includes(event.key) : aliasKey === event.key) || (aliasKeyCode && isType(aliasKeyCode) === "array" ? aliasKeyCode.includes(event.keyCode) : aliasKeyCode === event.keyCode) || event.key.toUpperCase() === key.toUpperCase()) {
          genLen++;
        }
      }
      return genLen === genArr.length;
    }
    function genKeyFormater(keyFilter) {
      const type2 = isType(keyFilter);
      if (type2 === "function") {
        return keyFilter;
      }
      if (type2 === "string" || type2 === "number") {
        return (event) => genFilterKey(event, keyFilter);
      }
      if (type2 === "array") {
        return (event) => keyFilter.some((item) => genFilterKey(event, item));
      }
      return keyFilter ? () => true : () => false;
    }
    const defaultEvents = ["keydown"];
    function useKeyPress(keyFilter, eventHandler = noop$3, option = {}) {
      const { events = defaultEvents, target } = option;
      const isKeyEvent = genKeyFormater(keyFilter);
      safeOnMounted(() => {
        const handlers = [];
        const el = getTargetElement(target, window);
        for (const eventName of events) {
          const handler = (event) => {
            if (isKeyEvent(event)) {
              return eventHandler(event);
            }
          };
          handlers.push(handler);
          el.addEventListener(eventName, handler);
        }
        onUnmounted(() => {
          for (const eventName of events) {
            const handler = handlers.shift();
            el.removeEventListener(eventName, handler);
          }
        });
      });
    }
    var localforage$1 = { exports: {} };
    /*!
        localForage -- Offline Storage, Improved
        Version 1.9.0
        https://localforage.github.io/localForage
        (c) 2013-2017 Mozilla, Apache License 2.0
    */
    (function(module2, exports2) {
      (function(f) {
        {
          module2.exports = f();
        }
      })(function() {
        return function e(t, n, r) {
          function s(o2, u) {
            if (!n[o2]) {
              if (!t[o2]) {
                var a = typeof commonjsRequire == "function" && commonjsRequire;
                if (!u && a)
                  return a(o2, true);
                if (i2)
                  return i2(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n[o2] = { exports: {} };
              t[o2][0].call(l.exports, function(e2) {
                var n2 = t[o2][1][e2];
                return s(n2 ? n2 : e2);
              }, l, l.exports, e, t, n, r);
            }
            return n[o2].exports;
          }
          var i2 = typeof commonjsRequire == "function" && commonjsRequire;
          for (var o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        }({ 1: [function(_dereq_, module22, exports22) {
          (function(global2) {
            var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick2);
                var element = global2.document.createTextNode("");
                observer.observe(element, {
                  characterData: true
                });
                scheduleDrain = function() {
                  element.data = called = ++called % 2;
                };
              } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                var channel = new global2.MessageChannel();
                channel.port1.onmessage = nextTick2;
                scheduleDrain = function() {
                  channel.port2.postMessage(0);
                };
              } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                scheduleDrain = function() {
                  var scriptEl = global2.document.createElement("script");
                  scriptEl.onreadystatechange = function() {
                    nextTick2();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global2.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function() {
                  setTimeout(nextTick2, 0);
                };
              }
            }
            var draining;
            var queue2 = [];
            function nextTick2() {
              draining = true;
              var i2, oldQueue;
              var len = queue2.length;
              while (len) {
                oldQueue = queue2;
                queue2 = [];
                i2 = -1;
                while (++i2 < len) {
                  oldQueue[i2]();
                }
                len = queue2.length;
              }
              draining = false;
            }
            module22.exports = immediate;
            function immediate(task) {
              if (queue2.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 2: [function(_dereq_, module22, exports22) {
          var immediate = _dereq_(1);
          function INTERNAL() {
          }
          var handlers = {};
          var REJECTED = ["REJECTED"];
          var FULFILLED = ["FULFILLED"];
          var PENDING = ["PENDING"];
          module22.exports = Promise2;
          function Promise2(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError("resolver must be a function");
            }
            this.state = PENDING;
            this.queue = [];
            this.outcome = void 0;
            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver);
            }
          }
          Promise2.prototype["catch"] = function(onRejected) {
            return this.then(null, onRejected);
          };
          Promise2.prototype.then = function(onFulfilled, onRejected) {
            if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
              return this;
            }
            var promise = new this.constructor(INTERNAL);
            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
              unwrap(promise, resolver, this.outcome);
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
            }
            return promise;
          };
          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise;
            if (typeof onFulfilled === "function") {
              this.onFulfilled = onFulfilled;
              this.callFulfilled = this.otherCallFulfilled;
            }
            if (typeof onRejected === "function") {
              this.onRejected = onRejected;
              this.callRejected = this.otherCallRejected;
            }
          }
          QueueItem.prototype.callFulfilled = function(value) {
            handlers.resolve(this.promise, value);
          };
          QueueItem.prototype.otherCallFulfilled = function(value) {
            unwrap(this.promise, this.onFulfilled, value);
          };
          QueueItem.prototype.callRejected = function(value) {
            handlers.reject(this.promise, value);
          };
          QueueItem.prototype.otherCallRejected = function(value) {
            unwrap(this.promise, this.onRejected, value);
          };
          function unwrap(promise, func, value) {
            immediate(function() {
              var returnValue;
              try {
                returnValue = func(value);
              } catch (e) {
                return handlers.reject(promise, e);
              }
              if (returnValue === promise) {
                handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
              } else {
                handlers.resolve(promise, returnValue);
              }
            });
          }
          handlers.resolve = function(self2, value) {
            var result = tryCatch(getThen, value);
            if (result.status === "error") {
              return handlers.reject(self2, result.value);
            }
            var thenable = result.value;
            if (thenable) {
              safelyResolveThenable(self2, thenable);
            } else {
              self2.state = FULFILLED;
              self2.outcome = value;
              var i2 = -1;
              var len = self2.queue.length;
              while (++i2 < len) {
                self2.queue[i2].callFulfilled(value);
              }
            }
            return self2;
          };
          handlers.reject = function(self2, error) {
            self2.state = REJECTED;
            self2.outcome = error;
            var i2 = -1;
            var len = self2.queue.length;
            while (++i2 < len) {
              self2.queue[i2].callRejected(error);
            }
            return self2;
          };
          function getThen(obj) {
            var then = obj && obj.then;
            if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
              return function appyThen() {
                then.apply(obj, arguments);
              };
            }
          }
          function safelyResolveThenable(self2, thenable) {
            var called = false;
            function onError(value) {
              if (called) {
                return;
              }
              called = true;
              handlers.reject(self2, value);
            }
            function onSuccess(value) {
              if (called) {
                return;
              }
              called = true;
              handlers.resolve(self2, value);
            }
            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }
            var result = tryCatch(tryToUnwrap);
            if (result.status === "error") {
              onError(result.value);
            }
          }
          function tryCatch(func, value) {
            var out = {};
            try {
              out.value = func(value);
              out.status = "success";
            } catch (e) {
              out.status = "error";
              out.value = e;
            }
            return out;
          }
          Promise2.resolve = resolve2;
          function resolve2(value) {
            if (value instanceof this) {
              return value;
            }
            return handlers.resolve(new this(INTERNAL), value);
          }
          Promise2.reject = reject;
          function reject(reason) {
            var promise = new this(INTERNAL);
            return handlers.reject(promise, reason);
          }
          Promise2.all = all;
          function all(iterable) {
            var self2 = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var values = new Array(len);
            var resolved = 0;
            var i2 = -1;
            var promise = new this(INTERNAL);
            while (++i2 < len) {
              allResolver(iterable[i2], i2);
            }
            return promise;
            function allResolver(value, i22) {
              self2.resolve(value).then(resolveFromAll, function(error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
              function resolveFromAll(outValue) {
                values[i22] = outValue;
                if (++resolved === len && !called) {
                  called = true;
                  handlers.resolve(promise, values);
                }
              }
            }
          }
          Promise2.race = race;
          function race(iterable) {
            var self2 = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var i2 = -1;
            var promise = new this(INTERNAL);
            while (++i2 < len) {
              resolver(iterable[i2]);
            }
            return promise;
            function resolver(value) {
              self2.resolve(value).then(function(response) {
                if (!called) {
                  called = true;
                  handlers.resolve(promise, response);
                }
              }, function(error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
            }
          }
        }, { "1": 1 }], 3: [function(_dereq_, module22, exports22) {
          (function(global2) {
            if (typeof global2.Promise !== "function") {
              global2.Promise = _dereq_(2);
            }
          }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "2": 2 }], 4: [function(_dereq_, module22, exports22) {
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function getIDB() {
            try {
              if (typeof indexedDB !== "undefined") {
                return indexedDB;
              }
              if (typeof webkitIndexedDB !== "undefined") {
                return webkitIndexedDB;
              }
              if (typeof mozIndexedDB !== "undefined") {
                return mozIndexedDB;
              }
              if (typeof OIndexedDB !== "undefined") {
                return OIndexedDB;
              }
              if (typeof msIndexedDB !== "undefined") {
                return msIndexedDB;
              }
            } catch (e) {
              return;
            }
          }
          var idb = getIDB();
          function isIndexedDBValid() {
            try {
              if (!idb || !idb.open) {
                return false;
              }
              var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
              var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
              return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && typeof IDBKeyRange !== "undefined";
            } catch (e) {
              return false;
            }
          }
          function createBlob(parts, properties) {
            parts = parts || [];
            properties = properties || {};
            try {
              return new Blob(parts, properties);
            } catch (e) {
              if (e.name !== "TypeError") {
                throw e;
              }
              var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
              var builder = new Builder();
              for (var i2 = 0; i2 < parts.length; i2 += 1) {
                builder.append(parts[i2]);
              }
              return builder.getBlob(properties.type);
            }
          }
          if (typeof Promise === "undefined") {
            _dereq_(3);
          }
          var Promise$12 = Promise;
          function executeCallback(promise, callback) {
            if (callback) {
              promise.then(function(result) {
                callback(null, result);
              }, function(error) {
                callback(error);
              });
            }
          }
          function executeTwoCallbacks(promise, callback, errorCallback) {
            if (typeof callback === "function") {
              promise.then(callback);
            }
            if (typeof errorCallback === "function") {
              promise["catch"](errorCallback);
            }
          }
          function normalizeKey2(key2) {
            if (typeof key2 !== "string") {
              console.warn(key2 + " used as a key, but it is not a string.");
              key2 = String(key2);
            }
            return key2;
          }
          function getCallback() {
            if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
              return arguments[arguments.length - 1];
            }
          }
          var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
          var supportsBlobs = void 0;
          var dbContexts = {};
          var toString2 = Object.prototype.toString;
          var READ_ONLY = "readonly";
          var READ_WRITE = "readwrite";
          function _binStringToArrayBuffer(bin) {
            var length2 = bin.length;
            var buf = new ArrayBuffer(length2);
            var arr = new Uint8Array(buf);
            for (var i2 = 0; i2 < length2; i2++) {
              arr[i2] = bin.charCodeAt(i2);
            }
            return buf;
          }
          function _checkBlobSupportWithoutCaching(idb2) {
            return new Promise$12(function(resolve2) {
              var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
              var blob = createBlob([""]);
              txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
              txn.onabort = function(e) {
                e.preventDefault();
                e.stopPropagation();
                resolve2(false);
              };
              txn.oncomplete = function() {
                var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                var matchedEdge = navigator.userAgent.match(/Edge\//);
                resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
              };
            })["catch"](function() {
              return false;
            });
          }
          function _checkBlobSupport(idb2) {
            if (typeof supportsBlobs === "boolean") {
              return Promise$12.resolve(supportsBlobs);
            }
            return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
              supportsBlobs = value;
              return supportsBlobs;
            });
          }
          function _deferReadiness(dbInfo) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = {};
            deferredOperation.promise = new Promise$12(function(resolve2, reject) {
              deferredOperation.resolve = resolve2;
              deferredOperation.reject = reject;
            });
            dbContext.deferredOperations.push(deferredOperation);
            if (!dbContext.dbReady) {
              dbContext.dbReady = deferredOperation.promise;
            } else {
              dbContext.dbReady = dbContext.dbReady.then(function() {
                return deferredOperation.promise;
              });
            }
          }
          function _advanceReadiness(dbInfo) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = dbContext.deferredOperations.pop();
            if (deferredOperation) {
              deferredOperation.resolve();
              return deferredOperation.promise;
            }
          }
          function _rejectReadiness(dbInfo, err) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = dbContext.deferredOperations.pop();
            if (deferredOperation) {
              deferredOperation.reject(err);
              return deferredOperation.promise;
            }
          }
          function _getConnection(dbInfo, upgradeNeeded) {
            return new Promise$12(function(resolve2, reject) {
              dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
              if (dbInfo.db) {
                if (upgradeNeeded) {
                  _deferReadiness(dbInfo);
                  dbInfo.db.close();
                } else {
                  return resolve2(dbInfo.db);
                }
              }
              var dbArgs = [dbInfo.name];
              if (upgradeNeeded) {
                dbArgs.push(dbInfo.version);
              }
              var openreq = idb.open.apply(idb, dbArgs);
              if (upgradeNeeded) {
                openreq.onupgradeneeded = function(e) {
                  var db = openreq.result;
                  try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                      db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                  } catch (ex) {
                    if (ex.name === "ConstraintError") {
                      console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                      throw ex;
                    }
                  }
                };
              }
              openreq.onerror = function(e) {
                e.preventDefault();
                reject(openreq.error);
              };
              openreq.onsuccess = function() {
                resolve2(openreq.result);
                _advanceReadiness(dbInfo);
              };
            });
          }
          function _getOriginalConnection(dbInfo) {
            return _getConnection(dbInfo, false);
          }
          function _getUpgradedConnection(dbInfo) {
            return _getConnection(dbInfo, true);
          }
          function _isUpgradeNeeded(dbInfo, defaultVersion) {
            if (!dbInfo.db) {
              return true;
            }
            var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
            var isDowngrade = dbInfo.version < dbInfo.db.version;
            var isUpgrade = dbInfo.version > dbInfo.db.version;
            if (isDowngrade) {
              if (dbInfo.version !== defaultVersion) {
                console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
              }
              dbInfo.version = dbInfo.db.version;
            }
            if (isUpgrade || isNewStore) {
              if (isNewStore) {
                var incVersion = dbInfo.db.version + 1;
                if (incVersion > dbInfo.version) {
                  dbInfo.version = incVersion;
                }
              }
              return true;
            }
            return false;
          }
          function _encodeBlob(blob) {
            return new Promise$12(function(resolve2, reject) {
              var reader = new FileReader();
              reader.onerror = reject;
              reader.onloadend = function(e) {
                var base64 = btoa(e.target.result || "");
                resolve2({
                  __local_forage_encoded_blob: true,
                  data: base64,
                  type: blob.type
                });
              };
              reader.readAsBinaryString(blob);
            });
          }
          function _decodeBlob(encodedBlob) {
            var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
            return createBlob([arrayBuff], { type: encodedBlob.type });
          }
          function _isEncodedBlob(value) {
            return value && value.__local_forage_encoded_blob;
          }
          function _fullyReady(callback) {
            var self2 = this;
            var promise = self2._initReady().then(function() {
              var dbContext = dbContexts[self2._dbInfo.name];
              if (dbContext && dbContext.dbReady) {
                return dbContext.dbReady;
              }
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          }
          function _tryReconnect(dbInfo) {
            _deferReadiness(dbInfo);
            var dbContext = dbContexts[dbInfo.name];
            var forages = dbContext.forages;
            for (var i2 = 0; i2 < forages.length; i2++) {
              var forage = forages[i2];
              if (forage._dbInfo.db) {
                forage._dbInfo.db.close();
                forage._dbInfo.db = null;
              }
            }
            dbInfo.db = null;
            return _getOriginalConnection(dbInfo).then(function(db) {
              dbInfo.db = db;
              if (_isUpgradeNeeded(dbInfo)) {
                return _getUpgradedConnection(dbInfo);
              }
              return db;
            }).then(function(db) {
              dbInfo.db = dbContext.db = db;
              for (var i22 = 0; i22 < forages.length; i22++) {
                forages[i22]._dbInfo.db = db;
              }
            })["catch"](function(err) {
              _rejectReadiness(dbInfo, err);
              throw err;
            });
          }
          function createTransaction(dbInfo, mode, callback, retries) {
            if (retries === void 0) {
              retries = 1;
            }
            try {
              var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
              callback(null, tx);
            } catch (err) {
              if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
                return Promise$12.resolve().then(function() {
                  if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    if (dbInfo.db) {
                      dbInfo.version = dbInfo.db.version + 1;
                    }
                    return _getUpgradedConnection(dbInfo);
                  }
                }).then(function() {
                  return _tryReconnect(dbInfo).then(function() {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                  });
                })["catch"](callback);
              }
              callback(err);
            }
          }
          function createDbContext() {
            return {
              forages: [],
              db: null,
              dbReady: null,
              deferredOperations: []
            };
          }
          function _initStorage(options) {
            var self2 = this;
            var dbInfo = {
              db: null
            };
            if (options) {
              for (var i2 in options) {
                dbInfo[i2] = options[i2];
              }
            }
            var dbContext = dbContexts[dbInfo.name];
            if (!dbContext) {
              dbContext = createDbContext();
              dbContexts[dbInfo.name] = dbContext;
            }
            dbContext.forages.push(self2);
            if (!self2._initReady) {
              self2._initReady = self2.ready;
              self2.ready = _fullyReady;
            }
            var initPromises = [];
            function ignoreErrors() {
              return Promise$12.resolve();
            }
            for (var j = 0; j < dbContext.forages.length; j++) {
              var forage = dbContext.forages[j];
              if (forage !== self2) {
                initPromises.push(forage._initReady()["catch"](ignoreErrors));
              }
            }
            var forages = dbContext.forages.slice(0);
            return Promise$12.all(initPromises).then(function() {
              dbInfo.db = dbContext.db;
              return _getOriginalConnection(dbInfo);
            }).then(function(db) {
              dbInfo.db = db;
              if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
                return _getUpgradedConnection(dbInfo);
              }
              return db;
            }).then(function(db) {
              dbInfo.db = dbContext.db = db;
              self2._dbInfo = dbInfo;
              for (var k = 0; k < forages.length; k++) {
                var forage2 = forages[k];
                if (forage2 !== self2) {
                  forage2._dbInfo.db = dbInfo.db;
                  forage2._dbInfo.version = dbInfo.version;
                }
              }
            });
          }
          function getItem(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.get(key2);
                    req.onsuccess = function() {
                      var value = req.result;
                      if (value === void 0) {
                        value = null;
                      }
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      resolve2(value);
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate(iterator, callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;
                    req.onsuccess = function() {
                      var cursor = req.result;
                      if (cursor) {
                        var value = cursor.value;
                        if (_isEncodedBlob(value)) {
                          value = _decodeBlob(value);
                        }
                        var result = iterator(value, cursor.key, iterationNumber++);
                        if (result !== void 0) {
                          resolve2(result);
                        } else {
                          cursor["continue"]();
                        }
                      } else {
                        resolve2();
                      }
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem(key2, value, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$12(function(resolve2, reject) {
              var dbInfo;
              self2.ready().then(function() {
                dbInfo = self2._dbInfo;
                if (toString2.call(value) === "[object Blob]") {
                  return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                    if (blobSupport) {
                      return value;
                    }
                    return _encodeBlob(value);
                  });
                }
                return value;
              }).then(function(value2) {
                createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    if (value2 === null) {
                      value2 = void 0;
                    }
                    var req = store.put(value2, key2);
                    transaction.oncomplete = function() {
                      if (value2 === void 0) {
                        value2 = null;
                      }
                      resolve2(value2);
                    };
                    transaction.onabort = transaction.onerror = function() {
                      var err2 = req.error ? req.error : req.transaction.error;
                      reject(err2);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store["delete"](key2);
                    transaction.oncomplete = function() {
                      resolve2();
                    };
                    transaction.onerror = function() {
                      reject(req.error);
                    };
                    transaction.onabort = function() {
                      var err2 = req.error ? req.error : req.transaction.error;
                      reject(err2);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function clear2(callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.clear();
                    transaction.oncomplete = function() {
                      resolve2();
                    };
                    transaction.onabort = transaction.onerror = function() {
                      var err2 = req.error ? req.error : req.transaction.error;
                      reject(err2);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length(callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.count();
                    req.onsuccess = function() {
                      resolve2(req.result);
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key(n, callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              if (n < 0) {
                resolve2(null);
                return;
              }
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();
                    req.onsuccess = function() {
                      var cursor = req.result;
                      if (!cursor) {
                        resolve2(null);
                        return;
                      }
                      if (n === 0) {
                        resolve2(cursor.key);
                      } else {
                        if (!advanced) {
                          advanced = true;
                          cursor.advance(n);
                        } else {
                          resolve2(cursor.key);
                        }
                      }
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys2(callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                  if (err) {
                    return reject(err);
                  }
                  try {
                    var store = transaction.objectStore(self2._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys22 = [];
                    req.onsuccess = function() {
                      var cursor = req.result;
                      if (!cursor) {
                        resolve2(keys22);
                        return;
                      }
                      keys22.push(cursor.key);
                      cursor["continue"]();
                    };
                    req.onerror = function() {
                      reject(req.error);
                    };
                  } catch (e) {
                    reject(e);
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function dropInstance(options, callback) {
            callback = getCallback.apply(this, arguments);
            var currentConfig = this.config();
            options = typeof options !== "function" && options || {};
            if (!options.name) {
              options.name = options.name || currentConfig.name;
              options.storeName = options.storeName || currentConfig.storeName;
            }
            var self2 = this;
            var promise;
            if (!options.name) {
              promise = Promise$12.reject("Invalid arguments");
            } else {
              var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
              var dbPromise = isCurrentDb ? Promise$12.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                dbContext.db = db;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  forages[i2]._dbInfo.db = db;
                }
                return db;
              });
              if (!options.storeName) {
                promise = dbPromise.then(function(db) {
                  _deferReadiness(options);
                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;
                  db.close();
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var forage = forages[i2];
                    forage._dbInfo.db = null;
                  }
                  var dropDBPromise = new Promise$12(function(resolve2, reject) {
                    var req = idb.deleteDatabase(options.name);
                    req.onerror = req.onblocked = function(err) {
                      var db2 = req.result;
                      if (db2) {
                        db2.close();
                      }
                      reject(err);
                    };
                    req.onsuccess = function() {
                      var db2 = req.result;
                      if (db2) {
                        db2.close();
                      }
                      resolve2(db2);
                    };
                  });
                  return dropDBPromise.then(function(db2) {
                    dbContext.db = db2;
                    for (var i22 = 0; i22 < forages.length; i22++) {
                      var _forage = forages[i22];
                      _advanceReadiness(_forage._dbInfo);
                    }
                  })["catch"](function(err) {
                    (_rejectReadiness(options, err) || Promise$12.resolve())["catch"](function() {
                    });
                    throw err;
                  });
                });
              } else {
                promise = dbPromise.then(function(db) {
                  if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                  }
                  var newVersion = db.version + 1;
                  _deferReadiness(options);
                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;
                  db.close();
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var forage = forages[i2];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                  }
                  var dropObjectPromise = new Promise$12(function(resolve2, reject) {
                    var req = idb.open(options.name, newVersion);
                    req.onerror = function(err) {
                      var db2 = req.result;
                      db2.close();
                      reject(err);
                    };
                    req.onupgradeneeded = function() {
                      var db2 = req.result;
                      db2.deleteObjectStore(options.storeName);
                    };
                    req.onsuccess = function() {
                      var db2 = req.result;
                      db2.close();
                      resolve2(db2);
                    };
                  });
                  return dropObjectPromise.then(function(db2) {
                    dbContext.db = db2;
                    for (var j = 0; j < forages.length; j++) {
                      var _forage2 = forages[j];
                      _forage2._dbInfo.db = db2;
                      _advanceReadiness(_forage2._dbInfo);
                    }
                  })["catch"](function(err) {
                    (_rejectReadiness(options, err) || Promise$12.resolve())["catch"](function() {
                    });
                    throw err;
                  });
                });
              }
            }
            executeCallback(promise, callback);
            return promise;
          }
          var asyncStorage = {
            _driver: "asyncStorage",
            _initStorage,
            _support: isIndexedDBValid(),
            iterate,
            getItem,
            setItem,
            removeItem,
            clear: clear2,
            length,
            key,
            keys: keys2,
            dropInstance
          };
          function isWebSQLValid() {
            return typeof openDatabase === "function";
          }
          var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var BLOB_TYPE_PREFIX = "~~local_forage_type~";
          var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
          var SERIALIZED_MARKER = "__lfsc__:";
          var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
          var TYPE_ARRAYBUFFER = "arbf";
          var TYPE_BLOB = "blob";
          var TYPE_INT8ARRAY = "si08";
          var TYPE_UINT8ARRAY = "ui08";
          var TYPE_UINT8CLAMPEDARRAY = "uic8";
          var TYPE_INT16ARRAY = "si16";
          var TYPE_INT32ARRAY = "si32";
          var TYPE_UINT16ARRAY = "ur16";
          var TYPE_UINT32ARRAY = "ui32";
          var TYPE_FLOAT32ARRAY = "fl32";
          var TYPE_FLOAT64ARRAY = "fl64";
          var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
          var toString$12 = Object.prototype.toString;
          function stringToBuffer(serializedString) {
            var bufferLength = serializedString.length * 0.75;
            var len = serializedString.length;
            var i2;
            var p2 = 0;
            var encoded1, encoded2, encoded3, encoded4;
            if (serializedString[serializedString.length - 1] === "=") {
              bufferLength--;
              if (serializedString[serializedString.length - 2] === "=") {
                bufferLength--;
              }
            }
            var buffer2 = new ArrayBuffer(bufferLength);
            var bytes = new Uint8Array(buffer2);
            for (i2 = 0; i2 < len; i2 += 4) {
              encoded1 = BASE_CHARS.indexOf(serializedString[i2]);
              encoded2 = BASE_CHARS.indexOf(serializedString[i2 + 1]);
              encoded3 = BASE_CHARS.indexOf(serializedString[i2 + 2]);
              encoded4 = BASE_CHARS.indexOf(serializedString[i2 + 3]);
              bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
              bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
              bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
            }
            return buffer2;
          }
          function bufferToString(buffer2) {
            var bytes = new Uint8Array(buffer2);
            var base64String = "";
            var i2;
            for (i2 = 0; i2 < bytes.length; i2 += 3) {
              base64String += BASE_CHARS[bytes[i2] >> 2];
              base64String += BASE_CHARS[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
              base64String += BASE_CHARS[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
              base64String += BASE_CHARS[bytes[i2 + 2] & 63];
            }
            if (bytes.length % 3 === 2) {
              base64String = base64String.substring(0, base64String.length - 1) + "=";
            } else if (bytes.length % 3 === 1) {
              base64String = base64String.substring(0, base64String.length - 2) + "==";
            }
            return base64String;
          }
          function serialize(value, callback) {
            var valueType = "";
            if (value) {
              valueType = toString$12.call(value);
            }
            if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$12.call(value.buffer) === "[object ArrayBuffer]")) {
              var buffer2;
              var marker = SERIALIZED_MARKER;
              if (value instanceof ArrayBuffer) {
                buffer2 = value;
                marker += TYPE_ARRAYBUFFER;
              } else {
                buffer2 = value.buffer;
                if (valueType === "[object Int8Array]") {
                  marker += TYPE_INT8ARRAY;
                } else if (valueType === "[object Uint8Array]") {
                  marker += TYPE_UINT8ARRAY;
                } else if (valueType === "[object Uint8ClampedArray]") {
                  marker += TYPE_UINT8CLAMPEDARRAY;
                } else if (valueType === "[object Int16Array]") {
                  marker += TYPE_INT16ARRAY;
                } else if (valueType === "[object Uint16Array]") {
                  marker += TYPE_UINT16ARRAY;
                } else if (valueType === "[object Int32Array]") {
                  marker += TYPE_INT32ARRAY;
                } else if (valueType === "[object Uint32Array]") {
                  marker += TYPE_UINT32ARRAY;
                } else if (valueType === "[object Float32Array]") {
                  marker += TYPE_FLOAT32ARRAY;
                } else if (valueType === "[object Float64Array]") {
                  marker += TYPE_FLOAT64ARRAY;
                } else {
                  callback(new Error("Failed to get type for BinaryArray"));
                }
              }
              callback(marker + bufferToString(buffer2));
            } else if (valueType === "[object Blob]") {
              var fileReader = new FileReader();
              fileReader.onload = function() {
                var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
                callback(SERIALIZED_MARKER + TYPE_BLOB + str);
              };
              fileReader.readAsArrayBuffer(value);
            } else {
              try {
                callback(JSON.stringify(value));
              } catch (e) {
                console.error("Couldn't convert value into a JSON string: ", value);
                callback(null, e);
              }
            }
          }
          function deserialize(value) {
            if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
              return JSON.parse(value);
            }
            var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
            var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
            var blobType;
            if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
              var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
              blobType = matcher[1];
              serializedString = serializedString.substring(matcher[0].length);
            }
            var buffer2 = stringToBuffer(serializedString);
            switch (type2) {
              case TYPE_ARRAYBUFFER:
                return buffer2;
              case TYPE_BLOB:
                return createBlob([buffer2], { type: blobType });
              case TYPE_INT8ARRAY:
                return new Int8Array(buffer2);
              case TYPE_UINT8ARRAY:
                return new Uint8Array(buffer2);
              case TYPE_UINT8CLAMPEDARRAY:
                return new Uint8ClampedArray(buffer2);
              case TYPE_INT16ARRAY:
                return new Int16Array(buffer2);
              case TYPE_UINT16ARRAY:
                return new Uint16Array(buffer2);
              case TYPE_INT32ARRAY:
                return new Int32Array(buffer2);
              case TYPE_UINT32ARRAY:
                return new Uint32Array(buffer2);
              case TYPE_FLOAT32ARRAY:
                return new Float32Array(buffer2);
              case TYPE_FLOAT64ARRAY:
                return new Float64Array(buffer2);
              default:
                throw new Error("Unkown type: " + type2);
            }
          }
          var localforageSerializer = {
            serialize,
            deserialize,
            stringToBuffer,
            bufferToString
          };
          function createDbTable(t, dbInfo, callback, errorCallback) {
            t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
          }
          function _initStorage$1(options) {
            var self2 = this;
            var dbInfo = {
              db: null
            };
            if (options) {
              for (var i2 in options) {
                dbInfo[i2] = typeof options[i2] !== "string" ? options[i2].toString() : options[i2];
              }
            }
            var dbInfoPromise = new Promise$12(function(resolve2, reject) {
              try {
                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
              } catch (e) {
                return reject(e);
              }
              dbInfo.db.transaction(function(t) {
                createDbTable(t, dbInfo, function() {
                  self2._dbInfo = dbInfo;
                  resolve2();
                }, function(t2, error) {
                  reject(error);
                });
              }, reject);
            });
            dbInfo.serializer = localforageSerializer;
            return dbInfoPromise;
          }
          function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
            t.executeSql(sqlStatement, args, callback, function(t2, error) {
              if (error.code === error.SYNTAX_ERR) {
                t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                  if (!results.rows.length) {
                    createDbTable(t3, dbInfo, function() {
                      t3.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                  } else {
                    errorCallback(t3, error);
                  }
                }, errorCallback);
              } else {
                errorCallback(t2, error);
              }
            }, errorCallback);
          }
          function getItem$1(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    resolve2(result);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate$1(iterator, callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                    var rows = results.rows;
                    var length2 = rows.length;
                    for (var i2 = 0; i2 < length2; i2++) {
                      var item = rows.item(i2);
                      var result = item.value;
                      if (result) {
                        result = dbInfo.serializer.deserialize(result);
                      }
                      result = iterator(result, item.key, i2 + 1);
                      if (result !== void 0) {
                        resolve2(result);
                        return;
                      }
                    }
                    resolve2();
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function _setItem(key2, value, callback, retriesLeft) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                if (value === void 0) {
                  value = null;
                }
                var originalValue = value;
                var dbInfo = self2._dbInfo;
                dbInfo.serializer.serialize(value, function(value2, error) {
                  if (error) {
                    reject(error);
                  } else {
                    dbInfo.db.transaction(function(t) {
                      tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                        resolve2(originalValue);
                      }, function(t2, error2) {
                        reject(error2);
                      });
                    }, function(sqlError) {
                      if (sqlError.code === sqlError.QUOTA_ERR) {
                        if (retriesLeft > 0) {
                          resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                          return;
                        }
                        reject(sqlError);
                      }
                    });
                  }
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem$1(key2, value, callback) {
            return _setItem.apply(this, [key2, value, callback, 1]);
          }
          function removeItem$1(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                    resolve2();
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function clear$1(callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                    resolve2();
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length$1(callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                    var result = results.rows.item(0).c;
                    resolve2(result);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key$1(n, callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve2(result);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys$1(callback) {
            var self2 = this;
            var promise = new Promise$12(function(resolve2, reject) {
              self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                    var keys22 = [];
                    for (var i2 = 0; i2 < results.rows.length; i2++) {
                      keys22.push(results.rows.item(i2).key);
                    }
                    resolve2(keys22);
                  }, function(t2, error) {
                    reject(error);
                  });
                });
              })["catch"](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function getAllStoreNames(db) {
            return new Promise$12(function(resolve2, reject) {
              db.transaction(function(t) {
                t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                  var storeNames = [];
                  for (var i2 = 0; i2 < results.rows.length; i2++) {
                    storeNames.push(results.rows.item(i2).name);
                  }
                  resolve2({
                    db,
                    storeNames
                  });
                }, function(t2, error) {
                  reject(error);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          }
          function dropInstance$1(options, callback) {
            callback = getCallback.apply(this, arguments);
            var currentConfig = this.config();
            options = typeof options !== "function" && options || {};
            if (!options.name) {
              options.name = options.name || currentConfig.name;
              options.storeName = options.storeName || currentConfig.storeName;
            }
            var self2 = this;
            var promise;
            if (!options.name) {
              promise = Promise$12.reject("Invalid arguments");
            } else {
              promise = new Promise$12(function(resolve2) {
                var db;
                if (options.name === currentConfig.name) {
                  db = self2._dbInfo.db;
                } else {
                  db = openDatabase(options.name, "", "", 0);
                }
                if (!options.storeName) {
                  resolve2(getAllStoreNames(db));
                } else {
                  resolve2({
                    db,
                    storeNames: [options.storeName]
                  });
                }
              }).then(function(operationInfo) {
                return new Promise$12(function(resolve2, reject) {
                  operationInfo.db.transaction(function(t) {
                    function dropTable(storeName) {
                      return new Promise$12(function(resolve22, reject2) {
                        t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                          resolve22();
                        }, function(t2, error) {
                          reject2(error);
                        });
                      });
                    }
                    var operations = [];
                    for (var i2 = 0, len = operationInfo.storeNames.length; i2 < len; i2++) {
                      operations.push(dropTable(operationInfo.storeNames[i2]));
                    }
                    Promise$12.all(operations).then(function() {
                      resolve2();
                    })["catch"](function(e) {
                      reject(e);
                    });
                  }, function(sqlError) {
                    reject(sqlError);
                  });
                });
              });
            }
            executeCallback(promise, callback);
            return promise;
          }
          var webSQLStorage = {
            _driver: "webSQLStorage",
            _initStorage: _initStorage$1,
            _support: isWebSQLValid(),
            iterate: iterate$1,
            getItem: getItem$1,
            setItem: setItem$1,
            removeItem: removeItem$1,
            clear: clear$1,
            length: length$1,
            key: key$1,
            keys: keys$1,
            dropInstance: dropInstance$1
          };
          function isLocalStorageValid() {
            try {
              return typeof localStorage !== "undefined" && "setItem" in localStorage && !!localStorage.setItem;
            } catch (e) {
              return false;
            }
          }
          function _getKeyPrefix(options, defaultConfig) {
            var keyPrefix = options.name + "/";
            if (options.storeName !== defaultConfig.storeName) {
              keyPrefix += options.storeName + "/";
            }
            return keyPrefix;
          }
          function checkIfLocalStorageThrows() {
            var localStorageTestKey = "_localforage_support_test";
            try {
              localStorage.setItem(localStorageTestKey, true);
              localStorage.removeItem(localStorageTestKey);
              return false;
            } catch (e) {
              return true;
            }
          }
          function _isLocalStorageUsable() {
            return !checkIfLocalStorageThrows() || localStorage.length > 0;
          }
          function _initStorage$2(options) {
            var self2 = this;
            var dbInfo = {};
            if (options) {
              for (var i2 in options) {
                dbInfo[i2] = options[i2];
              }
            }
            dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
            if (!_isLocalStorageUsable()) {
              return Promise$12.reject();
            }
            self2._dbInfo = dbInfo;
            dbInfo.serializer = localforageSerializer;
            return Promise$12.resolve();
          }
          function clear$2(callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var keyPrefix = self2._dbInfo.keyPrefix;
              for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
                var key2 = localStorage.key(i2);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
            executeCallback(promise, callback);
            return promise;
          }
          function getItem$2(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var result = localStorage.getItem(dbInfo.keyPrefix + key2);
              if (result) {
                result = dbInfo.serializer.deserialize(result);
              }
              return result;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate$2(iterator, callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var keyPrefix = dbInfo.keyPrefix;
              var keyPrefixLength = keyPrefix.length;
              var length2 = localStorage.length;
              var iterationNumber = 1;
              for (var i2 = 0; i2 < length2; i2++) {
                var key2 = localStorage.key(i2);
                if (key2.indexOf(keyPrefix) !== 0) {
                  continue;
                }
                var value = localStorage.getItem(key2);
                if (value) {
                  value = dbInfo.serializer.deserialize(value);
                }
                value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
                if (value !== void 0) {
                  return value;
                }
              }
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key$2(n, callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var result;
              try {
                result = localStorage.key(n);
              } catch (error) {
                result = null;
              }
              if (result) {
                result = result.substring(dbInfo.keyPrefix.length);
              }
              return result;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys$2(callback) {
            var self2 = this;
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              var length2 = localStorage.length;
              var keys22 = [];
              for (var i2 = 0; i2 < length2; i2++) {
                var itemKey = localStorage.key(i2);
                if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                  keys22.push(itemKey.substring(dbInfo.keyPrefix.length));
                }
              }
              return keys22;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length$2(callback) {
            var self2 = this;
            var promise = self2.keys().then(function(keys22) {
              return keys22.length;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem$2(key2, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              localStorage.removeItem(dbInfo.keyPrefix + key2);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem$2(key2, value, callback) {
            var self2 = this;
            key2 = normalizeKey2(key2);
            var promise = self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              return new Promise$12(function(resolve2, reject) {
                var dbInfo = self2._dbInfo;
                dbInfo.serializer.serialize(value, function(value2, error) {
                  if (error) {
                    reject(error);
                  } else {
                    try {
                      localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                      resolve2(originalValue);
                    } catch (e) {
                      if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                        reject(e);
                      }
                      reject(e);
                    }
                  }
                });
              });
            });
            executeCallback(promise, callback);
            return promise;
          }
          function dropInstance$2(options, callback) {
            callback = getCallback.apply(this, arguments);
            options = typeof options !== "function" && options || {};
            if (!options.name) {
              var currentConfig = this.config();
              options.name = options.name || currentConfig.name;
              options.storeName = options.storeName || currentConfig.storeName;
            }
            var self2 = this;
            var promise;
            if (!options.name) {
              promise = Promise$12.reject("Invalid arguments");
            } else {
              promise = new Promise$12(function(resolve2) {
                if (!options.storeName) {
                  resolve2(options.name + "/");
                } else {
                  resolve2(_getKeyPrefix(options, self2._defaultConfig));
                }
              }).then(function(keyPrefix) {
                for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
                  var key2 = localStorage.key(i2);
                  if (key2.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key2);
                  }
                }
              });
            }
            executeCallback(promise, callback);
            return promise;
          }
          var localStorageWrapper = {
            _driver: "localStorageWrapper",
            _initStorage: _initStorage$2,
            _support: isLocalStorageValid(),
            iterate: iterate$2,
            getItem: getItem$2,
            setItem: setItem$2,
            removeItem: removeItem$2,
            clear: clear$2,
            length: length$2,
            key: key$2,
            keys: keys$2,
            dropInstance: dropInstance$2
          };
          var sameValue = function sameValue2(x, y) {
            return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
          };
          var includes = function includes2(array2, searchElement) {
            var len = array2.length;
            var i2 = 0;
            while (i2 < len) {
              if (sameValue(array2[i2], searchElement)) {
                return true;
              }
              i2++;
            }
            return false;
          };
          var isArray2 = Array.isArray || function(arg) {
            return Object.prototype.toString.call(arg) === "[object Array]";
          };
          var DefinedDrivers = {};
          var DriverSupport = {};
          var DefaultDrivers = {
            INDEXEDDB: asyncStorage,
            WEBSQL: webSQLStorage,
            LOCALSTORAGE: localStorageWrapper
          };
          var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
          var OptionalDriverMethods = ["dropInstance"];
          var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
          var DefaultConfig = {
            description: "",
            driver: DefaultDriverOrder.slice(),
            name: "localforage",
            size: 4980736,
            storeName: "keyvaluepairs",
            version: 1
          };
          function callWhenReady(localForageInstance, libraryMethod) {
            localForageInstance[libraryMethod] = function() {
              var _args = arguments;
              return localForageInstance.ready().then(function() {
                return localForageInstance[libraryMethod].apply(localForageInstance, _args);
              });
            };
          }
          function extend2() {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var arg = arguments[i2];
              if (arg) {
                for (var _key in arg) {
                  if (arg.hasOwnProperty(_key)) {
                    if (isArray2(arg[_key])) {
                      arguments[0][_key] = arg[_key].slice();
                    } else {
                      arguments[0][_key] = arg[_key];
                    }
                  }
                }
              }
            }
            return arguments[0];
          }
          var LocalForage = function() {
            function LocalForage2(options) {
              _classCallCheck(this, LocalForage2);
              for (var driverTypeKey in DefaultDrivers) {
                if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                  var driver = DefaultDrivers[driverTypeKey];
                  var driverName = driver._driver;
                  this[driverTypeKey] = driverName;
                  if (!DefinedDrivers[driverName]) {
                    this.defineDriver(driver);
                  }
                }
              }
              this._defaultConfig = extend2({}, DefaultConfig);
              this._config = extend2({}, this._defaultConfig, options);
              this._driverSet = null;
              this._initDriver = null;
              this._ready = false;
              this._dbInfo = null;
              this._wrapLibraryMethodsWithReady();
              this.setDriver(this._config.driver)["catch"](function() {
              });
            }
            LocalForage2.prototype.config = function config2(options) {
              if ((typeof options === "undefined" ? "undefined" : _typeof2(options)) === "object") {
                if (this._ready) {
                  return new Error("Can't call config() after localforage has been used.");
                }
                for (var i2 in options) {
                  if (i2 === "storeName") {
                    options[i2] = options[i2].replace(/\W/g, "_");
                  }
                  if (i2 === "version" && typeof options[i2] !== "number") {
                    return new Error("Database version must be a number.");
                  }
                  this._config[i2] = options[i2];
                }
                if ("driver" in options && options.driver) {
                  return this.setDriver(this._config.driver);
                }
                return true;
              } else if (typeof options === "string") {
                return this._config[options];
              } else {
                return this._config;
              }
            };
            LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
              var promise = new Promise$12(function(resolve2, reject) {
                try {
                  var driverName = driverObject._driver;
                  var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                  }
                  var driverMethods = LibraryMethods.concat("_initStorage");
                  for (var i2 = 0, len = driverMethods.length; i2 < len; i2++) {
                    var driverMethodName = driverMethods[i2];
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                      reject(complianceError);
                      return;
                    }
                  }
                  var configureMissingMethods = function configureMissingMethods2() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                      return function() {
                        var error = new Error("Method " + methodName + " is not implemented by the current driver");
                        var promise2 = Promise$12.reject(error);
                        executeCallback(promise2, arguments[arguments.length - 1]);
                        return promise2;
                      };
                    };
                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                      var optionalDriverMethod = OptionalDriverMethods[_i];
                      if (!driverObject[optionalDriverMethod]) {
                        driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                      }
                    }
                  };
                  configureMissingMethods();
                  var setDriverSupport = function setDriverSupport2(support) {
                    if (DefinedDrivers[driverName]) {
                      console.info("Redefining LocalForage driver: " + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    resolve2();
                  };
                  if ("_support" in driverObject) {
                    if (driverObject._support && typeof driverObject._support === "function") {
                      driverObject._support().then(setDriverSupport, reject);
                    } else {
                      setDriverSupport(!!driverObject._support);
                    }
                  } else {
                    setDriverSupport(true);
                  }
                } catch (e) {
                  reject(e);
                }
              });
              executeTwoCallbacks(promise, callback, errorCallback);
              return promise;
            };
            LocalForage2.prototype.driver = function driver() {
              return this._driver || null;
            };
            LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
              var getDriverPromise = DefinedDrivers[driverName] ? Promise$12.resolve(DefinedDrivers[driverName]) : Promise$12.reject(new Error("Driver not found."));
              executeTwoCallbacks(getDriverPromise, callback, errorCallback);
              return getDriverPromise;
            };
            LocalForage2.prototype.getSerializer = function getSerializer(callback) {
              var serializerPromise = Promise$12.resolve(localforageSerializer);
              executeTwoCallbacks(serializerPromise, callback);
              return serializerPromise;
            };
            LocalForage2.prototype.ready = function ready(callback) {
              var self2 = this;
              var promise = self2._driverSet.then(function() {
                if (self2._ready === null) {
                  self2._ready = self2._initDriver();
                }
                return self2._ready;
              });
              executeTwoCallbacks(promise, callback, callback);
              return promise;
            };
            LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
              var self2 = this;
              if (!isArray2(drivers)) {
                drivers = [drivers];
              }
              var supportedDrivers = this._getSupportedDrivers(drivers);
              function setDriverToConfig() {
                self2._config.driver = self2.driver();
              }
              function extendSelfWithDriver(driver) {
                self2._extend(driver);
                setDriverToConfig();
                self2._ready = self2._initStorage(self2._config);
                return self2._ready;
              }
              function initDriver(supportedDrivers2) {
                return function() {
                  var currentDriverIndex = 0;
                  function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers2.length) {
                      var driverName = supportedDrivers2[currentDriverIndex];
                      currentDriverIndex++;
                      self2._dbInfo = null;
                      self2._ready = null;
                      return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }
                    setDriverToConfig();
                    var error = new Error("No available storage method found.");
                    self2._driverSet = Promise$12.reject(error);
                    return self2._driverSet;
                  }
                  return driverPromiseLoop();
                };
              }
              var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
                return Promise$12.resolve();
              }) : Promise$12.resolve();
              this._driverSet = oldDriverSetDone.then(function() {
                var driverName = supportedDrivers[0];
                self2._dbInfo = null;
                self2._ready = null;
                return self2.getDriver(driverName).then(function(driver) {
                  self2._driver = driver._driver;
                  setDriverToConfig();
                  self2._wrapLibraryMethodsWithReady();
                  self2._initDriver = initDriver(supportedDrivers);
                });
              })["catch"](function() {
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$12.reject(error);
                return self2._driverSet;
              });
              executeTwoCallbacks(this._driverSet, callback, errorCallback);
              return this._driverSet;
            };
            LocalForage2.prototype.supports = function supports(driverName) {
              return !!DriverSupport[driverName];
            };
            LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
              extend2(this, libraryMethodsAndProperties);
            };
            LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
              var supportedDrivers = [];
              for (var i2 = 0, len = drivers.length; i2 < len; i2++) {
                var driverName = drivers[i2];
                if (this.supports(driverName)) {
                  supportedDrivers.push(driverName);
                }
              }
              return supportedDrivers;
            };
            LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
              for (var i2 = 0, len = LibraryMethods.length; i2 < len; i2++) {
                callWhenReady(this, LibraryMethods[i2]);
              }
            };
            LocalForage2.prototype.createInstance = function createInstance2(options) {
              return new LocalForage2(options);
            };
            return LocalForage2;
          }();
          var localforage_js = new LocalForage();
          module22.exports = localforage_js;
        }, { "3": 3 }] }, {}, [4])(4);
      });
    })(localforage$1);
    localforage$1.exports;
    var OPERATOR;
    (function(OPERATOR2) {
      OPERATOR2["\u7B49\u4E8E"] = "=";
      OPERATOR2["\u5927\u4E8E"] = ">";
      OPERATOR2["\u5C0F\u4E8E"] = "<";
      OPERATOR2["\u5927\u4E8E\u7B49\u4E8E"] = ">=";
      OPERATOR2["\u5C0F\u4E8E\u7B49\u4E8E"] = "<=";
      OPERATOR2["\u4E0D\u7B49\u4E8E"] = "!=";
    })(OPERATOR || (OPERATOR = {}));
    const EMPTY_OBJ = {};
    const NOOP = () => {
    };
    const extend$1 = Object.assign;
    const remove = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const isArray$4 = Array.isArray;
    const isMap$1 = (val) => toTypeString(val) === "[object Map]";
    const isSet$1 = (val) => toTypeString(val) === "[object Set]";
    const isFunction = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return isObject(val) && isFunction(val.then) && isFunction(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const isPlainObject = (val) => toTypeString(val) === "[object Object]";
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    let activeEffectScope;
    function recordEffectScope(effect2, scope) {
      scope = scope || activeEffectScope;
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    const newTracked = (dep) => (dep.n & trackOpBit) > 0;
    const initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].w |= trackOpBit;
        }
      }
    };
    const finalizeDepMarkers = (effect2) => {
      const { deps } = effect2;
      if (deps.length) {
        let ptr = 0;
        for (let i2 = 0; i2 < deps.length; i2++) {
          const dep = deps[i2];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect2);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    let effectTrackDepth = 0;
    let trackOpBit = 1;
    const maxMarkerBits = 30;
    const effectStack = [];
    let activeEffect;
    class ReactiveEffect {
      constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        if (!effectStack.length || !effectStack.includes(this)) {
          try {
            effectStack.push(activeEffect = this);
            enableTracking();
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            effectStack.pop();
            const n = effectStack.length;
            activeEffect = n > 0 ? effectStack[n - 1] : void 0;
          }
        }
      }
      stop() {
        if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect(effect2) {
      const { deps } = effect2;
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].delete(effect2);
        }
        deps.length = 0;
      }
    }
    function enableTracking() {
    }
    new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol$1));
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    function isRef(r) {
      return Boolean(r && r.__v_isRef === true);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    Promise.resolve();
    function callWithErrorHandling(fn, instance, type2, args) {
      let res;
      try {
        res = args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type2);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn, instance, type2, args) {
      if (isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type2, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn[i2], instance, type2, args));
      }
      return values;
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type2;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev);
    }
    function logError(err, type2, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPreFlushCbs = [];
    let activePreFlushCbs = null;
    let preFlushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = Promise.resolve();
    let currentFlushPromise = null;
    let currentPreFlushParentJob = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
      }
      return start;
    }
    function queueJob(job) {
      if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queueCb(cb, activeQueue, pendingQueue, index2) {
      if (!isArray$4(cb)) {
        if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
          pendingQueue.push(cb);
        }
      } else {
        pendingQueue.push(...cb);
      }
      queueFlush();
    }
    function queuePreFlushCb(cb) {
      queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
    }
    function queuePostFlushCb(cb) {
      queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
    }
    function flushPreFlushCbs(seen2, parentJob = null) {
      if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
          activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        flushPreFlushCbs(seen2, parentJob);
      }
    }
    function flushPostFlushCbs(seen2) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    function flushJobs(seen2) {
      isFlushPending = false;
      isFlushing = true;
      flushPreFlushCbs(seen2);
      queue.sort((a, b) => getId(a) - getId(b));
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
          flushJobs(seen2);
        }
      }
    }
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$4(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const INITIAL_WATCHER_VALUE = {};
    function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      const instance = currentInstance;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$4(source)) {
        isMultiSource = true;
        forceTrigger = source.some(isReactive);
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
        };
      };
      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        scheduler = () => {
          if (!instance || instance.isMounted) {
            queuePreFlushCb(job);
          } else {
            job();
          }
        };
      }
      const effect2 = new ReactiveEffect(getter, scheduler);
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
      } else {
        effect2.run();
      }
      return () => {
        effect2.stop();
        if (instance && instance.scope) {
          remove(instance.scope.effects, effect2);
        }
      };
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      if (cur) {
        setCurrentInstance(cur);
      } else {
        unsetCurrentInstance();
      }
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse(value, seen2) {
      if (!isObject(value) || value["__v_skip"]) {
        return value;
      }
      seen2 = seen2 || /* @__PURE__ */ new Set();
      if (seen2.has(value)) {
        return value;
      }
      seen2.add(value);
      if (isRef(value)) {
        traverse(value.value, seen2);
      } else if (isArray$4(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse(value[i2], seen2);
        }
      } else if (isSet$1(value) || isMap$1(value)) {
        value.forEach((v) => {
          traverse(v, seen2);
        });
      } else if (isPlainObject(value)) {
        for (const key in value) {
          traverse(value[key], seen2);
        }
      }
      return value;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
      const cached = cache2.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      cache2.set(base, resolved);
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeObjectOptions,
      emits: mergeObjectOptions,
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      watch: mergeWatchOptions,
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend$1(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$4(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend$1(extend$1(/* @__PURE__ */ Object.create(null), to), from) : from;
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getExposeProxy(i2) || i2.proxy;
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = extend$1(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => i2.props,
      $attrs: (i2) => i2.attrs,
      $slots: (i2) => i2.slots,
      $refs: (i2) => i2.refs,
      $parent: (i2) => getPublicInstance(i2.parent),
      $root: (i2) => getPublicInstance(i2.root),
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions(i2),
      $forceUpdate: (i2) => () => queueJob(i2.update),
      $nextTick: (i2) => nextTick.bind(i2.proxy),
      $watch: (i2) => instanceWatch.bind(i2)
    });
    let currentInstance = null;
    const setCurrentInstance = (instance) => {
      currentInstance = instance;
      instance.scope.on();
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      currentInstance = null;
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          }
        }));
      }
    }
    function fetchProxy(params) {
      let url;
      let rest;
      if (typeof params === "string") {
        url = params;
      } else {
        url = params.url;
        rest = params;
      }
      return fetch(url, rest).then((res) => {
        if (res.ok) {
          return res.json();
        }
        throw new Error(res.statusText);
      });
    }
    ({
      formatResult: (res) => res,
      requestMethod: fetchProxy,
      manual: false,
      onSuccess: () => {
      },
      onError: () => {
      },
      onFinally: () => {
      },
      defaultLoading: false,
      loadingDelay: 0,
      pollingInterval: 0,
      pollingWhenHidden: true,
      pollingSinceLastFinished: true,
      defaultParams: [],
      debounceInterval: 0,
      loadingWhenDebounceStart: true,
      throttleInterval: 0,
      initialData: void 0,
      ready: ref(true),
      throwOnError: false,
      refreshDeps: [],
      refreshOnWindowFocus: false
    });
    var MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index2) {
          if (entry[0] === key) {
            result = index2;
            return true;
          }
          return false;
        });
        return result;
      }
      return function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key) {
          var index2 = getIndex(this.__entries__, key);
          var entry = this.__entries__[index2];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key, value) {
          var index2 = getIndex(this.__entries__, key);
          if (~index2) {
            this.__entries__[index2][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        class_1.prototype.delete = function(key) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        class_1.prototype.has = function(key) {
          return !!~getIndex(this.__entries__, key);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }();
    }();
    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    var global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    var requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    var trailingTimeout = 2;
    function throttle$1(callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }
        if (trailingCall) {
          proxy();
        }
      }
      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          }
          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
      }
      return proxy;
    }
    var REFRESH_DELAY = 20;
    var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    var mutationObserverSupported = typeof MutationObserver !== "undefined";
    var ResizeObserverController = function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index2 = observers2.indexOf(observer);
        if (~index2) {
          observers2.splice(index2, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key) {
          return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }();
    var defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    var getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    var emptyRect = createRectInit(0, 0, 0, 0);
    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function(size2, position) {
        var value = styles["border-" + position + "-width"];
        return size2 + toFloat(value);
      }, 0);
    }
    function getPaddings(styles) {
      var positions = ["top", "right", "bottom", "left"];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles["padding-" + position];
        paddings[position] = toFloat(value);
      }
      return paddings;
    }
    function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
    }
    function getHTMLElementContentRect(target) {
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      if (!clientWidth && !clientHeight) {
        return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      var width = toFloat(styles.width), height = toFloat(styles.height);
      if (styles.boxSizing === "border-box") {
        if (Math.round(width + horizPad) !== clientWidth) {
          width -= getBordersSize(styles, "left", "right") + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
          height -= getBordersSize(styles, "top", "bottom") + vertPad;
        }
      }
      if (!isDocumentElement(target)) {
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        if (Math.abs(vertScrollbar) !== 1) {
          width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
          height -= horizScrollbar;
        }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
    }
    var isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
    }
    function getContentRect(target) {
      if (!isBrowser) {
        return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
    }
    function createReadOnlyRect(_a) {
      var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      defineConfigurable(rect, {
        x,
        y,
        width,
        height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
      });
      return rect;
    }
    function createRectInit(x, y, width, height) {
      return { x, y, width, height };
    }
    var ResizeObservation = function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }();
    var ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }();
    var ResizeObserverSPI = function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }();
    var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    var ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (!(this instanceof ResizeObserver2)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver2;
    }();
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method) {
      ResizeObserver.prototype[method] = function() {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
      };
    });
    var index$1 = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver;
    }();
    function useSize(target, options) {
      const size2 = reactive({
        width: void 0,
        height: void 0
      });
      const onSizeChange = options == null ? void 0 : options.onChange;
      safeOnMounted(() => {
        const targetElement = getTargetElement(target);
        if (!targetElement) {
          return;
        }
        const resizeObserver = new index$1((entries) => {
          entries.forEach((entry) => {
            Object.assign(size2, {
              width: entry.target.clientWidth,
              height: entry.target.clientHeight
            });
            onSizeChange && onSizeChange(size2);
          });
        });
        resizeObserver.observe(targetElement);
        onUnmounted(() => {
          resizeObserver.disconnect();
        });
      });
      return size2;
    }
    var shams = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = shams;
    var hasSymbols$1 = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr$1 = Object.prototype.toString;
    var funcType = "[object Function]";
    var implementation$1 = function bind3(that) {
      var target = this;
      if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs.push("$" + i2);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
    var implementation = implementation$1;
    var functionBind = Function.prototype.bind || implementation;
    var bind$1 = functionBind;
    var src$1 = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
    var undefined$1;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError$1 = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError$1();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols2 = hasSymbols$1();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
      "%AsyncFromSyncIteratorPrototype%": undefined$1,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
      "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError$1,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = functionBind;
    var hasOwn$1 = src$1;
    var $concat = bind2.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
    var $replace = bind2.call(Function.call, String.prototype.replace);
    var $strSlice = bind2.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first = $strSlice(string2, 0, 1);
      var last = $strSlice(string2, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match2, number2, quote2, subString) {
        result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number2 || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn$1(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    var getIntrinsic = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError$1("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError$1('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn$1(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
    var callBind$1 = { exports: {} };
    (function(module2) {
      var bind3 = functionBind;
      var GetIntrinsic3 = getIntrinsic;
      var $apply = GetIntrinsic3("%Function.prototype.apply%");
      var $call = GetIntrinsic3("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
      var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
      var $max = GetIntrinsic3("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind2(originalFunction) {
        var func = $reflectApply(bind3, $call, arguments);
        if ($gOPD2 && $defineProperty) {
          var desc = $gOPD2(func, "length");
          if (desc.configurable) {
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind3, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    })(callBind$1);
    var GetIntrinsic$1 = getIntrinsic;
    var callBind = callBind$1.exports;
    var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
    var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic$1(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
    var __viteBrowserExternal = {};
    var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      "default": __viteBrowserExternal
    });
    var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    hasWeakRef ? WeakRef.prototype.deref : null;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var inspectCustom = require$$0.custom;
    inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var GetIntrinsic2 = getIntrinsic;
    var callBound = callBound$1;
    GetIntrinsic2("%TypeError%");
    GetIntrinsic2("%WeakMap%", true);
    GetIntrinsic2("%Map%", true);
    callBound("WeakMap.prototype.get", true);
    callBound("WeakMap.prototype.set", true);
    callBound("WeakMap.prototype.has", true);
    callBound("Map.prototype.get", true);
    callBound("Map.prototype.set", true);
    callBound("Map.prototype.has", true);
    (function() {
      var array2 = [];
      for (var i2 = 0; i2 < 256; ++i2) {
        array2.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
      }
      return array2;
    })();
    var WORKER_STATUS;
    (function(WORKER_STATUS2) {
      WORKER_STATUS2["PENDING"] = "PENDING";
      WORKER_STATUS2["SUCCESS"] = "SUCCESS";
      WORKER_STATUS2["RUNNING"] = "RUNNING";
      WORKER_STATUS2["ERROR"] = "ERROR";
      WORKER_STATUS2["TIMEOUT_EXPIRED"] = "TIMEOUT_EXPIRED";
    })(WORKER_STATUS || (WORKER_STATUS = {}));
    var TRANSFERABLE_TYPE;
    (function(TRANSFERABLE_TYPE2) {
      TRANSFERABLE_TYPE2["AUTO"] = "auto";
      TRANSFERABLE_TYPE2["NONE"] = "none";
    })(TRANSFERABLE_TYPE || (TRANSFERABLE_TYPE = {}));
    ({
      timeout: void 0,
      remoteDependencies: [],
      autoTerminate: true,
      transferable: TRANSFERABLE_TYPE.AUTO
    });
    const isMacOS = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    const ShortcutMap = {
      SwitchDisplayMode: {
        key: isMacOS ? "meta.e" : "ctrl.shift.e",
        title: $t("SwitchDisplayMode"),
        value: isMacOS ? "\u2318 + E" : "Ctrl + Shift + E"
      },
      SwitchMaterialPanel: {
        key: isMacOS ? "meta.b" : "ctrl.b",
        title: $t("SwitchMaterialPanel"),
        value: isMacOS ? "\u2318 + B" : "Ctrl + B"
      },
      SwitchConfigPanel: {
        key: isMacOS ? "meta.shift.g" : "ctrl.shift.g",
        title: $t("SwitchConfigPanel"),
        value: isMacOS ? "\u2318 + Shift + G" : "Ctrl + Shift + G"
      },
      location: {
        key: isMacOS ? "meta.l" : "ctrl.l",
        title: $t("location"),
        value: isMacOS ? "\u2318 + L" : "Ctrl + L"
      },
      undo: {
        key: isMacOS ? "meta.z" : "ctrl.z",
        title: $t("undo"),
        value: isMacOS ? "\u2318 + Z" : "Ctrl + Z"
      },
      redo: {
        key: isMacOS ? "meta.shift.z" : "ctrl.shift.z",
        title: $t("redo"),
        value: isMacOS ? "\u2318 + Shift + Z" : "Ctrl + Shift + Z"
      },
      delete: {
        key: isMacOS ? "meta.delete" : "ctrl.delete",
        title: $t("delete"),
        value: isMacOS ? "\u2318 + Delete" : "Ctrl + Delete"
      },
      copyComponent: {
        key: isMacOS ? "meta.shift.c" : "ctrl.shift.c",
        title: $t("copyComponent"),
        value: isMacOS ? "\u2318 + Shift + C" : "Ctrl + Shift + C"
      },
      saveProject: {
        key: isMacOS ? "meta.s" : "ctrl.s",
        title: $t("saveProject"),
        value: isMacOS ? "\u2318 + S" : "Ctrl + S"
      },
      cut: {
        key: isMacOS ? "meta.x" : "ctrl.x",
        title: $t("cut"),
        value: isMacOS ? "\u2318 + X" : "Ctrl + X"
      },
      copyToClipboard: {
        key: isMacOS ? "meta.c" : "ctrl.c",
        title: $t("copyToClipboard"),
        value: isMacOS ? "\u2318 + C" : "Ctrl + C"
      },
      paste: {
        key: isMacOS ? "meta.v" : "ctrl.v",
        title: $t("paste"),
        value: isMacOS ? "\u2318 + V" : "Ctrl + V"
      },
      pasteToInside: {
        key: isMacOS ? "meta.shift.v" : "ctrl.shift.v",
        title: $t("pasteToInside"),
        value: isMacOS ? "\u2318 + Shift + V" : "Ctrl + Shift + V"
      },
      saveMaterial: {
        key: isMacOS ? "meta.shift.s" : "ctrl.shift.s",
        title: $t("saveMaterial"),
        value: isMacOS ? "\u2318 + Shift + S" : "Ctrl + Shift + S"
      },
      switchDevice: {
        key: (e) => (isMacOS ? e.metaKey : e.ctrlKey) && e.key === "/",
        title: $t("switchDevice"),
        value: isMacOS ? "\u2318 + /" : "Ctrl + /"
      },
      collapseAll: {
        key: (e) => (isMacOS ? e.metaKey : e.ctrlKey) && (isMacOS ? e.shiftKey : e.altKey) && e.key === ".",
        title: $t("collapseAll"),
        value: isMacOS ? "\u2318 + Shift + ." : "Ctrl + Alt + ."
      },
      switchSection: {
        key: (e) => (isMacOS ? e.metaKey : e.ctrlKey) && (isMacOS ? e.shiftKey : e.altKey) && /\d/.test(e.key),
        title: $t("switchSection"),
        value: isMacOS ? "\u2318 + Shift + {\u6570\u5B57\u952E}" : "Ctrl + Alt + {\u6570\u5B57\u952E}"
      },
      nextSection: {
        key: isMacOS ? "alt.down" : "alt.down",
        title: $t("nextSection"),
        value: isMacOS ? "\u2325 + \u2193" : "Alt + \u2193"
      },
      prevSection: {
        key: isMacOS ? "alt.up" : "alt.up",
        title: $t("prevSection"),
        value: isMacOS ? "\u2325 + \u2191" : "Alt + \u2191"
      },
      nextComponent: {
        key: isMacOS ? "meta.shift.right" : "ctrl.shift.right",
        title: $t("nextComponent"),
        value: isMacOS ? "\u2318 + Shift + \u2192" : "Ctrl + Shift + \u2192"
      },
      prevComponent: {
        key: isMacOS ? "meta.shift.left" : "ctrl.shift.left",
        title: $t("prevComponent"),
        value: isMacOS ? "\u2318 + Shift + \u2190" : "Ctrl + Shift + \u2190"
      },
      parentComponent: {
        key: isMacOS ? "meta.shift.up" : "ctrl.shift.up",
        title: $t("parentComponent"),
        value: isMacOS ? "\u2318 + Shift + \u2191" : "Ctrl + Shift + \u2191"
      },
      childrenComponent: {
        key: isMacOS ? "meta.shift.down" : "ctrl.shift.down",
        title: $t("childrenComponent"),
        value: isMacOS ? "\u2318 + Shift + \u2193" : "Ctrl + Shift + \u2193"
      },
      switchShortcut: {
        key: isMacOS ? "meta.shift.p" : "ctrl.shift.p",
        title: $t("switchShortcut"),
        value: isMacOS ? "\u2318 + Shift + P" : "Ctrl + Shift + P"
      }
    };
    const ShortcutKey = Object.fromEntries(Object.entries(ShortcutMap).map(([key, map]) => [key, map.key]));
    const _hoisted_1$o = { class: "tree-node-info-name" };
    const _hoisted_2$h = ["title"];
    const _hoisted_3$f = { class: "tree-node-children" };
    const _sfc_main$q = /* @__PURE__ */ defineComponent({
      __name: "TreeNode",
      props: {
        node: null,
        preview: { type: Boolean }
      },
      setup(__props) {
        const displayStore = useDisplayStore();
        const { layerStatus } = storeToRefs(displayStore);
        const pageStore = usePageStore();
        const { activeNode, activeParentChain } = storeToRefs(pageStore);
        const { setActiveNodeHide, setActiveNode, deleteActiveNode, copyActiveNode, separateActiveNode } = pageStore;
        let collapse = ref(!!layerStatus.value.get(__props.node));
        const isActive = computed(() => activeNode.value === __props.node);
        const canCollapse = computed(() => {
          var _a;
          return ((_a = __props.node.children) == null ? void 0 : _a.length) && !__props.node.isModule;
        });
        const isHide = computed(() => {
          var _a;
          return (_a = useConfigProps(__props.node).common) == null ? void 0 : _a.hide;
        });
        const icon = computed(() => {
          if (__props.node.type === "section") {
            return "circle";
          }
          if (__props.node.isModule) {
            return "module";
          }
          return {
            Image: "image",
            Text: "text",
            Block: "block",
            Icon: "symbol"
          }[__props.node.component];
        });
        watch(() => collapse.value, (val) => layerStatus.value.set(__props.node, val));
        watch([activeNode], () => {
          if (activeNode.value && activeParentChain.value.some((n) => n === __props.node)) {
            collapse.value = true;
          }
        }, { immediate: true, flush: "post" });
        return (_ctx, _cache) => {
          const _component_TreeNode = resolveComponent("TreeNode", true);
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["tree-node", { collapse: unref$1(collapse), active: __props.preview ? false : isActive.value }])
          }, [
            canCollapse.value && !__props.preview ? (openBlock(), createBlock(Icon$1, {
              key: 0,
              class: "collapse-btn",
              name: "caret-down",
              size: 10,
              onClick: _cache[0] || (_cache[0] = ($event) => isRef$1(collapse) ? collapse.value = !unref$1(collapse) : collapse = !unref$1(collapse))
            })) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "tree-node-info",
              onClick: _cache[5] || (_cache[5] = () => !__props.preview && unref$1(setActiveNode)(__props.node))
            }, [
              createVNode(Icon$1, {
                class: "tree-node-info-icon",
                name: icon.value,
                size: 12
              }, null, 8, ["name"]),
              createBaseVNode("div", _hoisted_1$o, [
                createBaseVNode("div", {
                  class: "tree-node-info-name-text",
                  title: __props.node.name
                }, toDisplayString(__props.node.name), 9, _hoisted_2$h),
                isHide.value ? (openBlock(), createBlock(Icon$1, {
                  key: 0,
                  class: "tree-node-info-name-icon",
                  name: "hide",
                  size: 10,
                  onClick: _cache[1] || (_cache[1] = ($event) => unref$1(setActiveNodeHide)(false))
                })) : createCommentVNode("", true)
              ]),
              unref$1(activeNode) === __props.node && !__props.preview ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                unref$1(activeNode).isModule ? withDirectives((openBlock(), createBlock(Icon$1, {
                  key: 0,
                  class: "tree-node-info-op-icon separate-icon",
                  name: "separate",
                  size: 10,
                  onClick: _cache[2] || (_cache[2] = () => {
                    unref$1(separateActiveNode)();
                    isRef$1(collapse) ? collapse.value = true : collapse = true;
                  })
                }, null, 512)), [
                  [_directive_tooltip, _ctx.$t("ungroup")]
                ]) : createCommentVNode("", true),
                !isHide.value ? withDirectives((openBlock(), createBlock(Icon$1, {
                  key: 1,
                  class: "tree-node-info-op-icon eye-slash-icon",
                  name: "eye-slash",
                  size: 13,
                  onClick: _cache[3] || (_cache[3] = ($event) => unref$1(setActiveNodeHide)(true))
                }, null, 512)), [
                  [_directive_tooltip, _ctx.$t("hidden")]
                ]) : createCommentVNode("", true),
                isHide.value ? withDirectives((openBlock(), createBlock(Icon$1, {
                  key: 2,
                  class: "tree-node-info-op-icon eye-icon",
                  name: "eye",
                  size: 13,
                  onClick: _cache[4] || (_cache[4] = ($event) => unref$1(setActiveNodeHide)(false))
                }, null, 512)), [
                  [_directive_tooltip, _ctx.$t("visible")]
                ]) : createCommentVNode("", true),
                withDirectives(createVNode(Icon$1, {
                  class: "tree-node-info-op-icon copy-icon",
                  name: "copy",
                  size: 10,
                  onClick: withModifiers(unref$1(copyActiveNode), ["stop"])
                }, null, 8, ["onClick"]), [
                  [_directive_tooltip, _ctx.$t("copy")]
                ]),
                withDirectives(createVNode(Icon$1, {
                  class: "tree-node-info-op-icon delete-icon",
                  name: "delete",
                  size: 10,
                  onClick: withModifiers(unref$1(deleteActiveNode), ["stop"])
                }, null, 8, ["onClick"]), [
                  [_directive_tooltip, _ctx.$t("delete")]
                ])
              ], 64)) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_3$f, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.node.children, (child) => {
                return withDirectives((openBlock(), createBlock(_component_TreeNode, {
                  preview: __props.preview,
                  key: child.name,
                  node: child
                }, null, 8, ["preview", "node"])), [
                  [vShow, __props.preview || canCollapse.value && unref$1(collapse)]
                ]);
              }), 128))
            ])
          ], 2);
        };
      }
    });
    const TreeNode_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$n = ["id"];
    const _hoisted_2$g = { class: "modal-content-header" };
    const _hoisted_3$e = {
      key: 0,
      class: "modal-content-header-title"
    };
    const __default__$3 = {
      inheritAttrs: false
    };
    const _sfc_main$p = /* @__PURE__ */ defineComponent({
      ...__default__$3,
      __name: "Modal",
      props: {
        width: null,
        modelValue: { type: Boolean },
        title: null,
        closeOnClickMask: { type: Boolean },
        uniqId: null,
        showClose: { type: Boolean, default: true },
        onHide: null
      },
      setup(__props, { expose }) {
        const onUpdate = useAttrs()["onUpdate:modelValue"];
        const handleClose = () => {
          var _a;
          if (((_a = __props.onHide) == null ? void 0 : _a.call(__props)) === true)
            return;
          onUpdate == null ? void 0 : onUpdate(false);
        };
        expose({
          hide: handleClose
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, { to: "body" }, [
            createVNode(Transition, { name: "modal-fade" }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  class: normalizeClass(["modal-wrapper"]),
                  id: __props.uniqId
                }, [
                  createBaseVNode("div", {
                    class: "modal-mask",
                    onClick: _cache[0] || (_cache[0] = () => __props.closeOnClickMask && handleClose())
                  }),
                  createBaseVNode("div", mergeProps({
                    class: ["modal-content"],
                    style: { width: __props.width ? `${__props.width}` : "" }
                  }, _ctx.$attrs), [
                    createBaseVNode("div", _hoisted_2$g, [
                      __props.title ? (openBlock(), createElementBlock("div", _hoisted_3$e, toDisplayString(__props.title), 1)) : createCommentVNode("", true)
                    ]),
                    __props.showClose ? (openBlock(), createBlock(Icon$1, {
                      key: 0,
                      name: "close",
                      type: "btn",
                      size: 20,
                      class: "modal-content-close",
                      onClick: handleClose
                    })) : createCommentVNode("", true),
                    renderSlot(_ctx.$slots, "default", { hide: handleClose }, void 0, true)
                  ], 16)
                ], 8, _hoisted_1$n), [
                  [vShow, __props.modelValue]
                ])
              ]),
              _: 3
            })
          ]);
        };
      }
    });
    const Modal_vue_vue_type_style_index_0_scoped_c61309c3_lang = "";
    const Modal_vue_vue_type_style_index_1_lang = "";
    const Modal$1 = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-c61309c3"]]);
    const maxSnapshotWidth = 1200;
    const maxSnapshotHeight = 800;
    const createMaterialSnapshot = (el, options) => {
      let { width, height } = el.getBoundingClientRect();
      let scale = 1;
      if (width > height && width > maxSnapshotWidth) {
        scale = maxSnapshotWidth / width;
      }
      if (height > width && height > maxSnapshotHeight) {
        scale = maxSnapshotHeight / height;
      }
      return html2canvas(el, {
        scale,
        useCORS: true,
        ignoreElements: (elem) => {
          if (elem.classList.contains("moveable-control-box")) {
            return true;
          }
          return false;
        },
        onclone: (document2) => {
          const activeElements = document2.querySelector(".edit-content");
          activeElements.style.transform = "";
        },
        ...options
      }).then((canvas) => {
        return canvas.toDataURL("image/png", 1);
      });
    };
    let JSONEditor = null;
    const getJSONEditor = async () => {
      if (JSONEditor)
        return JSONEditor;
      JSONEditor = (await __vitePreload(() => import("./jsoneditor.1c760790.js").then((n) => n.j), true ? ["assets/jsoneditor.1c760790.js","assets/lodash.f70a6700.js"] : void 0)).default;
    };
    const createJSONEditor = async (querySelector) => {
      await getJSONEditor();
      if (!JSONEditor) {
        console.error("jsoneditor load failed");
        return;
      }
      const elem = document.querySelector(querySelector);
      if (!elem)
        return;
      return new JSONEditor(elem, {
        mode: "text",
        mainMenuBar: false,
        navigationBar: false,
        statusBar: false
      });
    };
    const _hoisted_1$m = {
      key: 0,
      class: "info-wrapper"
    };
    const _hoisted_2$f = { class: "info" };
    const _hoisted_3$d = {
      key: 0,
      class: "module-config-wrapper"
    };
    const _hoisted_4$7 = /* @__PURE__ */ createBaseVNode("div", { class: "module-input module-config" }, null, -1);
    const _hoisted_5$7 = /* @__PURE__ */ createBaseVNode("div", { class: "module-dependence-wrapper" }, [
      /* @__PURE__ */ createBaseVNode("div", { class: "module-input module-dependence" })
    ], -1);
    const _hoisted_6$6 = { class: "btn-wrapper" };
    const _hoisted_7$4 = { class: "btn-wrapper-left" };
    const __default__$2 = {
      inheritAttrs: true
    };
    const _sfc_main$o = /* @__PURE__ */ defineComponent({
      ...__default__$2,
      __name: "SaveMaterialModal",
      props: {
        modelValue: { type: Boolean },
        material: null,
        autoCreateCover: { type: Boolean },
        actionText: { default: () => $t("save") },
        hideCreateCover: { type: Boolean },
        onSave: null
      },
      setup(__props) {
        const pageStore = usePageStore();
        const { colorVars } = storeToRefs(pageStore);
        const { fetchSaveMaterial } = pageStore;
        const userStore = useUserStore();
        const { isAdmin } = storeToRefs(userStore);
        let editItem = ref(null);
        let coverLoading = ref(!!__props.autoCreateCover);
        let moduleConfigEditor = ref(null);
        let moduleDependenceElemEditor = ref(null);
        let modal = ref(null);
        const isTemplate = computed(() => {
          var _a;
          return ((_a = __props.material) == null ? void 0 : _a.type) === "template";
        });
        const node = computed(() => {
          var _a;
          return isTemplate.value ? null : (_a = editItem.value) == null ? void 0 : _a.node;
        });
        const isModule = computed({
          get() {
            var _a;
            return !isTemplate.value && ((_a = node.value) == null ? void 0 : _a.isModule) || false;
          },
          set(val) {
            var _a;
            if (!((_a = editItem.value) == null ? void 0 : _a.node))
              return;
            if (val)
              nextTick$1(() => initJSONEditor());
            editItem.value.node.isModule = val;
          }
        });
        const initJSONEditor = async () => {
          var _a;
          if (!editItem.value || !node.value || !isAdmin)
            return;
          moduleConfigEditor.value = await createJSONEditor(".module-config");
          if (!moduleConfigEditor.value)
            return;
          moduleConfigEditor.value.set(node.value.moduleConfig && ((_a = node.value.moduleConfig) == null ? void 0 : _a.length) > 0 ? node.value.moduleConfig : [
            {
              title: "\u6807\u9898",
              titleEn: "Title",
              icon: "basic",
              defaultCollapsed: true,
              data: [
                {
                  type: "text",
                  label: "\u6587\u672C",
                  labelEn: "Text",
                  props: { type: "textarea" },
                  sourceValue: "children[0].config.props.basic.text",
                  targetValue: "children[0].config.props.basic.text"
                }
              ]
            }
          ]);
        };
        const initJSONDependence = async () => {
          if (!editItem.value || !node.value || !isAdmin)
            return;
          moduleDependenceElemEditor.value = await createJSONEditor(".module-dependence");
          if (!moduleDependenceElemEditor.value)
            return;
          moduleDependenceElemEditor.value.set(node.value.moduleDependence || {
            customFontFace: "",
            colorVars: colorVars.value
          });
        };
        const handleCreateCover = async () => {
          if (!node.value || !editItem.value)
            return;
          try {
            coverLoading.value = true;
            const elem = document.querySelector(`[data-name="${node.value.name}"]`);
            if (!elem)
              return;
            const cover = await createMaterialSnapshot(elem);
            if (cover.length >= 1e4) {
              const url = await uploadByBase64(cover);
              editItem.value.cover = url;
            } else {
              editItem.value.cover = cover;
            }
          } finally {
            coverLoading.value = false;
          }
        };
        watch(() => [__props.material, __props.modelValue], async () => {
          var _a, _b;
          if (__props.material && __props.modelValue) {
            editItem.value = cloneDeep(__props.material);
            nextTick$1(() => {
              initJSONEditor();
              initJSONDependence();
            });
            if (__props.autoCreateCover) {
              await handleCreateCover();
            }
          } else {
            editItem.value = null;
            (_a = moduleConfigEditor.value) == null ? void 0 : _a.destroy();
            (_b = moduleDependenceElemEditor.value) == null ? void 0 : _b.destroy();
          }
        }, { immediate: true });
        const handleSave = async () => {
          var _a, _b, _c, _d, _e;
          if (!((_a = editItem.value) == null ? void 0 : _a.name)) {
            AlertError($t("nameRequired"));
            return;
          }
          const data2 = await fetchSaveMaterial({
            ...editItem.value,
            node: isTemplate.value ? void 0 : {
              ...node.value,
              isModule: ((_b = node.value) == null ? void 0 : _b.isModule) || false,
              moduleConfig: ((_c = node.value) == null ? void 0 : _c.isModule) && moduleConfigEditor.value ? moduleConfigEditor.value.get() : [],
              moduleDependence: moduleDependenceElemEditor.value ? moduleDependenceElemEditor.value.get() : null
            }
          });
          (_d = __props.onSave) == null ? void 0 : _d.call(__props, data2);
          Alert($t("saveSuccess"));
          (_e = modal.value) == null ? void 0 : _e.hide();
        };
        const handleTreeNodeClick = (e) => {
          let targetElem = e.target;
          let list = [];
          while (targetElem && !targetElem.classList.contains("node-tree")) {
            if (targetElem.classList.contains("tree-node")) {
              list.unshift(Array.from(targetElem.parentElement.children).indexOf(targetElem));
            }
            targetElem = targetElem.parentElement;
          }
          list.shift();
          setClipboard(list.map((i2) => `children[${i2}]`).join("."));
        };
        const setClipboard = async (text) => {
          await copyToClipboard(text);
          Alert("copy to clipboard: " + text);
        };
        const handleStatusChange = (bool) => {
          if (!editItem.value)
            return;
          editItem.value.status = bool ? DataStatus.Normal : DataStatus.Hidden;
        };
        const titleMap = {
          template: $t("template"),
          component: $t("component"),
          section: $t("section")
        };
        const setValue = (key, value) => {
          if (!editItem.value)
            return;
          editItem.value[key] = value;
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Modal$1, mergeProps({
            ref_key: "modal",
            ref: modal,
            class: "save-modal",
            title: `${__props.actionText} ${titleMap[__props.material.type]}`,
            width: "70vw",
            "close-on-click-mask": "",
            "model-value": __props.modelValue
          }, _ctx.$attrs), {
            default: withCtx(() => [
              editItem.value ? (openBlock(), createElementBlock("div", _hoisted_1$m, [
                createBaseVNode("div", _hoisted_2$f, [
                  createVNode(InputItem, {
                    label: unref$1($t)("name"),
                    modelValue: editItem.value.name,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => editItem.value.name = $event)
                  }, null, 8, ["label", "modelValue"]),
                  unref$1(isAdmin) ? (openBlock(), createBlock(InputItem, {
                    key: 0,
                    label: unref$1($t)("nameEn"),
                    "model-value": editItem.value.enName || "",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = (val) => setValue("enName", val))
                  }, null, 8, ["label", "model-value"])) : createCommentVNode("", true),
                  !isTemplate.value ? (openBlock(), createBlock(InputItem, {
                    key: 1,
                    label: unref$1($t)("category"),
                    "model-value": editItem.value.category || "",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (val) => setValue("category", val))
                  }, null, 8, ["label", "model-value"])) : createCommentVNode("", true),
                  unref$1(isAdmin) && !isTemplate.value ? (openBlock(), createBlock(InputItem, {
                    key: 2,
                    label: unref$1($t)("categoryEn"),
                    "model-value": editItem.value.categoryEn || "",
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (val) => setValue("categoryEn", val))
                  }, null, 8, ["label", "model-value"])) : createCommentVNode("", true),
                  unref$1(isAdmin) && !isTemplate.value ? (openBlock(), createBlock(SwitchItem, {
                    key: 3,
                    label: unref$1($t)("moduleSwitch"),
                    modelValue: isModule.value,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isModule.value = $event)
                  }, null, 8, ["label", "modelValue"])) : createCommentVNode("", true)
                ]),
                createVNode(ImageItem, {
                  "hide-label": "",
                  loading: coverLoading.value,
                  "wrapper-class": "image-item",
                  rows: 5,
                  "model-value": editItem.value.cover || "",
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = (val) => setValue("cover", val))
                }, null, 8, ["loading", "model-value"])
              ])) : createCommentVNode("", true),
              unref$1(isAdmin) && !isTemplate.value ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "module-setting-wrapper",
                onKeydown: _cache[6] || (_cache[6] = withModifiers(() => {
                }, ["stop"]))
              }, [
                isModule.value ? (openBlock(), createElementBlock("div", _hoisted_3$d, [
                  _hoisted_4$7,
                  node.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "node-tree",
                    onClick: handleTreeNodeClick
                  }, [
                    createVNode(_sfc_main$q, {
                      node: node.value,
                      preview: true
                    }, null, 8, ["node"])
                  ])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                _hoisted_5$7
              ], 32)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$6, [
                createBaseVNode("div", _hoisted_7$4, [
                  !__props.hideCreateCover ? (openBlock(), createBlock(Btn, {
                    key: 0,
                    class: "create-cover-btn",
                    type: "text",
                    size: "sm",
                    onClick: handleCreateCover
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref$1($t)("autoCreateCover")), 1)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                unref$1(isAdmin) && editItem.value ? (openBlock(), createBlock(Switch, {
                  key: 0,
                  "model-value": !editItem.value.status || editItem.value.status === unref$1(DataStatus).Normal,
                  "onUpdate:modelValue": handleStatusChange
                }, null, 8, ["model-value"])) : createCommentVNode("", true),
                createVNode(Btn, {
                  class: "save-btn",
                  type: "inner",
                  text: unref$1($t)("save"),
                  onClick: handleSave
                }, null, 8, ["text"])
              ])
            ]),
            _: 1
          }, 16, ["title", "model-value"]);
        };
      }
    });
    const SaveMaterialModal_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$l = { class: "modal-msg" };
    const _hoisted_2$e = { class: "btn-group" };
    const _hoisted_3$c = {
      key: 0,
      class: "extra-link-wrapper"
    };
    const __default__$1 = {
      inheritAttrs: true
    };
    const _sfc_main$n = /* @__PURE__ */ defineComponent({
      ...__default__$1,
      __name: "ConfirmModal",
      props: {
        title: null,
        msg: null,
        extraLink: { default: "" },
        onExtraLinkClick: { type: Function, default: null },
        okText: { default: () => $t("ok") },
        cancelText: { default: () => $t("cancel") },
        onOk: null,
        onCancel: null
      },
      setup(__props, { expose }) {
        let modal = ref(null);
        expose({});
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Modal$1, mergeProps({
            ref_key: "modal",
            ref: modal,
            class: "confirm-modal",
            title: __props.title
          }, _ctx.$attrs), {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$l, [
                createBaseVNode("div", null, toDisplayString(__props.msg), 1)
              ]),
              createBaseVNode("div", _hoisted_2$e, [
                __props.extraLink ? (openBlock(), createElementBlock("div", _hoisted_3$c, [
                  createVNode(Btn, {
                    type: "text",
                    size: "sm",
                    class: "extra-link",
                    onClick: __props.onExtraLinkClick
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(__props.extraLink), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ])) : createCommentVNode("", true),
                createVNode(Btn, {
                  class: "cancel-btn",
                  type: "btn",
                  size: "sm",
                  color: "default",
                  onClick: _cache[0] || (_cache[0] = () => {
                    var _a, _b;
                    (_a = __props.onCancel) == null ? void 0 : _a.call(__props);
                    (_b = modal.value) == null ? void 0 : _b.hide();
                  })
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(__props.cancelText), 1)
                  ]),
                  _: 1
                }),
                createVNode(Btn, {
                  class: "ok-btn",
                  type: "btn",
                  size: "sm",
                  onClick: _cache[1] || (_cache[1] = () => {
                    var _a, _b;
                    (_a = __props.onOk) == null ? void 0 : _a.call(__props);
                    (_b = modal.value) == null ? void 0 : _b.hide();
                  })
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(__props.okText), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 16, ["title"]);
        };
      }
    });
    const ConfirmModal_vue_vue_type_style_index_0_lang = "";
    const _Modal = class {
      static confirm(msg, options) {
        return new Promise((res) => {
          const id = "__modal__" + _Modal.id++;
          let vnode = createVNode(_sfc_main$n, {
            msg,
            showClose: false,
            onOk: () => res(true),
            onCancel: () => res(false),
            ...options,
            modelValue: true,
            uniqId: id,
            "onUpdate:modelValue": () => destroy()
          });
          render$1m(vnode, document.body);
          const destroy = () => {
            const elem = document.getElementById(id);
            document.body.removeChild(elem);
            render$1m(null, document.body);
            vnode = null;
          };
        });
      }
    };
    let Modal = _Modal;
    __publicField(Modal, "id", 0);
    const _withScopeId$2 = (n) => (pushScopeId("data-v-4a0055ab"), n = n(), popScopeId(), n);
    const _hoisted_1$k = { class: "config-mini-main" };
    const _hoisted_2$d = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "top" }, null, -1));
    const _hoisted_3$b = {
      key: 0,
      class: "mini-content"
    };
    const _hoisted_4$6 = {
      key: 1,
      class: "bottom"
    };
    const _hoisted_5$6 = { class: "config-main" };
    const _hoisted_6$5 = { key: 0 };
    const _hoisted_7$3 = { class: "header" };
    const _hoisted_8$3 = { class: "op-icon-wrapper" };
    const _hoisted_9$3 = { class: "link-btn-wrapper" };
    const _hoisted_10$2 = ["onClick"];
    const _hoisted_11$2 = { class: "content" };
    const _hoisted_12$2 = {
      key: 1,
      class: "layers"
    };
    const _hoisted_13$2 = { class: "header" };
    const _hoisted_14$2 = { class: "title" };
    const _hoisted_15$1 = { class: "content layers-content" };
    const _sfc_main$m = /* @__PURE__ */ defineComponent({
      __name: "ConfigSection",
      setup(__props) {
        const pageStore = usePageStore();
        const { nameMap, pageData, activeNode, activeNodeGroups, activeNodeHide, setting } = storeToRefs(pageStore);
        const {
          unlinkActiveNodeProp,
          switchActiveNodeConfigMode,
          getAllTags,
          setActiveNode,
          deleteActiveNode,
          copyActiveNode,
          separateActiveNode,
          setActiveNodeHide,
          getMaterialByMaterialId,
          changeNodeName,
          syncNodeModuleConfig
        } = pageStore;
        const displayStore = useDisplayStore();
        const { minimize, deviceType } = storeToRefs(displayStore);
        const { setMinimize } = displayStore;
        const userStore = useUserStore();
        const { isAdmin } = storeToRefs(userStore);
        let showLayer = ref(false);
        let showSaveMaterialModal = ref(false);
        let curMaterial = ref(null);
        let saveCallback = ref(null);
        const handleActiveNodeChange = async (event) => {
          const elem = event.target;
          elem.scrollLeft = 0;
          if (!activeNode.value)
            return;
          const newName = elem.innerText || "";
          if (newName === activeNode.value.name)
            return;
          if (!isValidName(newName) || !newName) {
            AlertError($t("nameValidTip"));
            elem.innerText = activeNode.value.name;
            return;
          }
          if (nameMap.value[newName]) {
            AlertError($t("nameExistTip"));
            elem.innerText = activeNode.value.name;
            return;
          }
          changeNodeName(activeNode.value, newName);
        };
        const disabledUnlinkDropdown = computed(() => !activeNode.value || !activeNode.value.children || activeNode.value.children.length === 0);
        const handleUnlink = (includeChildren) => unlinkActiveNodeProp(includeChildren);
        const handleFocusLinkNode = () => {
          var _a;
          return activeNode.value && ((_a = activeNode.value) == null ? void 0 : _a.propLink) && nameMap.value[activeNode.value.propLink] && setActiveNode(nameMap.value[activeNode.value.propLink]);
        };
        const iconList = computed(() => {
          var _a;
          return [
            {
              noMini: true,
              name: "layers",
              tip: $t("layers"),
              click: () => showLayer.value = true
            },
            {
              hide: !((_a = activeNode.value) == null ? void 0 : _a.isModule),
              name: "separate",
              tip: $t("ungroup"),
              click: separateActiveNode
            },
            {
              hide: !!activeNodeHide.value,
              name: "eye-slash",
              tip: $t("hidden"),
              click: () => setActiveNodeHide(true)
            },
            {
              hide: !activeNodeHide.value,
              name: "eye",
              tip: $t("visible"),
              click: () => setActiveNodeHide(false)
            },
            {
              name: "save",
              tip: $t("save"),
              click: () => {
                openMaterialModal();
              }
            },
            {
              name: "copy",
              tip: $t("copy"),
              click: copyActiveNode
            },
            {
              name: "delete",
              tip: $t("delete"),
              click: deleteActiveNode
            },
            {
              hide: !isAdmin.value,
              name: "sync",
              tip: $t("sync"),
              click: syncNodeModuleConfig
            }
          ];
        });
        useKeyPress(ShortcutKey.saveMaterial, (e) => {
          if (!activeNode.value)
            return;
          openMaterialModal();
        });
        useKeyPress(ShortcutKey.SwitchConfigPanel, (e) => {
          e.preventDefault();
          setMinimize(!minimize.value);
        });
        useKeyPress(ShortcutKey.copyComponent, (e) => {
          e.preventDefault();
          copyActiveNode();
        });
        const openMaterialModal = async () => {
          if (!activeNode.value)
            return;
          let material;
          let id = "";
          if (activeNode.value.materialId) {
            material = getMaterialByMaterialId(activeNode.value.materialId);
            if (material && material.id) {
              if (await Modal.confirm($t("materialExistTipMsg", getMaterialName(material)), { title: $t("materialExistTip"), cancelText: $t("newMaterial") })) {
                id = material.id;
              }
            } else {
              activeNode.value.materialId = "";
            }
          }
          const node = activeNode.value;
          curMaterial.value = {
            id,
            name: material && material.name ? material.name : node.name,
            enName: material && material.enName ? material.enName : "",
            type: node.type,
            category: material && material.category ? material.category : "",
            categoryEn: material && material.categoryEn ? material.categoryEn : "",
            cover: (material && material.cover ? material.cover : node.cover) || "",
            node
          };
          saveCallback.value = !id ? (material2) => {
            if (!node)
              return;
            node.materialId = material2.id;
            showSaveMaterialModal.value = false;
          } : null;
          showSaveMaterialModal.value = true;
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["config-section", { minimize: unref$1(minimize) }])
          }, [
            createVNode(Icon$1, {
              class: "mini-btn",
              type: "circle",
              name: "down",
              size: 12,
              onClick: _cache[0] || (_cache[0] = ($event) => unref$1(setMinimize)(!unref$1(minimize)))
            }),
            createBaseVNode("div", _hoisted_1$k, [
              _hoisted_2$d,
              unref$1(activeNode) ? (openBlock(), createElementBlock("div", _hoisted_3$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(activeNodeGroups), (groupType, index2) => {
                  return openBlock(), createBlock(ConfigGroup, {
                    "group-type": groupType,
                    index: index2,
                    minimize: true,
                    key: groupType + unref$1(activeNode).name + index2 + "_mini"
                  }, null, 8, ["group-type", "index"]);
                }), 128))
              ])) : createCommentVNode("", true),
              unref$1(activeNode) ? (openBlock(), createElementBlock("div", _hoisted_4$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(iconList.value, (item, index2) => {
                  return openBlock(), createElementBlock(Fragment, { key: index2 }, [
                    !item.hide && !item.noMini ? withDirectives((openBlock(), createBlock(Icon$1, {
                      key: 0,
                      class: normalizeClass(["op-icon", `${item.name}-icon`]),
                      name: item.name,
                      size: 16,
                      onClick: item.click
                    }, null, 8, ["class", "name", "onClick"])), [
                      [_directive_tooltip, { content: item.tip, placement: "left" }]
                    ]) : createCommentVNode("", true)
                  ], 64);
                }), 128))
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_5$6, [
              unref$1(activeNode) && !showLayer.value ? (openBlock(), createElementBlock("div", _hoisted_6$5, [
                createBaseVNode("div", _hoisted_7$3, [
                  createBaseVNode("div", {
                    class: "title",
                    contenteditable: "true",
                    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((e) => {
                      var _a;
                      return (_a = e.target) == null ? void 0 : _a.blur();
                    }, ["stop"]), ["enter"])),
                    onBlur: handleActiveNodeChange
                  }, toDisplayString(unref$1(activeNode).name), 33)
                ]),
                createBaseVNode("div", _hoisted_8$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(iconList.value, (item, index2) => {
                    return withDirectives((openBlock(), createElementBlock("div", {
                      class: "op-icon-btn",
                      key: index2
                    }, [
                      withDirectives(createVNode(Icon$1, {
                        class: normalizeClass(["op-icon", `${item.name}-icon`]),
                        name: item.name,
                        size: 13,
                        onClick: item.click
                      }, null, 8, ["class", "name", "onClick"]), [
                        [_directive_tooltip, item.tip]
                      ])
                    ])), [
                      [vShow, !item.hide]
                    ]);
                  }), 128)),
                  createBaseVNode("div", _hoisted_9$3, [
                    unref$1(activeNode).propLink ? (openBlock(), createBlock(_sfc_main$X, {
                      key: 0,
                      type: "pure",
                      disabled: disabledUnlinkDropdown.value,
                      "popper-class": "link-dropdown",
                      placement: "bottom-end",
                      distance: 0,
                      skidding: -5
                    }, {
                      content: withCtx(() => [
                        createBaseVNode("div", {
                          class: "select-option",
                          onClick: _cache[3] || (_cache[3] = () => handleUnlink(false))
                        }, toDisplayString(unref$1($t)("unlinkSelf")), 1),
                        createBaseVNode("div", {
                          class: "select-option",
                          onClick: _cache[4] || (_cache[4] = () => handleUnlink(true))
                        }, toDisplayString(unref$1($t)("unlinkAll")), 1)
                      ]),
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          class: "op-icon-btn link-btn",
                          onClick: _cache[2] || (_cache[2] = () => disabledUnlinkDropdown.value ? handleUnlink(false) : null)
                        }, [
                          createVNode(Icon$1, {
                            name: unref$1(activeNode).propLink ? "link-broken" : "link",
                            size: 14
                          }, null, 8, ["name"]),
                          createTextVNode(" " + toDisplayString(unref$1($t)("unlink")), 1),
                          createBaseVNode("span", {
                            class: "link-text",
                            onClick: withModifiers(handleFocusLinkNode, ["stop"])
                          }, toDisplayString(unref$1(activeNode).propLink), 9, _hoisted_10$2)
                        ])
                      ]),
                      _: 1
                    }, 8, ["disabled"])) : createCommentVNode("", true)
                  ])
                ]),
                !unref$1(activeNode).isModule ? (openBlock(), createBlock(_sfc_main$r, {
                  key: 0,
                  tags: unref$1(activeNode).tags,
                  "auto-complete-tags": unref$1(getAllTags)(),
                  onChange: _cache[5] || (_cache[5] = (newTags) => unref$1(activeNode).tags = newTags)
                }, null, 8, ["tags", "auto-complete-tags"])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_11$2, [
                  unref$1(activeNode).isModule ? (openBlock(), createBlock(Tip, {
                    key: 0,
                    type: "warning",
                    message: unref$1($t)("ungroupNotify"),
                    block: "",
                    "no-radius": ""
                  }, null, 8, ["message"])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(activeNodeGroups), (groupType, index2) => {
                    return openBlock(), createBlock(ConfigGroup, {
                      "group-type": groupType,
                      index: index2,
                      key: groupType + unref$1(activeNode).name + index2
                    }, null, 8, ["group-type", "index"]);
                  }), 128))
                ])
              ])) : (openBlock(), createElementBlock("div", _hoisted_12$2, [
                createBaseVNode("div", _hoisted_13$2, [
                  createBaseVNode("div", _hoisted_14$2, toDisplayString(unref$1($t)("layers")), 1),
                  unref$1(activeNode) ? withDirectives((openBlock(), createBlock(Icon$1, {
                    key: 0,
                    class: "op-icon separate-icon",
                    name: "layers-slash",
                    size: 16,
                    onClick: _cache[6] || (_cache[6] = ($event) => showLayer.value = false)
                  }, null, 512)), [
                    [_directive_tooltip, "Setting"]
                  ]) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_15$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(pageData), (node) => {
                    return openBlock(), createBlock(_sfc_main$q, {
                      key: node.name,
                      node
                    }, null, 8, ["node"]);
                  }), 128))
                ])
              ]))
            ]),
            curMaterial.value ? (openBlock(), createBlock(_sfc_main$o, {
              key: 0,
              "auto-create-cover": !curMaterial.value.cover,
              "action-text": curMaterial.value.id ? unref$1($t)("edit") : unref$1($t)("saveOf"),
              material: curMaterial.value,
              "on-save": saveCallback.value,
              modelValue: showSaveMaterialModal.value,
              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => showSaveMaterialModal.value = $event)
            }, null, 8, ["auto-create-cover", "action-text", "material", "on-save", "modelValue"])) : createCommentVNode("", true)
          ], 2);
        };
      }
    });
    const ConfigSection_vue_vue_type_style_index_0_scoped_4a0055ab_lang = "";
    const ConfigSection_vue_vue_type_style_index_1_lang = "";
    const ConfigSection = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-4a0055ab"]]);
    const downloadHtml = (html) => {
      const blob = new Blob([html], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = "index.html";
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    };
    var vuedraggable_umd = { exports: {} };
    /**!
     * Sortable 1.14.0
     * @author	RubaXa   <trash@rubaxa.org>
     * @author	owenm    <owen23355@gmail.com>
     * @license MIT
     */
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var version = "1.14.0";
    function userAgent(pattern) {
      if (typeof window !== "undefined" && window.navigator) {
        return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
      }
    }
    var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
    var Edge = userAgent(/Edge/i);
    var FireFox = userAgent(/firefox/i);
    var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
    var IOS = userAgent(/iP(ad|od|hone)/i);
    var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
    var captureMode = {
      capture: false,
      passive: false
    };
    function on(el, event, fn) {
      el.addEventListener(event, fn, !IE11OrLess && captureMode);
    }
    function off(el, event, fn) {
      el.removeEventListener(event, fn, !IE11OrLess && captureMode);
    }
    function matches(el, selector) {
      if (!selector)
        return;
      selector[0] === ">" && (selector = selector.substring(1));
      if (el) {
        try {
          if (el.matches) {
            return el.matches(selector);
          } else if (el.msMatchesSelector) {
            return el.msMatchesSelector(selector);
          } else if (el.webkitMatchesSelector) {
            return el.webkitMatchesSelector(selector);
          }
        } catch (_) {
          return false;
        }
      }
      return false;
    }
    function getParentOrHost(el) {
      return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
    }
    function closest(el, selector, ctx, includeCTX) {
      if (el) {
        ctx = ctx || document;
        do {
          if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
            return el;
          }
          if (el === ctx)
            break;
        } while (el = getParentOrHost(el));
      }
      return null;
    }
    var R_SPACE = /\s+/g;
    function toggleClass(el, name, state) {
      if (el && name) {
        if (el.classList) {
          el.classList[state ? "add" : "remove"](name);
        } else {
          var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
          el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
        }
      }
    }
    function css(el, prop, val) {
      var style2 = el && el.style;
      if (style2) {
        if (val === void 0) {
          if (document.defaultView && document.defaultView.getComputedStyle) {
            val = document.defaultView.getComputedStyle(el, "");
          } else if (el.currentStyle) {
            val = el.currentStyle;
          }
          return prop === void 0 ? val : val[prop];
        } else {
          if (!(prop in style2) && prop.indexOf("webkit") === -1) {
            prop = "-webkit-" + prop;
          }
          style2[prop] = val + (typeof val === "string" ? "" : "px");
        }
      }
    }
    function matrix(el, selfOnly) {
      var appliedTransforms = "";
      if (typeof el === "string") {
        appliedTransforms = el;
      } else {
        do {
          var transform2 = css(el, "transform");
          if (transform2 && transform2 !== "none") {
            appliedTransforms = transform2 + " " + appliedTransforms;
          }
        } while (!selfOnly && (el = el.parentNode));
      }
      var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
      return matrixFn && new matrixFn(appliedTransforms);
    }
    function find(ctx, tagName, iterator) {
      if (ctx) {
        var list = ctx.getElementsByTagName(tagName), i2 = 0, n = list.length;
        if (iterator) {
          for (; i2 < n; i2++) {
            iterator(list[i2], i2);
          }
        }
        return list;
      }
      return [];
    }
    function getWindowScrollingElement() {
      var scrollingElement = document.scrollingElement;
      if (scrollingElement) {
        return scrollingElement;
      } else {
        return document.documentElement;
      }
    }
    function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
      if (!el.getBoundingClientRect && el !== window)
        return;
      var elRect, top, left, bottom, right, height, width;
      if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
        elRect = el.getBoundingClientRect();
        top = elRect.top;
        left = elRect.left;
        bottom = elRect.bottom;
        right = elRect.right;
        height = elRect.height;
        width = elRect.width;
      } else {
        top = 0;
        left = 0;
        bottom = window.innerHeight;
        right = window.innerWidth;
        height = window.innerHeight;
        width = window.innerWidth;
      }
      if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
        container = container || el.parentNode;
        if (!IE11OrLess) {
          do {
            if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
              var containerRect = container.getBoundingClientRect();
              top -= containerRect.top + parseInt(css(container, "border-top-width"));
              left -= containerRect.left + parseInt(css(container, "border-left-width"));
              bottom = top + elRect.height;
              right = left + elRect.width;
              break;
            }
          } while (container = container.parentNode);
        }
      }
      if (undoScale && el !== window) {
        var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
        if (elMatrix) {
          top /= scaleY;
          left /= scaleX;
          width /= scaleX;
          height /= scaleY;
          bottom = top + height;
          right = left + width;
        }
      }
      return {
        top,
        left,
        bottom,
        right,
        width,
        height
      };
    }
    function isScrolledPast(el, elSide, parentSide) {
      var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
      while (parent2) {
        var parentSideVal = getRect(parent2)[parentSide], visible = void 0;
        if (parentSide === "top" || parentSide === "left") {
          visible = elSideVal >= parentSideVal;
        } else {
          visible = elSideVal <= parentSideVal;
        }
        if (!visible)
          return parent2;
        if (parent2 === getWindowScrollingElement())
          break;
        parent2 = getParentAutoScrollElement(parent2, false);
      }
      return false;
    }
    function getChild(el, childNum, options, includeDragEl) {
      var currentChild = 0, i2 = 0, children = el.children;
      while (i2 < children.length) {
        if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options.draggable, el, false)) {
          if (currentChild === childNum) {
            return children[i2];
          }
          currentChild++;
        }
        i2++;
      }
      return null;
    }
    function lastChild(el, selector) {
      var last = el.lastElementChild;
      while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
        last = last.previousElementSibling;
      }
      return last || null;
    }
    function index(el, selector) {
      var index2 = 0;
      if (!el || !el.parentNode) {
        return -1;
      }
      while (el = el.previousElementSibling) {
        if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
          index2++;
        }
      }
      return index2;
    }
    function getRelativeScrollOffset(el) {
      var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
      if (el) {
        do {
          var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
          offsetLeft += el.scrollLeft * scaleX;
          offsetTop += el.scrollTop * scaleY;
        } while (el !== winScroller && (el = el.parentNode));
      }
      return [offsetLeft, offsetTop];
    }
    function indexOfObject(arr, obj) {
      for (var i2 in arr) {
        if (!arr.hasOwnProperty(i2))
          continue;
        for (var key in obj) {
          if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
            return Number(i2);
        }
      }
      return -1;
    }
    function getParentAutoScrollElement(el, includeSelf) {
      if (!el || !el.getBoundingClientRect)
        return getWindowScrollingElement();
      var elem = el;
      var gotSelf = false;
      do {
        if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
          var elemCSS = css(elem);
          if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
            if (!elem.getBoundingClientRect || elem === document.body)
              return getWindowScrollingElement();
            if (gotSelf || includeSelf)
              return elem;
            gotSelf = true;
          }
        }
      } while (elem = elem.parentNode);
      return getWindowScrollingElement();
    }
    function extend(dst, src2) {
      if (dst && src2) {
        for (var key in src2) {
          if (src2.hasOwnProperty(key)) {
            dst[key] = src2[key];
          }
        }
      }
      return dst;
    }
    function isRectEqual(rect1, rect2) {
      return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
    }
    var _throttleTimeout;
    function throttle(callback, ms) {
      return function() {
        if (!_throttleTimeout) {
          var args = arguments, _this = this;
          if (args.length === 1) {
            callback.call(_this, args[0]);
          } else {
            callback.apply(_this, args);
          }
          _throttleTimeout = setTimeout(function() {
            _throttleTimeout = void 0;
          }, ms);
        }
      };
    }
    function cancelThrottle() {
      clearTimeout(_throttleTimeout);
      _throttleTimeout = void 0;
    }
    function scrollBy(el, x, y) {
      el.scrollLeft += x;
      el.scrollTop += y;
    }
    function clone(el) {
      var Polymer = window.Polymer;
      var $ = window.jQuery || window.Zepto;
      if (Polymer && Polymer.dom) {
        return Polymer.dom(el).cloneNode(true);
      } else if ($) {
        return $(el).clone(true)[0];
      } else {
        return el.cloneNode(true);
      }
    }
    function setRect(el, rect) {
      css(el, "position", "absolute");
      css(el, "top", rect.top);
      css(el, "left", rect.left);
      css(el, "width", rect.width);
      css(el, "height", rect.height);
    }
    function unsetRect(el) {
      css(el, "position", "");
      css(el, "top", "");
      css(el, "left", "");
      css(el, "width", "");
      css(el, "height", "");
    }
    var expando = "Sortable" + new Date().getTime();
    function AnimationStateManager() {
      var animationStates = [], animationCallbackId;
      return {
        captureAnimationState: function captureAnimationState() {
          animationStates = [];
          if (!this.options.animation)
            return;
          var children = [].slice.call(this.el.children);
          children.forEach(function(child) {
            if (css(child, "display") === "none" || child === Sortable.ghost)
              return;
            animationStates.push({
              target: child,
              rect: getRect(child)
            });
            var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
            if (child.thisAnimationDuration) {
              var childMatrix = matrix(child, true);
              if (childMatrix) {
                fromRect.top -= childMatrix.f;
                fromRect.left -= childMatrix.e;
              }
            }
            child.fromRect = fromRect;
          });
        },
        addAnimationState: function addAnimationState(state) {
          animationStates.push(state);
        },
        removeAnimationState: function removeAnimationState(target) {
          animationStates.splice(indexOfObject(animationStates, {
            target
          }), 1);
        },
        animateAll: function animateAll(callback) {
          var _this = this;
          if (!this.options.animation) {
            clearTimeout(animationCallbackId);
            if (typeof callback === "function")
              callback();
            return;
          }
          var animating = false, animationTime = 0;
          animationStates.forEach(function(state) {
            var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
            if (targetMatrix) {
              toRect.top -= targetMatrix.f;
              toRect.left -= targetMatrix.e;
            }
            target.toRect = toRect;
            if (target.thisAnimationDuration) {
              if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
                time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
              }
            }
            if (!isRectEqual(toRect, fromRect)) {
              target.prevFromRect = fromRect;
              target.prevToRect = toRect;
              if (!time) {
                time = _this.options.animation;
              }
              _this.animate(target, animatingRect, toRect, time);
            }
            if (time) {
              animating = true;
              animationTime = Math.max(animationTime, time);
              clearTimeout(target.animationResetTimer);
              target.animationResetTimer = setTimeout(function() {
                target.animationTime = 0;
                target.prevFromRect = null;
                target.fromRect = null;
                target.prevToRect = null;
                target.thisAnimationDuration = null;
              }, time);
              target.thisAnimationDuration = time;
            }
          });
          clearTimeout(animationCallbackId);
          if (!animating) {
            if (typeof callback === "function")
              callback();
          } else {
            animationCallbackId = setTimeout(function() {
              if (typeof callback === "function")
                callback();
            }, animationTime);
          }
          animationStates = [];
        },
        animate: function animate2(target, currentRect, toRect, duration) {
          if (duration) {
            css(target, "transition", "");
            css(target, "transform", "");
            var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
            target.animatingX = !!translateX;
            target.animatingY = !!translateY;
            css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
            this.forRepaintDummy = repaint(target);
            css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
            css(target, "transform", "translate3d(0,0,0)");
            typeof target.animated === "number" && clearTimeout(target.animated);
            target.animated = setTimeout(function() {
              css(target, "transition", "");
              css(target, "transform", "");
              target.animated = false;
              target.animatingX = false;
              target.animatingY = false;
            }, duration);
          }
        }
      };
    }
    function repaint(target) {
      return target.offsetWidth;
    }
    function calculateRealTime(animatingRect, fromRect, toRect, options) {
      return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
    }
    var plugins = [];
    var defaults = {
      initializeByDefault: true
    };
    var PluginManager = {
      mount: function mount(plugin) {
        for (var option in defaults) {
          if (defaults.hasOwnProperty(option) && !(option in plugin)) {
            plugin[option] = defaults[option];
          }
        }
        plugins.forEach(function(p2) {
          if (p2.pluginName === plugin.pluginName) {
            throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
          }
        });
        plugins.push(plugin);
      },
      pluginEvent: function pluginEvent2(eventName, sortable, evt) {
        var _this = this;
        this.eventCanceled = false;
        evt.cancel = function() {
          _this.eventCanceled = true;
        };
        var eventNameGlobal = eventName + "Global";
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (sortable[plugin.pluginName][eventNameGlobal]) {
            sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
              sortable
            }, evt));
          }
          if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
            sortable[plugin.pluginName][eventName](_objectSpread2({
              sortable
            }, evt));
          }
        });
      },
      initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
        plugins.forEach(function(plugin) {
          var pluginName = plugin.pluginName;
          if (!sortable.options[pluginName] && !plugin.initializeByDefault)
            return;
          var initialized = new plugin(sortable, el, sortable.options);
          initialized.sortable = sortable;
          initialized.options = sortable.options;
          sortable[pluginName] = initialized;
          _extends(defaults2, initialized.defaults);
        });
        for (var option in sortable.options) {
          if (!sortable.options.hasOwnProperty(option))
            continue;
          var modified = this.modifyOption(sortable, option, sortable.options[option]);
          if (typeof modified !== "undefined") {
            sortable.options[option] = modified;
          }
        }
      },
      getEventProperties: function getEventProperties(name, sortable) {
        var eventProperties = {};
        plugins.forEach(function(plugin) {
          if (typeof plugin.eventProperties !== "function")
            return;
          _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
        });
        return eventProperties;
      },
      modifyOption: function modifyOption(sortable, name, value) {
        var modifiedValue;
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
            modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
          }
        });
        return modifiedValue;
      }
    };
    function dispatchEvent(_ref) {
      var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
      sortable = sortable || rootEl2 && rootEl2[expando];
      if (!sortable)
        return;
      var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent(name, {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent("Event");
        evt.initEvent(name, true, true);
      }
      evt.to = toEl || rootEl2;
      evt.from = fromEl || rootEl2;
      evt.item = targetEl || rootEl2;
      evt.clone = cloneEl2;
      evt.oldIndex = oldIndex2;
      evt.newIndex = newIndex2;
      evt.oldDraggableIndex = oldDraggableIndex2;
      evt.newDraggableIndex = newDraggableIndex2;
      evt.originalEvent = originalEvent;
      evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
      var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
      for (var option in allEventProperties) {
        evt[option] = allEventProperties[option];
      }
      if (rootEl2) {
        rootEl2.dispatchEvent(evt);
      }
      if (options[onName]) {
        options[onName].call(sortable, evt);
      }
    }
    var _excluded = ["evt"];
    var pluginEvent = function pluginEvent2(eventName, sortable) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data2 = _objectWithoutProperties(_ref, _excluded);
      PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
        dragEl,
        parentEl,
        ghostEl,
        rootEl,
        nextEl,
        lastDownEl,
        cloneEl,
        cloneHidden,
        dragStarted: moved,
        putSortable,
        activeSortable: Sortable.active,
        originalEvent,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex,
        hideGhostForTarget: _hideGhostForTarget,
        unhideGhostForTarget: _unhideGhostForTarget,
        cloneNowHidden: function cloneNowHidden() {
          cloneHidden = true;
        },
        cloneNowShown: function cloneNowShown() {
          cloneHidden = false;
        },
        dispatchSortableEvent: function dispatchSortableEvent(name) {
          _dispatchEvent({
            sortable,
            name,
            originalEvent
          });
        }
      }, data2));
    };
    function _dispatchEvent(info) {
      dispatchEvent(_objectSpread2({
        putSortable,
        cloneEl,
        targetEl: dragEl,
        rootEl,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex
      }, info));
    }
    var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
    var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
      if (!documentExists)
        return;
      if (IE11OrLess) {
        return false;
      }
      var el = document.createElement("x");
      el.style.cssText = "pointer-events:auto";
      return el.style.pointerEvents === "auto";
    }(), _detectDirection = function _detectDirection2(el, options) {
      var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
      if (elCSS.display === "flex") {
        return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
      }
      if (elCSS.display === "grid") {
        return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
      }
      if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
        var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
        return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
      }
      return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
    }, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
      return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
    }, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
      var ret;
      sortables.some(function(sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable))
          return;
        var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
        if (insideHorizontally && insideVertically) {
          return ret = sortable;
        }
      });
      return ret;
    }, _prepareGroup = function _prepareGroup2(options) {
      function toFn(value, pull) {
        return function(to, from, dragEl2, evt) {
          var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
          if (value == null && (pull || sameGroup)) {
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === "clone") {
            return value;
          } else if (typeof value === "function") {
            return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
          } else {
            var otherGroup = (pull ? to : from).options.group.name;
            return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
          }
        };
      }
      var group = {};
      var originalGroup = options.group;
      if (!originalGroup || _typeof(originalGroup) != "object") {
        originalGroup = {
          name: originalGroup
        };
      }
      group.name = originalGroup.name;
      group.checkPull = toFn(originalGroup.pull, true);
      group.checkPut = toFn(originalGroup.put);
      group.revertClone = originalGroup.revertClone;
      options.group = group;
    }, _hideGhostForTarget = function _hideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "none");
      }
    }, _unhideGhostForTarget = function _unhideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "");
      }
    };
    if (documentExists) {
      document.addEventListener("click", function(evt) {
        if (ignoreNextClick) {
          evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          evt.stopImmediatePropagation && evt.stopImmediatePropagation();
          ignoreNextClick = false;
          return false;
        }
      }, true);
    }
    var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
      if (dragEl) {
        evt = evt.touches ? evt.touches[0] : evt;
        var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
        if (nearest) {
          var event = {};
          for (var i2 in evt) {
            if (evt.hasOwnProperty(i2)) {
              event[i2] = evt[i2];
            }
          }
          event.target = event.rootEl = nearest;
          event.preventDefault = void 0;
          event.stopPropagation = void 0;
          nearest[expando]._onDragOver(event);
        }
      }
    };
    var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
      if (dragEl) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
      }
    };
    function Sortable(el, options) {
      if (!(el && el.nodeType && el.nodeType === 1)) {
        throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
      }
      this.el = el;
      this.options = options = _extends({}, options);
      el[expando] = this;
      var defaults2 = {
        group: null,
        sort: true,
        disabled: false,
        store: null,
        handle: null,
        draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
        swapThreshold: 1,
        invertSwap: false,
        invertedSwapThreshold: null,
        removeCloneOnHide: true,
        direction: function direction() {
          return _detectDirection(el, this.options);
        },
        ghostClass: "sortable-ghost",
        chosenClass: "sortable-chosen",
        dragClass: "sortable-drag",
        ignore: "a, img",
        filter: null,
        preventOnFilter: true,
        animation: 0,
        easing: null,
        setData: function setData(dataTransfer, dragEl2) {
          dataTransfer.setData("Text", dragEl2.textContent);
        },
        dropBubble: false,
        dragoverBubble: false,
        dataIdAttr: "data-id",
        delay: 0,
        delayOnTouchOnly: false,
        touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
        forceFallback: false,
        fallbackClass: "sortable-fallback",
        fallbackOnBody: false,
        fallbackTolerance: 0,
        fallbackOffset: {
          x: 0,
          y: 0
        },
        supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
        emptyInsertThreshold: 5
      };
      PluginManager.initializePlugins(this, el, defaults2);
      for (var name in defaults2) {
        !(name in options) && (options[name] = defaults2[name]);
      }
      _prepareGroup(options);
      for (var fn in this) {
        if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
          this[fn] = this[fn].bind(this);
        }
      }
      this.nativeDraggable = options.forceFallback ? false : supportDraggable;
      if (this.nativeDraggable) {
        this.options.touchStartThreshold = 1;
      }
      if (options.supportPointer) {
        on(el, "pointerdown", this._onTapStart);
      } else {
        on(el, "mousedown", this._onTapStart);
        on(el, "touchstart", this._onTapStart);
      }
      if (this.nativeDraggable) {
        on(el, "dragover", this);
        on(el, "dragenter", this);
      }
      sortables.push(this.el);
      options.store && options.store.get && this.sort(options.store.get(this) || []);
      _extends(this, AnimationStateManager());
    }
    Sortable.prototype = {
      constructor: Sortable,
      _isOutsideThisEl: function _isOutsideThisEl(target) {
        if (!this.el.contains(target) && target !== this.el) {
          lastTarget = null;
        }
      },
      _getDirection: function _getDirection(evt, target) {
        return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
      },
      _onTapStart: function _onTapStart(evt) {
        if (!evt.cancelable)
          return;
        var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type2 = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
        _saveInputCheckedState(el);
        if (dragEl) {
          return;
        }
        if (/mousedown|pointerdown/.test(type2) && evt.button !== 0 || options.disabled) {
          return;
        }
        if (originalTarget.isContentEditable) {
          return;
        }
        if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
          return;
        }
        target = closest(target, options.draggable, el, false);
        if (target && target.animated) {
          return;
        }
        if (lastDownEl === target) {
          return;
        }
        oldIndex = index(target);
        oldDraggableIndex = index(target, options.draggable);
        if (typeof filter === "function") {
          if (filter.call(this, evt, target, this)) {
            _dispatchEvent({
              sortable: _this,
              rootEl: originalTarget,
              name: "filter",
              targetEl: target,
              toEl: el,
              fromEl: el
            });
            pluginEvent("filter", _this, {
              evt
            });
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        } else if (filter) {
          filter = filter.split(",").some(function(criteria) {
            criteria = closest(originalTarget, criteria.trim(), el, false);
            if (criteria) {
              _dispatchEvent({
                sortable: _this,
                rootEl: criteria,
                name: "filter",
                targetEl: target,
                fromEl: el,
                toEl: el
              });
              pluginEvent("filter", _this, {
                evt
              });
              return true;
            }
          });
          if (filter) {
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        }
        if (options.handle && !closest(originalTarget, options.handle, el, false)) {
          return;
        }
        this._prepareDragStart(evt, touch, target);
      },
      _prepareDragStart: function _prepareDragStart(evt, touch, target) {
        var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
        if (target && !dragEl && target.parentNode === el) {
          var dragRect = getRect(target);
          rootEl = el;
          dragEl = target;
          parentEl = dragEl.parentNode;
          nextEl = dragEl.nextSibling;
          lastDownEl = target;
          activeGroup = options.group;
          Sortable.dragged = dragEl;
          tapEvt = {
            target: dragEl,
            clientX: (touch || evt).clientX,
            clientY: (touch || evt).clientY
          };
          tapDistanceLeft = tapEvt.clientX - dragRect.left;
          tapDistanceTop = tapEvt.clientY - dragRect.top;
          this._lastX = (touch || evt).clientX;
          this._lastY = (touch || evt).clientY;
          dragEl.style["will-change"] = "all";
          dragStartFn = function dragStartFn2() {
            pluginEvent("delayEnded", _this, {
              evt
            });
            if (Sortable.eventCanceled) {
              _this._onDrop();
              return;
            }
            _this._disableDelayedDragEvents();
            if (!FireFox && _this.nativeDraggable) {
              dragEl.draggable = true;
            }
            _this._triggerDragStart(evt, touch);
            _dispatchEvent({
              sortable: _this,
              name: "choose",
              originalEvent: evt
            });
            toggleClass(dragEl, options.chosenClass, true);
          };
          options.ignore.split(",").forEach(function(criteria) {
            find(dragEl, criteria.trim(), _disableDraggable);
          });
          on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
          on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
          on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
          on(ownerDocument, "mouseup", _this._onDrop);
          on(ownerDocument, "touchend", _this._onDrop);
          on(ownerDocument, "touchcancel", _this._onDrop);
          if (FireFox && this.nativeDraggable) {
            this.options.touchStartThreshold = 4;
            dragEl.draggable = true;
          }
          pluginEvent("delayStart", this, {
            evt
          });
          if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
            if (Sortable.eventCanceled) {
              this._onDrop();
              return;
            }
            on(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on(ownerDocument, "touchend", _this._disableDelayedDrag);
            on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
            on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
            on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
            options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
            _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
          } else {
            dragStartFn();
          }
        }
      },
      _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
        var touch = e.touches ? e.touches[0] : e;
        if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
          this._disableDelayedDrag();
        }
      },
      _disableDelayedDrag: function _disableDelayedDrag() {
        dragEl && _disableDraggable(dragEl);
        clearTimeout(this._dragStartTimer);
        this._disableDelayedDragEvents();
      },
      _disableDelayedDragEvents: function _disableDelayedDragEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._disableDelayedDrag);
        off(ownerDocument, "touchend", this._disableDelayedDrag);
        off(ownerDocument, "touchcancel", this._disableDelayedDrag);
        off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
      },
      _triggerDragStart: function _triggerDragStart(evt, touch) {
        touch = touch || evt.pointerType == "touch" && evt;
        if (!this.nativeDraggable || touch) {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._onTouchMove);
          } else if (touch) {
            on(document, "touchmove", this._onTouchMove);
          } else {
            on(document, "mousemove", this._onTouchMove);
          }
        } else {
          on(dragEl, "dragend", this);
          on(rootEl, "dragstart", this._onDragStart);
        }
        try {
          if (document.selection) {
            _nextTick(function() {
              document.selection.empty();
            });
          } else {
            window.getSelection().removeAllRanges();
          }
        } catch (err) {
        }
      },
      _dragStarted: function _dragStarted(fallback, evt) {
        awaitingDragStarted = false;
        if (rootEl && dragEl) {
          pluginEvent("dragStarted", this, {
            evt
          });
          if (this.nativeDraggable) {
            on(document, "dragover", _checkOutsideTargetEl);
          }
          var options = this.options;
          !fallback && toggleClass(dragEl, options.dragClass, false);
          toggleClass(dragEl, options.ghostClass, true);
          Sortable.active = this;
          fallback && this._appendGhost();
          _dispatchEvent({
            sortable: this,
            name: "start",
            originalEvent: evt
          });
        } else {
          this._nulling();
        }
      },
      _emulateDragOver: function _emulateDragOver() {
        if (touchEvt) {
          this._lastX = touchEvt.clientX;
          this._lastY = touchEvt.clientY;
          _hideGhostForTarget();
          var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          var parent2 = target;
          while (target && target.shadowRoot) {
            target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            if (target === parent2)
              break;
            parent2 = target;
          }
          dragEl.parentNode[expando]._isOutsideThisEl(target);
          if (parent2) {
            do {
              if (parent2[expando]) {
                var inserted = void 0;
                inserted = parent2[expando]._onDragOver({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target,
                  rootEl: parent2
                });
                if (inserted && !this.options.dragoverBubble) {
                  break;
                }
              }
              target = parent2;
            } while (parent2 = parent2.parentNode);
          }
          _unhideGhostForTarget();
        }
      },
      _onTouchMove: function _onTouchMove(evt) {
        if (tapEvt) {
          var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
          if (!Sortable.active && !awaitingDragStarted) {
            if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
              return;
            }
            this._onDragStart(evt, true);
          }
          if (ghostEl) {
            if (ghostMatrix) {
              ghostMatrix.e += dx - (lastDx || 0);
              ghostMatrix.f += dy - (lastDy || 0);
            } else {
              ghostMatrix = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: dx,
                f: dy
              };
            }
            var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
            css(ghostEl, "webkitTransform", cssMatrix);
            css(ghostEl, "mozTransform", cssMatrix);
            css(ghostEl, "msTransform", cssMatrix);
            css(ghostEl, "transform", cssMatrix);
            lastDx = dx;
            lastDy = dy;
            touchEvt = touch;
          }
          evt.cancelable && evt.preventDefault();
        }
      },
      _appendGhost: function _appendGhost() {
        if (!ghostEl) {
          var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
          if (PositionGhostAbsolutely) {
            ghostRelativeParent = container;
            while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
              ghostRelativeParent = ghostRelativeParent.parentNode;
            }
            if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
              if (ghostRelativeParent === document)
                ghostRelativeParent = getWindowScrollingElement();
              rect.top += ghostRelativeParent.scrollTop;
              rect.left += ghostRelativeParent.scrollLeft;
            } else {
              ghostRelativeParent = getWindowScrollingElement();
            }
            ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
          }
          ghostEl = dragEl.cloneNode(true);
          toggleClass(ghostEl, options.ghostClass, false);
          toggleClass(ghostEl, options.fallbackClass, true);
          toggleClass(ghostEl, options.dragClass, true);
          css(ghostEl, "transition", "");
          css(ghostEl, "transform", "");
          css(ghostEl, "box-sizing", "border-box");
          css(ghostEl, "margin", 0);
          css(ghostEl, "top", rect.top);
          css(ghostEl, "left", rect.left);
          css(ghostEl, "width", rect.width);
          css(ghostEl, "height", rect.height);
          css(ghostEl, "opacity", "0.8");
          css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
          css(ghostEl, "zIndex", "100000");
          css(ghostEl, "pointerEvents", "none");
          Sortable.ghost = ghostEl;
          container.appendChild(ghostEl);
          css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
        }
      },
      _onDragStart: function _onDragStart(evt, fallback) {
        var _this = this;
        var dataTransfer = evt.dataTransfer;
        var options = _this.options;
        pluginEvent("dragStart", this, {
          evt
        });
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        pluginEvent("setupClone", this);
        if (!Sortable.eventCanceled) {
          cloneEl = clone(dragEl);
          cloneEl.draggable = false;
          cloneEl.style["will-change"] = "";
          this._hideClone();
          toggleClass(cloneEl, this.options.chosenClass, false);
          Sortable.clone = cloneEl;
        }
        _this.cloneId = _nextTick(function() {
          pluginEvent("clone", _this);
          if (Sortable.eventCanceled)
            return;
          if (!_this.options.removeCloneOnHide) {
            rootEl.insertBefore(cloneEl, dragEl);
          }
          _this._hideClone();
          _dispatchEvent({
            sortable: _this,
            name: "clone"
          });
        });
        !fallback && toggleClass(dragEl, options.dragClass, true);
        if (fallback) {
          ignoreNextClick = true;
          _this._loopId = setInterval(_this._emulateDragOver, 50);
        } else {
          off(document, "mouseup", _this._onDrop);
          off(document, "touchend", _this._onDrop);
          off(document, "touchcancel", _this._onDrop);
          if (dataTransfer) {
            dataTransfer.effectAllowed = "move";
            options.setData && options.setData.call(_this, dataTransfer, dragEl);
          }
          on(document, "drop", _this);
          css(dragEl, "transform", "translateZ(0)");
        }
        awaitingDragStarted = true;
        _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
        on(document, "selectstart", _this);
        moved = true;
        if (Safari) {
          css(document.body, "user-select", "none");
        }
      },
      _onDragOver: function _onDragOver(evt) {
        var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
        if (_silent)
          return;
        function dragOverEvent(name, extra) {
          pluginEvent(name, _this, _objectSpread2({
            evt,
            isOwner,
            axis: vertical ? "vertical" : "horizontal",
            revert,
            dragRect,
            targetRect,
            canSort,
            fromSortable,
            target,
            completed,
            onMove: function onMove(target2, after2) {
              return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
            },
            changed
          }, extra));
        }
        function capture() {
          dragOverEvent("dragOverAnimationCapture");
          _this.captureAnimationState();
          if (_this !== fromSortable) {
            fromSortable.captureAnimationState();
          }
        }
        function completed(insertion) {
          dragOverEvent("dragOverCompleted", {
            insertion
          });
          if (insertion) {
            if (isOwner) {
              activeSortable._hideClone();
            } else {
              activeSortable._showClone(_this);
            }
            if (_this !== fromSortable) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
              toggleClass(dragEl, options.ghostClass, true);
            }
            if (putSortable !== _this && _this !== Sortable.active) {
              putSortable = _this;
            } else if (_this === Sortable.active && putSortable) {
              putSortable = null;
            }
            if (fromSortable === _this) {
              _this._ignoreWhileAnimating = target;
            }
            _this.animateAll(function() {
              dragOverEvent("dragOverAnimationComplete");
              _this._ignoreWhileAnimating = null;
            });
            if (_this !== fromSortable) {
              fromSortable.animateAll();
              fromSortable._ignoreWhileAnimating = null;
            }
          }
          if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
            lastTarget = null;
          }
          if (!options.dragoverBubble && !evt.rootEl && target !== document) {
            dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
            !insertion && nearestEmptyInsertDetectEvent(evt);
          }
          !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
          return completedFired = true;
        }
        function changed() {
          newIndex = index(dragEl);
          newDraggableIndex = index(dragEl, options.draggable);
          _dispatchEvent({
            sortable: _this,
            name: "change",
            toEl: el,
            newIndex,
            newDraggableIndex,
            originalEvent: evt
          });
        }
        if (evt.preventDefault !== void 0) {
          evt.cancelable && evt.preventDefault();
        }
        target = closest(target, options.draggable, el, true);
        dragOverEvent("dragOver");
        if (Sortable.eventCanceled)
          return completedFired;
        if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
          return completed(false);
        }
        ignoreNextClick = false;
        if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
          vertical = this._getDirection(evt, target) === "vertical";
          dragRect = getRect(dragEl);
          dragOverEvent("dragOverValid");
          if (Sortable.eventCanceled)
            return completedFired;
          if (revert) {
            parentEl = rootEl;
            capture();
            this._hideClone();
            dragOverEvent("revert");
            if (!Sortable.eventCanceled) {
              if (nextEl) {
                rootEl.insertBefore(dragEl, nextEl);
              } else {
                rootEl.appendChild(dragEl);
              }
            }
            return completed(true);
          }
          var elLastChild = lastChild(el, options.draggable);
          if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
            if (elLastChild === dragEl) {
              return completed(false);
            }
            if (elLastChild && el === evt.target) {
              target = elLastChild;
            }
            if (target) {
              targetRect = getRect(target);
            }
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
              capture();
              el.appendChild(dragEl);
              parentEl = el;
              changed();
              return completed(true);
            }
          } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
            var firstChild = getChild(el, 0, options, true);
            if (firstChild === dragEl) {
              return completed(false);
            }
            target = firstChild;
            targetRect = getRect(target);
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
              capture();
              el.insertBefore(dragEl, firstChild);
              parentEl = el;
              changed();
              return completed(true);
            }
          } else if (target.parentNode === el) {
            targetRect = getRect(target);
            var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
            if (lastTarget !== target) {
              targetBeforeFirstSwap = targetRect[side1];
              pastFirstInvertThresh = false;
              isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
            }
            direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
            var sibling;
            if (direction !== 0) {
              var dragIndex = index(dragEl);
              do {
                dragIndex -= direction;
                sibling = parentEl.children[dragIndex];
              } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
            }
            if (direction === 0 || sibling === target) {
              return completed(false);
            }
            lastTarget = target;
            lastDirection = direction;
            var nextSibling = target.nextElementSibling, after = false;
            after = direction === 1;
            var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
            if (moveVector !== false) {
              if (moveVector === 1 || moveVector === -1) {
                after = moveVector === 1;
              }
              _silent = true;
              setTimeout(_unsilent, 30);
              capture();
              if (after && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
              }
              if (scrolledPastTop) {
                scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
              }
              parentEl = dragEl.parentNode;
              if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
                targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
              }
              changed();
              return completed(true);
            }
          }
          if (el.contains(dragEl)) {
            return completed(false);
          }
        }
        return false;
      },
      _ignoreWhileAnimating: null,
      _offMoveEvents: function _offMoveEvents() {
        off(document, "mousemove", this._onTouchMove);
        off(document, "touchmove", this._onTouchMove);
        off(document, "pointermove", this._onTouchMove);
        off(document, "dragover", nearestEmptyInsertDetectEvent);
        off(document, "mousemove", nearestEmptyInsertDetectEvent);
        off(document, "touchmove", nearestEmptyInsertDetectEvent);
      },
      _offUpEvents: function _offUpEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._onDrop);
        off(ownerDocument, "touchend", this._onDrop);
        off(ownerDocument, "pointerup", this._onDrop);
        off(ownerDocument, "touchcancel", this._onDrop);
        off(document, "selectstart", this);
      },
      _onDrop: function _onDrop(evt) {
        var el = this.el, options = this.options;
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        pluginEvent("drop", this, {
          evt
        });
        parentEl = dragEl && dragEl.parentNode;
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        if (Sortable.eventCanceled) {
          this._nulling();
          return;
        }
        awaitingDragStarted = false;
        isCircumstantialInvert = false;
        pastFirstInvertThresh = false;
        clearInterval(this._loopId);
        clearTimeout(this._dragStartTimer);
        _cancelNextTick(this.cloneId);
        _cancelNextTick(this._dragStartId);
        if (this.nativeDraggable) {
          off(document, "drop", this);
          off(el, "dragstart", this._onDragStart);
        }
        this._offMoveEvents();
        this._offUpEvents();
        if (Safari) {
          css(document.body, "user-select", "");
        }
        css(dragEl, "transform", "");
        if (evt) {
          if (moved) {
            evt.cancelable && evt.preventDefault();
            !options.dropBubble && evt.stopPropagation();
          }
          ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
          if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
            cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
          }
          if (dragEl) {
            if (this.nativeDraggable) {
              off(dragEl, "dragend", this);
            }
            _disableDraggable(dragEl);
            dragEl.style["will-change"] = "";
            if (moved && !awaitingDragStarted) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
            }
            toggleClass(dragEl, this.options.chosenClass, false);
            _dispatchEvent({
              sortable: this,
              name: "unchoose",
              toEl: parentEl,
              newIndex: null,
              newDraggableIndex: null,
              originalEvent: evt
            });
            if (rootEl !== parentEl) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "add",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "remove",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "sort",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
              putSortable && putSortable.save();
            } else {
              if (newIndex !== oldIndex) {
                if (newIndex >= 0) {
                  _dispatchEvent({
                    sortable: this,
                    name: "update",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    sortable: this,
                    name: "sort",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                }
              }
            }
            if (Sortable.active) {
              if (newIndex == null || newIndex === -1) {
                newIndex = oldIndex;
                newDraggableIndex = oldDraggableIndex;
              }
              _dispatchEvent({
                sortable: this,
                name: "end",
                toEl: parentEl,
                originalEvent: evt
              });
              this.save();
            }
          }
        }
        this._nulling();
      },
      _nulling: function _nulling() {
        pluginEvent("nulling", this);
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
        savedInputChecked.forEach(function(el) {
          el.checked = true;
        });
        savedInputChecked.length = lastDx = lastDy = 0;
      },
      handleEvent: function handleEvent(evt) {
        switch (evt.type) {
          case "drop":
          case "dragend":
            this._onDrop(evt);
            break;
          case "dragenter":
          case "dragover":
            if (dragEl) {
              this._onDragOver(evt);
              _globalDragOver(evt);
            }
            break;
          case "selectstart":
            evt.preventDefault();
            break;
        }
      },
      toArray: function toArray2() {
        var order = [], el, children = this.el.children, i2 = 0, n = children.length, options = this.options;
        for (; i2 < n; i2++) {
          el = children[i2];
          if (closest(el, options.draggable, this.el, false)) {
            order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
          }
        }
        return order;
      },
      sort: function sort(order, useAnimation2) {
        var items = {}, rootEl2 = this.el;
        this.toArray().forEach(function(id, i2) {
          var el = rootEl2.children[i2];
          if (closest(el, this.options.draggable, rootEl2, false)) {
            items[id] = el;
          }
        }, this);
        useAnimation2 && this.captureAnimationState();
        order.forEach(function(id) {
          if (items[id]) {
            rootEl2.removeChild(items[id]);
            rootEl2.appendChild(items[id]);
          }
        });
        useAnimation2 && this.animateAll();
      },
      save: function save() {
        var store = this.options.store;
        store && store.set && store.set(this);
      },
      closest: function closest$1(el, selector) {
        return closest(el, selector || this.options.draggable, this.el, false);
      },
      option: function option(name, value) {
        var options = this.options;
        if (value === void 0) {
          return options[name];
        } else {
          var modifiedValue = PluginManager.modifyOption(this, name, value);
          if (typeof modifiedValue !== "undefined") {
            options[name] = modifiedValue;
          } else {
            options[name] = value;
          }
          if (name === "group") {
            _prepareGroup(options);
          }
        }
      },
      destroy: function destroy() {
        pluginEvent("destroy", this);
        var el = this.el;
        el[expando] = null;
        off(el, "mousedown", this._onTapStart);
        off(el, "touchstart", this._onTapStart);
        off(el, "pointerdown", this._onTapStart);
        if (this.nativeDraggable) {
          off(el, "dragover", this);
          off(el, "dragenter", this);
        }
        Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
          el2.removeAttribute("draggable");
        });
        this._onDrop();
        this._disableDelayedDragEvents();
        sortables.splice(sortables.indexOf(this.el), 1);
        this.el = el = null;
      },
      _hideClone: function _hideClone() {
        if (!cloneHidden) {
          pluginEvent("hideClone", this);
          if (Sortable.eventCanceled)
            return;
          css(cloneEl, "display", "none");
          if (this.options.removeCloneOnHide && cloneEl.parentNode) {
            cloneEl.parentNode.removeChild(cloneEl);
          }
          cloneHidden = true;
        }
      },
      _showClone: function _showClone(putSortable2) {
        if (putSortable2.lastPutMode !== "clone") {
          this._hideClone();
          return;
        }
        if (cloneHidden) {
          pluginEvent("showClone", this);
          if (Sortable.eventCanceled)
            return;
          if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
            rootEl.insertBefore(cloneEl, dragEl);
          } else if (nextEl) {
            rootEl.insertBefore(cloneEl, nextEl);
          } else {
            rootEl.appendChild(cloneEl);
          }
          if (this.options.group.revertClone) {
            this.animate(dragEl, cloneEl);
          }
          css(cloneEl, "display", "");
          cloneHidden = false;
        }
      }
    };
    function _globalDragOver(evt) {
      if (evt.dataTransfer) {
        evt.dataTransfer.dropEffect = "move";
      }
      evt.cancelable && evt.preventDefault();
    }
    function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
      var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent("move", {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent("Event");
        evt.initEvent("move", true, true);
      }
      evt.to = toEl;
      evt.from = fromEl;
      evt.dragged = dragEl2;
      evt.draggedRect = dragRect;
      evt.related = targetEl || toEl;
      evt.relatedRect = targetRect || getRect(toEl);
      evt.willInsertAfter = willInsertAfter;
      evt.originalEvent = originalEvent;
      fromEl.dispatchEvent(evt);
      if (onMoveFn) {
        retVal = onMoveFn.call(sortable, evt, originalEvent);
      }
      return retVal;
    }
    function _disableDraggable(el) {
      el.draggable = false;
    }
    function _unsilent() {
      _silent = false;
    }
    function _ghostIsFirst(evt, vertical, sortable) {
      var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
      var spacer = 10;
      return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
    }
    function _ghostIsLast(evt, vertical, sortable) {
      var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
      var spacer = 10;
      return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
    }
    function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
      var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
      if (!invertSwap) {
        if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
          if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
            pastFirstInvertThresh = true;
          }
          if (!pastFirstInvertThresh) {
            if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
              return -lastDirection;
            }
          } else {
            invert = true;
          }
        } else {
          if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
            return _getInsertDirection(target);
          }
        }
      }
      invert = invert || invertSwap;
      if (invert) {
        if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
          return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
        }
      }
      return 0;
    }
    function _getInsertDirection(target) {
      if (index(dragEl) < index(target)) {
        return 1;
      } else {
        return -1;
      }
    }
    function _generateId(el) {
      var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
      while (i2--) {
        sum += str.charCodeAt(i2);
      }
      return sum.toString(36);
    }
    function _saveInputCheckedState(root2) {
      savedInputChecked.length = 0;
      var inputs = root2.getElementsByTagName("input");
      var idx = inputs.length;
      while (idx--) {
        var el = inputs[idx];
        el.checked && savedInputChecked.push(el);
      }
    }
    function _nextTick(fn) {
      return setTimeout(fn, 0);
    }
    function _cancelNextTick(id) {
      return clearTimeout(id);
    }
    if (documentExists) {
      on(document, "touchmove", function(evt) {
        if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
          evt.preventDefault();
        }
      });
    }
    Sortable.utils = {
      on,
      off,
      css,
      find,
      is: function is2(el, selector) {
        return !!closest(el, selector, el, false);
      },
      extend,
      throttle,
      closest,
      toggleClass,
      clone,
      index,
      nextTick: _nextTick,
      cancelNextTick: _cancelNextTick,
      detectDirection: _detectDirection,
      getChild
    };
    Sortable.get = function(element) {
      return element[expando];
    };
    Sortable.mount = function() {
      for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins2[_key] = arguments[_key];
      }
      if (plugins2[0].constructor === Array)
        plugins2 = plugins2[0];
      plugins2.forEach(function(plugin) {
        if (!plugin.prototype || !plugin.prototype.constructor) {
          throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
        }
        if (plugin.utils)
          Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
        PluginManager.mount(plugin);
      });
    };
    Sortable.create = function(el, options) {
      return new Sortable(el, options);
    };
    Sortable.version = version;
    var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
    function AutoScrollPlugin() {
      function AutoScroll() {
        this.defaults = {
          scroll: true,
          forceAutoScrollFallback: false,
          scrollSensitivity: 30,
          scrollSpeed: 10,
          bubbleScroll: true
        };
        for (var fn in this) {
          if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
            this[fn] = this[fn].bind(this);
          }
        }
      }
      AutoScroll.prototype = {
        dragStarted: function dragStarted2(_ref) {
          var originalEvent = _ref.originalEvent;
          if (this.sortable.nativeDraggable) {
            on(document, "dragover", this._handleAutoScroll);
          } else {
            if (this.options.supportPointer) {
              on(document, "pointermove", this._handleFallbackAutoScroll);
            } else if (originalEvent.touches) {
              on(document, "touchmove", this._handleFallbackAutoScroll);
            } else {
              on(document, "mousemove", this._handleFallbackAutoScroll);
            }
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref2) {
          var originalEvent = _ref2.originalEvent;
          if (!this.options.dragOverBubble && !originalEvent.rootEl) {
            this._handleAutoScroll(originalEvent);
          }
        },
        drop: function drop2() {
          if (this.sortable.nativeDraggable) {
            off(document, "dragover", this._handleAutoScroll);
          } else {
            off(document, "pointermove", this._handleFallbackAutoScroll);
            off(document, "touchmove", this._handleFallbackAutoScroll);
            off(document, "mousemove", this._handleFallbackAutoScroll);
          }
          clearPointerElemChangedInterval();
          clearAutoScrolls();
          cancelThrottle();
        },
        nulling: function nulling() {
          touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
          autoScrolls.length = 0;
        },
        _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
          this._handleAutoScroll(evt, true);
        },
        _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
          var _this = this;
          var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
          touchEvt$1 = evt;
          if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
            autoScroll(evt, this.options, elem, fallback);
            var ogElemScroller = getParentAutoScrollElement(elem, true);
            if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
              pointerElemChangedInterval && clearPointerElemChangedInterval();
              pointerElemChangedInterval = setInterval(function() {
                var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
                if (newElem !== ogElemScroller) {
                  ogElemScroller = newElem;
                  clearAutoScrolls();
                }
                autoScroll(evt, _this.options, newElem, fallback);
              }, 10);
              lastAutoScrollX = x;
              lastAutoScrollY = y;
            }
          } else {
            if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
              clearAutoScrolls();
              return;
            }
            autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
          }
        }
      };
      return _extends(AutoScroll, {
        pluginName: "scroll",
        initializeByDefault: true
      });
    }
    function clearAutoScrolls() {
      autoScrolls.forEach(function(autoScroll2) {
        clearInterval(autoScroll2.pid);
      });
      autoScrolls = [];
    }
    function clearPointerElemChangedInterval() {
      clearInterval(pointerElemChangedInterval);
    }
    var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
      if (!options.scroll)
        return;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
      var scrollThisInstance = false, scrollCustomFn;
      if (scrollRootEl !== rootEl2) {
        scrollRootEl = rootEl2;
        clearAutoScrolls();
        scrollEl = options.scroll;
        scrollCustomFn = options.scrollFn;
        if (scrollEl === true) {
          scrollEl = getParentAutoScrollElement(rootEl2, true);
        }
      }
      var layersOut = 0;
      var currentParent = scrollEl;
      do {
        var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
        if (el === winScroller) {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
        } else {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
        }
        var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
        var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
        if (!autoScrolls[layersOut]) {
          for (var i2 = 0; i2 <= layersOut; i2++) {
            if (!autoScrolls[i2]) {
              autoScrolls[i2] = {};
            }
          }
        }
        if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
          autoScrolls[layersOut].el = el;
          autoScrolls[layersOut].vx = vx;
          autoScrolls[layersOut].vy = vy;
          clearInterval(autoScrolls[layersOut].pid);
          if (vx != 0 || vy != 0) {
            scrollThisInstance = true;
            autoScrolls[layersOut].pid = setInterval(function() {
              if (isFallback && this.layer === 0) {
                Sortable.active._onTouchMove(touchEvt$1);
              }
              var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
              var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
              if (typeof scrollCustomFn === "function") {
                if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                  return;
                }
              }
              scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
            }.bind({
              layer: layersOut
            }), 24);
          }
        }
        layersOut++;
      } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
      scrolling = scrollThisInstance;
    }, 30);
    var drop = function drop2(_ref) {
      var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
      if (!originalEvent)
        return;
      var toSortable = putSortable2 || activeSortable;
      hideGhostForTarget();
      var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
      var target = document.elementFromPoint(touch.clientX, touch.clientY);
      unhideGhostForTarget();
      if (toSortable && !toSortable.el.contains(target)) {
        dispatchSortableEvent("spill");
        this.onSpill({
          dragEl: dragEl2,
          putSortable: putSortable2
        });
      }
    };
    function Revert() {
    }
    Revert.prototype = {
      startIndex: null,
      dragStart: function dragStart(_ref2) {
        var oldDraggableIndex2 = _ref2.oldDraggableIndex;
        this.startIndex = oldDraggableIndex2;
      },
      onSpill: function onSpill(_ref3) {
        var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
        this.sortable.captureAnimationState();
        if (putSortable2) {
          putSortable2.captureAnimationState();
        }
        var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
        if (nextSibling) {
          this.sortable.el.insertBefore(dragEl2, nextSibling);
        } else {
          this.sortable.el.appendChild(dragEl2);
        }
        this.sortable.animateAll();
        if (putSortable2) {
          putSortable2.animateAll();
        }
      },
      drop
    };
    _extends(Revert, {
      pluginName: "revertOnSpill"
    });
    function Remove() {
    }
    Remove.prototype = {
      onSpill: function onSpill(_ref4) {
        var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
        var parentSortable = putSortable2 || this.sortable;
        parentSortable.captureAnimationState();
        dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
        parentSortable.animateAll();
      },
      drop
    };
    _extends(Remove, {
      pluginName: "removeOnSpill"
    });
    var lastSwapEl;
    function SwapPlugin() {
      function Swap() {
        this.defaults = {
          swapClass: "sortable-swap-highlight"
        };
      }
      Swap.prototype = {
        dragStart: function dragStart(_ref) {
          var dragEl2 = _ref.dragEl;
          lastSwapEl = dragEl2;
        },
        dragOverValid: function dragOverValid(_ref2) {
          var completed = _ref2.completed, target = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
          if (!activeSortable.options.swap)
            return;
          var el = this.sortable.el, options = this.options;
          if (target && target !== el) {
            var prevSwapEl = lastSwapEl;
            if (onMove(target) !== false) {
              toggleClass(target, options.swapClass, true);
              lastSwapEl = target;
            } else {
              lastSwapEl = null;
            }
            if (prevSwapEl && prevSwapEl !== lastSwapEl) {
              toggleClass(prevSwapEl, options.swapClass, false);
            }
          }
          changed();
          completed(true);
          cancel();
        },
        drop: function drop2(_ref3) {
          var activeSortable = _ref3.activeSortable, putSortable2 = _ref3.putSortable, dragEl2 = _ref3.dragEl;
          var toSortable = putSortable2 || this.sortable;
          var options = this.options;
          lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
          if (lastSwapEl && (options.swap || putSortable2 && putSortable2.options.swap)) {
            if (dragEl2 !== lastSwapEl) {
              toSortable.captureAnimationState();
              if (toSortable !== activeSortable)
                activeSortable.captureAnimationState();
              swapNodes(dragEl2, lastSwapEl);
              toSortable.animateAll();
              if (toSortable !== activeSortable)
                activeSortable.animateAll();
            }
          }
        },
        nulling: function nulling() {
          lastSwapEl = null;
        }
      };
      return _extends(Swap, {
        pluginName: "swap",
        eventProperties: function eventProperties() {
          return {
            swapItem: lastSwapEl
          };
        }
      });
    }
    function swapNodes(n1, n2) {
      var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
      if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1))
        return;
      i1 = index(n1);
      i2 = index(n2);
      if (p1.isEqualNode(p2) && i1 < i2) {
        i2++;
      }
      p1.insertBefore(n2, p1.children[i1]);
      p2.insertBefore(n1, p2.children[i2]);
    }
    var multiDragElements = [], multiDragClones = [], lastMultiDragSelect, multiDragSortable, initialFolding = false, folding = false, dragStarted = false, dragEl$1, clonesFromRect, clonesHidden;
    function MultiDragPlugin() {
      function MultiDrag(sortable) {
        for (var fn in this) {
          if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
            this[fn] = this[fn].bind(this);
          }
        }
        if (sortable.options.supportPointer) {
          on(document, "pointerup", this._deselectMultiDrag);
        } else {
          on(document, "mouseup", this._deselectMultiDrag);
          on(document, "touchend", this._deselectMultiDrag);
        }
        on(document, "keydown", this._checkKeyDown);
        on(document, "keyup", this._checkKeyUp);
        this.defaults = {
          selectedClass: "sortable-selected",
          multiDragKey: null,
          setData: function setData(dataTransfer, dragEl2) {
            var data2 = "";
            if (multiDragElements.length && multiDragSortable === sortable) {
              multiDragElements.forEach(function(multiDragElement, i2) {
                data2 += (!i2 ? "" : ", ") + multiDragElement.textContent;
              });
            } else {
              data2 = dragEl2.textContent;
            }
            dataTransfer.setData("Text", data2);
          }
        };
      }
      MultiDrag.prototype = {
        multiDragKeyDown: false,
        isMultiDrag: false,
        delayStartGlobal: function delayStartGlobal(_ref) {
          var dragged = _ref.dragEl;
          dragEl$1 = dragged;
        },
        delayEnded: function delayEnded() {
          this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
        },
        setupClone: function setupClone(_ref2) {
          var sortable = _ref2.sortable, cancel = _ref2.cancel;
          if (!this.isMultiDrag)
            return;
          for (var i2 = 0; i2 < multiDragElements.length; i2++) {
            multiDragClones.push(clone(multiDragElements[i2]));
            multiDragClones[i2].sortableIndex = multiDragElements[i2].sortableIndex;
            multiDragClones[i2].draggable = false;
            multiDragClones[i2].style["will-change"] = "";
            toggleClass(multiDragClones[i2], this.options.selectedClass, false);
            multiDragElements[i2] === dragEl$1 && toggleClass(multiDragClones[i2], this.options.chosenClass, false);
          }
          sortable._hideClone();
          cancel();
        },
        clone: function clone2(_ref3) {
          var sortable = _ref3.sortable, rootEl2 = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
          if (!this.isMultiDrag)
            return;
          if (!this.options.removeCloneOnHide) {
            if (multiDragElements.length && multiDragSortable === sortable) {
              insertMultiDragClones(true, rootEl2);
              dispatchSortableEvent("clone");
              cancel();
            }
          }
        },
        showClone: function showClone(_ref4) {
          var cloneNowShown = _ref4.cloneNowShown, rootEl2 = _ref4.rootEl, cancel = _ref4.cancel;
          if (!this.isMultiDrag)
            return;
          insertMultiDragClones(false, rootEl2);
          multiDragClones.forEach(function(clone2) {
            css(clone2, "display", "");
          });
          cloneNowShown();
          clonesHidden = false;
          cancel();
        },
        hideClone: function hideClone(_ref5) {
          var _this = this;
          _ref5.sortable;
          var cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
          if (!this.isMultiDrag)
            return;
          multiDragClones.forEach(function(clone2) {
            css(clone2, "display", "none");
            if (_this.options.removeCloneOnHide && clone2.parentNode) {
              clone2.parentNode.removeChild(clone2);
            }
          });
          cloneNowHidden();
          clonesHidden = true;
          cancel();
        },
        dragStartGlobal: function dragStartGlobal(_ref6) {
          _ref6.sortable;
          if (!this.isMultiDrag && multiDragSortable) {
            multiDragSortable.multiDrag._deselectMultiDrag();
          }
          multiDragElements.forEach(function(multiDragElement) {
            multiDragElement.sortableIndex = index(multiDragElement);
          });
          multiDragElements = multiDragElements.sort(function(a, b) {
            return a.sortableIndex - b.sortableIndex;
          });
          dragStarted = true;
        },
        dragStarted: function dragStarted2(_ref7) {
          var _this2 = this;
          var sortable = _ref7.sortable;
          if (!this.isMultiDrag)
            return;
          if (this.options.sort) {
            sortable.captureAnimationState();
            if (this.options.animation) {
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement === dragEl$1)
                  return;
                css(multiDragElement, "position", "absolute");
              });
              var dragRect = getRect(dragEl$1, false, true, true);
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement === dragEl$1)
                  return;
                setRect(multiDragElement, dragRect);
              });
              folding = true;
              initialFolding = true;
            }
          }
          sortable.animateAll(function() {
            folding = false;
            initialFolding = false;
            if (_this2.options.animation) {
              multiDragElements.forEach(function(multiDragElement) {
                unsetRect(multiDragElement);
              });
            }
            if (_this2.options.sort) {
              removeMultiDragElements();
            }
          });
        },
        dragOver: function dragOver(_ref8) {
          var target = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
          if (folding && ~multiDragElements.indexOf(target)) {
            completed(false);
            cancel();
          }
        },
        revert: function revert(_ref9) {
          var fromSortable = _ref9.fromSortable, rootEl2 = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
          if (multiDragElements.length > 1) {
            multiDragElements.forEach(function(multiDragElement) {
              sortable.addAnimationState({
                target: multiDragElement,
                rect: folding ? getRect(multiDragElement) : dragRect
              });
              unsetRect(multiDragElement);
              multiDragElement.fromRect = dragRect;
              fromSortable.removeAnimationState(multiDragElement);
            });
            folding = false;
            insertMultiDragElements(!this.options.removeCloneOnHide, rootEl2);
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref10) {
          var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl2 = _ref10.parentEl, putSortable2 = _ref10.putSortable;
          var options = this.options;
          if (insertion) {
            if (isOwner) {
              activeSortable._hideClone();
            }
            initialFolding = false;
            if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable2)) {
              var dragRectAbsolute = getRect(dragEl$1, false, true, true);
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement === dragEl$1)
                  return;
                setRect(multiDragElement, dragRectAbsolute);
                parentEl2.appendChild(multiDragElement);
              });
              folding = true;
            }
            if (!isOwner) {
              if (!folding) {
                removeMultiDragElements();
              }
              if (multiDragElements.length > 1) {
                var clonesHiddenBefore = clonesHidden;
                activeSortable._showClone(sortable);
                if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
                  multiDragClones.forEach(function(clone2) {
                    activeSortable.addAnimationState({
                      target: clone2,
                      rect: clonesFromRect
                    });
                    clone2.fromRect = clonesFromRect;
                    clone2.thisAnimationDuration = null;
                  });
                }
              } else {
                activeSortable._showClone(sortable);
              }
            }
          }
        },
        dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
          var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
          multiDragElements.forEach(function(multiDragElement) {
            multiDragElement.thisAnimationDuration = null;
          });
          if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
            clonesFromRect = _extends({}, dragRect);
            var dragMatrix = matrix(dragEl$1, true);
            clonesFromRect.top -= dragMatrix.f;
            clonesFromRect.left -= dragMatrix.e;
          }
        },
        dragOverAnimationComplete: function dragOverAnimationComplete() {
          if (folding) {
            folding = false;
            removeMultiDragElements();
          }
        },
        drop: function drop2(_ref12) {
          var evt = _ref12.originalEvent, rootEl2 = _ref12.rootEl, parentEl2 = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex2 = _ref12.oldIndex, putSortable2 = _ref12.putSortable;
          var toSortable = putSortable2 || this.sortable;
          if (!evt)
            return;
          var options = this.options, children = parentEl2.children;
          if (!dragStarted) {
            if (options.multiDragKey && !this.multiDragKeyDown) {
              this._deselectMultiDrag();
            }
            toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
            if (!~multiDragElements.indexOf(dragEl$1)) {
              multiDragElements.push(dragEl$1);
              dispatchEvent({
                sortable,
                rootEl: rootEl2,
                name: "select",
                targetEl: dragEl$1,
                originalEvt: evt
              });
              if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
                var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
                if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
                  var n, i2;
                  if (currentIndex > lastIndex) {
                    i2 = lastIndex;
                    n = currentIndex;
                  } else {
                    i2 = currentIndex;
                    n = lastIndex + 1;
                  }
                  for (; i2 < n; i2++) {
                    if (~multiDragElements.indexOf(children[i2]))
                      continue;
                    toggleClass(children[i2], options.selectedClass, true);
                    multiDragElements.push(children[i2]);
                    dispatchEvent({
                      sortable,
                      rootEl: rootEl2,
                      name: "select",
                      targetEl: children[i2],
                      originalEvt: evt
                    });
                  }
                }
              } else {
                lastMultiDragSelect = dragEl$1;
              }
              multiDragSortable = toSortable;
            } else {
              multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
              lastMultiDragSelect = null;
              dispatchEvent({
                sortable,
                rootEl: rootEl2,
                name: "deselect",
                targetEl: dragEl$1,
                originalEvt: evt
              });
            }
          }
          if (dragStarted && this.isMultiDrag) {
            folding = false;
            if ((parentEl2[expando].options.sort || parentEl2 !== rootEl2) && multiDragElements.length > 1) {
              var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
              if (!initialFolding && options.animation)
                dragEl$1.thisAnimationDuration = null;
              toSortable.captureAnimationState();
              if (!initialFolding) {
                if (options.animation) {
                  dragEl$1.fromRect = dragRect;
                  multiDragElements.forEach(function(multiDragElement) {
                    multiDragElement.thisAnimationDuration = null;
                    if (multiDragElement !== dragEl$1) {
                      var rect = folding ? getRect(multiDragElement) : dragRect;
                      multiDragElement.fromRect = rect;
                      toSortable.addAnimationState({
                        target: multiDragElement,
                        rect
                      });
                    }
                  });
                }
                removeMultiDragElements();
                multiDragElements.forEach(function(multiDragElement) {
                  if (children[multiDragIndex]) {
                    parentEl2.insertBefore(multiDragElement, children[multiDragIndex]);
                  } else {
                    parentEl2.appendChild(multiDragElement);
                  }
                  multiDragIndex++;
                });
                if (oldIndex2 === index(dragEl$1)) {
                  var update = false;
                  multiDragElements.forEach(function(multiDragElement) {
                    if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                      update = true;
                      return;
                    }
                  });
                  if (update) {
                    dispatchSortableEvent("update");
                  }
                }
              }
              multiDragElements.forEach(function(multiDragElement) {
                unsetRect(multiDragElement);
              });
              toSortable.animateAll();
            }
            multiDragSortable = toSortable;
          }
          if (rootEl2 === parentEl2 || putSortable2 && putSortable2.lastPutMode !== "clone") {
            multiDragClones.forEach(function(clone2) {
              clone2.parentNode && clone2.parentNode.removeChild(clone2);
            });
          }
        },
        nullingGlobal: function nullingGlobal() {
          this.isMultiDrag = dragStarted = false;
          multiDragClones.length = 0;
        },
        destroyGlobal: function destroyGlobal() {
          this._deselectMultiDrag();
          off(document, "pointerup", this._deselectMultiDrag);
          off(document, "mouseup", this._deselectMultiDrag);
          off(document, "touchend", this._deselectMultiDrag);
          off(document, "keydown", this._checkKeyDown);
          off(document, "keyup", this._checkKeyUp);
        },
        _deselectMultiDrag: function _deselectMultiDrag(evt) {
          if (typeof dragStarted !== "undefined" && dragStarted)
            return;
          if (multiDragSortable !== this.sortable)
            return;
          if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false))
            return;
          if (evt && evt.button !== 0)
            return;
          while (multiDragElements.length) {
            var el = multiDragElements[0];
            toggleClass(el, this.options.selectedClass, false);
            multiDragElements.shift();
            dispatchEvent({
              sortable: this.sortable,
              rootEl: this.sortable.el,
              name: "deselect",
              targetEl: el,
              originalEvt: evt
            });
          }
        },
        _checkKeyDown: function _checkKeyDown(evt) {
          if (evt.key === this.options.multiDragKey) {
            this.multiDragKeyDown = true;
          }
        },
        _checkKeyUp: function _checkKeyUp(evt) {
          if (evt.key === this.options.multiDragKey) {
            this.multiDragKeyDown = false;
          }
        }
      };
      return _extends(MultiDrag, {
        pluginName: "multiDrag",
        utils: {
          select: function select(el) {
            var sortable = el.parentNode[expando];
            if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el))
              return;
            if (multiDragSortable && multiDragSortable !== sortable) {
              multiDragSortable.multiDrag._deselectMultiDrag();
              multiDragSortable = sortable;
            }
            toggleClass(el, sortable.options.selectedClass, true);
            multiDragElements.push(el);
          },
          deselect: function deselect(el) {
            var sortable = el.parentNode[expando], index2 = multiDragElements.indexOf(el);
            if (!sortable || !sortable.options.multiDrag || !~index2)
              return;
            toggleClass(el, sortable.options.selectedClass, false);
            multiDragElements.splice(index2, 1);
          }
        },
        eventProperties: function eventProperties() {
          var _this3 = this;
          var oldIndicies = [], newIndicies = [];
          multiDragElements.forEach(function(multiDragElement) {
            oldIndicies.push({
              multiDragElement,
              index: multiDragElement.sortableIndex
            });
            var newIndex2;
            if (folding && multiDragElement !== dragEl$1) {
              newIndex2 = -1;
            } else if (folding) {
              newIndex2 = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
            } else {
              newIndex2 = index(multiDragElement);
            }
            newIndicies.push({
              multiDragElement,
              index: newIndex2
            });
          });
          return {
            items: _toConsumableArray(multiDragElements),
            clones: [].concat(multiDragClones),
            oldIndicies,
            newIndicies
          };
        },
        optionListeners: {
          multiDragKey: function multiDragKey(key) {
            key = key.toLowerCase();
            if (key === "ctrl") {
              key = "Control";
            } else if (key.length > 1) {
              key = key.charAt(0).toUpperCase() + key.substr(1);
            }
            return key;
          }
        }
      });
    }
    function insertMultiDragElements(clonesInserted, rootEl2) {
      multiDragElements.forEach(function(multiDragElement, i2) {
        var target = rootEl2.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i2) : 0)];
        if (target) {
          rootEl2.insertBefore(multiDragElement, target);
        } else {
          rootEl2.appendChild(multiDragElement);
        }
      });
    }
    function insertMultiDragClones(elementsInserted, rootEl2) {
      multiDragClones.forEach(function(clone2, i2) {
        var target = rootEl2.children[clone2.sortableIndex + (elementsInserted ? Number(i2) : 0)];
        if (target) {
          rootEl2.insertBefore(clone2, target);
        } else {
          rootEl2.appendChild(clone2);
        }
      });
    }
    function removeMultiDragElements() {
      multiDragElements.forEach(function(multiDragElement) {
        if (multiDragElement === dragEl$1)
          return;
        multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
      });
    }
    Sortable.mount(new AutoScrollPlugin());
    Sortable.mount(Remove, Revert);
    const sortable_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: Sortable,
      MultiDrag: MultiDragPlugin,
      Sortable,
      Swap: SwapPlugin
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$1 = /* @__PURE__ */ getAugmentedNamespace$1(sortable_esm);
    (function(module2, exports2) {
      (function webpackUniversalModuleDefinition(root2, factory) {
        module2.exports = factory(require$$0$1, require$$1);
      })(typeof self !== "undefined" ? self : commonjsGlobal$1, function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE_a352__) {
        return function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports3, name, getter) {
            if (!__webpack_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports3) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports3, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __webpack_require__.d(ns, key, function(key2) {
                  return value[key2];
                }.bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? function getDefault() {
              return module3["default"];
            } : function getModuleExports() {
              return module3;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = "fb15");
        }({
          "00ee": function(module3, exports3, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var test = {};
            test[TO_STRING_TAG] = "z";
            module3.exports = String(test) === "[object z]";
          },
          "0366": function(module3, exports3, __webpack_require__) {
            var aFunction = __webpack_require__("1c0b");
            module3.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0)
                return fn;
              switch (length) {
                case 0:
                  return function() {
                    return fn.call(that);
                  };
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          "057f": function(module3, exports3, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
            var toString2 = {}.toString;
            var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it) {
              try {
                return nativeGetOwnPropertyNames(it);
              } catch (error) {
                return windowNames.slice();
              }
            };
            module3.exports.f = function getOwnPropertyNames(it) {
              return windowNames && toString2.call(it) == "[object Window]" ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
            };
          },
          "06cf": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var propertyIsEnumerableModule = __webpack_require__("d1e7");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var toIndexedObject = __webpack_require__("fc6a");
            var toPrimitive = __webpack_require__("c04e");
            var has2 = __webpack_require__("5135");
            var IE8_DOM_DEFINE = __webpack_require__("0cfb");
            var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports3.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
              O = toIndexedObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeGetOwnPropertyDescriptor(O, P);
                } catch (error) {
                }
              if (has2(O, P))
                return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
            };
          },
          "0cfb": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var fails = __webpack_require__("d039");
            var createElement = __webpack_require__("cc12");
            module3.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          },
          "13d5": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $reduce = __webpack_require__("d58f").left;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var STRICT_METHOD = arrayMethodIsStrict("reduce");
            var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
            $({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
              reduce: function reduce(callbackfn) {
                return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          "14c3": function(module3, exports3, __webpack_require__) {
            var classof = __webpack_require__("c6b6");
            var regexpExec = __webpack_require__("9263");
            module3.exports = function(R, S) {
              var exec = R.exec;
              if (typeof exec === "function") {
                var result = exec.call(R, S);
                if (typeof result !== "object") {
                  throw TypeError("RegExp exec method returned something other than an Object or null");
                }
                return result;
              }
              if (classof(R) !== "RegExp") {
                throw TypeError("RegExp#exec called on incompatible receiver");
              }
              return regexpExec.call(R, S);
            };
          },
          "159b": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var DOMIterables = __webpack_require__("fdbc");
            var forEach2 = __webpack_require__("17c2");
            var createNonEnumerableProperty = __webpack_require__("9112");
            for (var COLLECTION_NAME in DOMIterables) {
              var Collection = global2[COLLECTION_NAME];
              var CollectionPrototype = Collection && Collection.prototype;
              if (CollectionPrototype && CollectionPrototype.forEach !== forEach2)
                try {
                  createNonEnumerableProperty(CollectionPrototype, "forEach", forEach2);
                } catch (error) {
                  CollectionPrototype.forEach = forEach2;
                }
            }
          },
          "17c2": function(module3, exports3, __webpack_require__) {
            var $forEach = __webpack_require__("b727").forEach;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var STRICT_METHOD = arrayMethodIsStrict("forEach");
            var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
            module3.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach2(callbackfn) {
              return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            } : [].forEach;
          },
          "1be4": function(module3, exports3, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            module3.exports = getBuiltIn("document", "documentElement");
          },
          "1c0b": function(module3, exports3) {
            module3.exports = function(it) {
              if (typeof it != "function") {
                throw TypeError(String(it) + " is not a function");
              }
              return it;
            };
          },
          "1c7e": function(module3, exports3, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            var SAFE_CLOSING = false;
            try {
              var called = 0;
              var iteratorWithReturn = {
                next: function() {
                  return { done: !!called++ };
                },
                "return": function() {
                  SAFE_CLOSING = true;
                }
              };
              iteratorWithReturn[ITERATOR] = function() {
                return this;
              };
              Array.from(iteratorWithReturn, function() {
                throw 2;
              });
            } catch (error) {
            }
            module3.exports = function(exec, SKIP_CLOSING) {
              if (!SKIP_CLOSING && !SAFE_CLOSING)
                return false;
              var ITERATION_SUPPORT = false;
              try {
                var object = {};
                object[ITERATOR] = function() {
                  return {
                    next: function() {
                      return { done: ITERATION_SUPPORT = true };
                    }
                  };
                };
                exec(object);
              } catch (error) {
              }
              return ITERATION_SUPPORT;
            };
          },
          "1d80": function(module3, exports3) {
            module3.exports = function(it) {
              if (it == void 0)
                throw TypeError("Can't call method on " + it);
              return it;
            };
          },
          "1dde": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var wellKnownSymbol = __webpack_require__("b622");
            var V8_VERSION = __webpack_require__("2d00");
            var SPECIES = wellKnownSymbol("species");
            module3.exports = function(METHOD_NAME) {
              return V8_VERSION >= 51 || !fails(function() {
                var array2 = [];
                var constructor = array2.constructor = {};
                constructor[SPECIES] = function() {
                  return { foo: 1 };
                };
                return array2[METHOD_NAME](Boolean).foo !== 1;
              });
            };
          },
          "23cb": function(module3, exports3, __webpack_require__) {
            var toInteger2 = __webpack_require__("a691");
            var max2 = Math.max;
            var min2 = Math.min;
            module3.exports = function(index2, length) {
              var integer = toInteger2(index2);
              return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
            };
          },
          "23e7": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var setGlobal = __webpack_require__("ce4e");
            var copyConstructorProperties = __webpack_require__("e893");
            var isForced = __webpack_require__("94ca");
            module3.exports = function(options, source) {
              var TARGET = options.target;
              var GLOBAL = options.global;
              var STATIC = options.stat;
              var FORCED, target, key, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global2;
              } else if (STATIC) {
                target = global2[TARGET] || setGlobal(TARGET, {});
              } else {
                target = (global2[TARGET] || {}).prototype;
              }
              if (target)
                for (key in source) {
                  sourceProperty = source[key];
                  if (options.noTargetGet) {
                    descriptor = getOwnPropertyDescriptor(target, key);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key];
                  FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty === typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options.sham || targetProperty && targetProperty.sham) {
                    createNonEnumerableProperty(sourceProperty, "sham", true);
                  }
                  redefine(target, key, sourceProperty, options);
                }
            };
          },
          "241c": function(module3, exports3, __webpack_require__) {
            var internalObjectKeys = __webpack_require__("ca84");
            var enumBugKeys = __webpack_require__("7839");
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports3.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return internalObjectKeys(O, hiddenKeys);
            };
          },
          "25f0": function(module3, exports3, __webpack_require__) {
            var redefine = __webpack_require__("6eeb");
            var anObject = __webpack_require__("825a");
            var fails = __webpack_require__("d039");
            var flags = __webpack_require__("ad6d");
            var TO_STRING = "toString";
            var RegExpPrototype = RegExp.prototype;
            var nativeToString = RegExpPrototype[TO_STRING];
            var NOT_GENERIC = fails(function() {
              return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
            });
            var INCORRECT_NAME = nativeToString.name != TO_STRING;
            if (NOT_GENERIC || INCORRECT_NAME) {
              redefine(RegExp.prototype, TO_STRING, function toString2() {
                var R = anObject(this);
                var p2 = String(R.source);
                var rf = R.flags;
                var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R) : rf);
                return "/" + p2 + "/" + f;
              }, { unsafe: true });
            }
          },
          "2ca0": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var toLength = __webpack_require__("50c4");
            var notARegExp = __webpack_require__("5a34");
            var requireObjectCoercible = __webpack_require__("1d80");
            var correctIsRegExpLogic = __webpack_require__("ab13");
            var IS_PURE = __webpack_require__("c430");
            var nativeStartsWith = "".startsWith;
            var min2 = Math.min;
            var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
            var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
              var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
              return descriptor && !descriptor.writable;
            }();
            $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
              startsWith: function startsWith(searchString) {
                var that = String(requireObjectCoercible(this));
                notARegExp(searchString);
                var index2 = toLength(min2(arguments.length > 1 ? arguments[1] : void 0, that.length));
                var search = String(searchString);
                return nativeStartsWith ? nativeStartsWith.call(that, search, index2) : that.slice(index2, index2 + search.length) === search;
              }
            });
          },
          "2d00": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var userAgent2 = __webpack_require__("342f");
            var process2 = global2.process;
            var versions = process2 && process2.versions;
            var v8 = versions && versions.v8;
            var match, version2;
            if (v8) {
              match = v8.split(".");
              version2 = match[0] + match[1];
            } else if (userAgent2) {
              match = userAgent2.match(/Edge\/(\d+)/);
              if (!match || match[1] >= 74) {
                match = userAgent2.match(/Chrome\/(\d+)/);
                if (match)
                  version2 = match[1];
              }
            }
            module3.exports = version2 && +version2;
          },
          "342f": function(module3, exports3, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            module3.exports = getBuiltIn("navigator", "userAgent") || "";
          },
          "35a1": function(module3, exports3, __webpack_require__) {
            var classof = __webpack_require__("f5df");
            var Iterators = __webpack_require__("3f8c");
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            module3.exports = function(it) {
              if (it != void 0)
                return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          "37e8": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var definePropertyModule = __webpack_require__("9bf2");
            var anObject = __webpack_require__("825a");
            var objectKeys = __webpack_require__("df75");
            module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var keys2 = objectKeys(Properties);
              var length = keys2.length;
              var index2 = 0;
              var key;
              while (length > index2)
                definePropertyModule.f(O, key = keys2[index2++], Properties[key]);
              return O;
            };
          },
          "3bbe": function(module3, exports3, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            module3.exports = function(it) {
              if (!isObject2(it) && it !== null) {
                throw TypeError("Can't set " + String(it) + " as a prototype");
              }
              return it;
            };
          },
          "3ca3": function(module3, exports3, __webpack_require__) {
            var charAt = __webpack_require__("6547").charAt;
            var InternalStateModule = __webpack_require__("69f3");
            var defineIterator = __webpack_require__("7dd0");
            var STRING_ITERATOR = "String Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
            defineIterator(String, "String", function(iterated) {
              setInternalState(this, {
                type: STRING_ITERATOR,
                string: String(iterated),
                index: 0
              });
            }, function next() {
              var state = getInternalState(this);
              var string2 = state.string;
              var index2 = state.index;
              var point;
              if (index2 >= string2.length)
                return { value: void 0, done: true };
              point = charAt(string2, index2);
              state.index += point.length;
              return { value: point, done: false };
            });
          },
          "3f8c": function(module3, exports3) {
            module3.exports = {};
          },
          "4160": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var forEach2 = __webpack_require__("17c2");
            $({ target: "Array", proto: true, forced: [].forEach != forEach2 }, {
              forEach: forEach2
            });
          },
          "428f": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            module3.exports = global2;
          },
          "44ad": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var classof = __webpack_require__("c6b6");
            var split = "".split;
            module3.exports = fails(function() {
              return !Object("z").propertyIsEnumerable(0);
            }) ? function(it) {
              return classof(it) == "String" ? split.call(it, "") : Object(it);
            } : Object;
          },
          "44d2": function(module3, exports3, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var create2 = __webpack_require__("7c73");
            var definePropertyModule = __webpack_require__("9bf2");
            var UNSCOPABLES = wellKnownSymbol("unscopables");
            var ArrayPrototype = Array.prototype;
            if (ArrayPrototype[UNSCOPABLES] == void 0) {
              definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                configurable: true,
                value: create2(null)
              });
            }
            module3.exports = function(key) {
              ArrayPrototype[UNSCOPABLES][key] = true;
            };
          },
          "44e7": function(module3, exports3, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            var classof = __webpack_require__("c6b6");
            var wellKnownSymbol = __webpack_require__("b622");
            var MATCH = wellKnownSymbol("match");
            module3.exports = function(it) {
              var isRegExp;
              return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
            };
          },
          "4930": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              return !String(Symbol());
            });
          },
          "4d64": function(module3, exports3, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var toLength = __webpack_require__("50c4");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var createMethod = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIndexedObject($this);
                var length = toLength(O.length);
                var index2 = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index2) {
                    value = O[index2++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index2; index2++) {
                    if ((IS_INCLUDES || index2 in O) && O[index2] === el)
                      return IS_INCLUDES || index2 || 0;
                  }
                return !IS_INCLUDES && -1;
              };
            };
            module3.exports = {
              includes: createMethod(true),
              indexOf: createMethod(false)
            };
          },
          "4de4": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $filter = __webpack_require__("b727").filter;
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
            var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
            $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              filter: function filter(callbackfn) {
                return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          "4df4": function(module3, exports3, __webpack_require__) {
            var bind3 = __webpack_require__("0366");
            var toObject = __webpack_require__("7b0b");
            var callWithSafeIterationClosing = __webpack_require__("9bdd");
            var isArrayIteratorMethod = __webpack_require__("e95a");
            var toLength = __webpack_require__("50c4");
            var createProperty = __webpack_require__("8418");
            var getIteratorMethod = __webpack_require__("35a1");
            module3.exports = function from(arrayLike) {
              var O = toObject(arrayLike);
              var C2 = typeof this == "function" ? this : Array;
              var argumentsLength = arguments.length;
              var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
              var mapping = mapfn !== void 0;
              var iteratorMethod = getIteratorMethod(O);
              var index2 = 0;
              var length, result, step, iterator, next, value;
              if (mapping)
                mapfn = bind3(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
              if (iteratorMethod != void 0 && !(C2 == Array && isArrayIteratorMethod(iteratorMethod))) {
                iterator = iteratorMethod.call(O);
                next = iterator.next;
                result = new C2();
                for (; !(step = next.call(iterator)).done; index2++) {
                  value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
                  createProperty(result, index2, value);
                }
              } else {
                length = toLength(O.length);
                result = new C2(length);
                for (; length > index2; index2++) {
                  value = mapping ? mapfn(O[index2], index2) : O[index2];
                  createProperty(result, index2, value);
                }
              }
              result.length = index2;
              return result;
            };
          },
          "4fad": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $entries = __webpack_require__("6f53").entries;
            $({ target: "Object", stat: true }, {
              entries: function entries(O) {
                return $entries(O);
              }
            });
          },
          "50c4": function(module3, exports3, __webpack_require__) {
            var toInteger2 = __webpack_require__("a691");
            var min2 = Math.min;
            module3.exports = function(argument) {
              return argument > 0 ? min2(toInteger2(argument), 9007199254740991) : 0;
            };
          },
          "5135": function(module3, exports3) {
            var hasOwnProperty2 = {}.hasOwnProperty;
            module3.exports = function(it, key) {
              return hasOwnProperty2.call(it, key);
            };
          },
          "5319": function(module3, exports3, __webpack_require__) {
            var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
            var anObject = __webpack_require__("825a");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var toInteger2 = __webpack_require__("a691");
            var requireObjectCoercible = __webpack_require__("1d80");
            var advanceStringIndex = __webpack_require__("8aa5");
            var regExpExec = __webpack_require__("14c3");
            var max2 = Math.max;
            var min2 = Math.min;
            var floor = Math.floor;
            var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
            var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
            var maybeToString = function(it) {
              return it === void 0 ? it : String(it);
            };
            fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
              var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
              var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
              var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
              return [
                function replace(searchValue, replaceValue) {
                  var O = requireObjectCoercible(this);
                  var replacer2 = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                  return replacer2 !== void 0 ? replacer2.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
                },
                function(regexp, replaceValue) {
                  if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                    var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                    if (res.done)
                      return res.value;
                  }
                  var rx = anObject(regexp);
                  var S = String(this);
                  var functionalReplace = typeof replaceValue === "function";
                  if (!functionalReplace)
                    replaceValue = String(replaceValue);
                  var global2 = rx.global;
                  if (global2) {
                    var fullUnicode = rx.unicode;
                    rx.lastIndex = 0;
                  }
                  var results = [];
                  while (true) {
                    var result = regExpExec(rx, S);
                    if (result === null)
                      break;
                    results.push(result);
                    if (!global2)
                      break;
                    var matchStr = String(result[0]);
                    if (matchStr === "")
                      rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                  }
                  var accumulatedResult = "";
                  var nextSourcePosition = 0;
                  for (var i2 = 0; i2 < results.length; i2++) {
                    result = results[i2];
                    var matched = String(result[0]);
                    var position = max2(min2(toInteger2(result.index), S.length), 0);
                    var captures = [];
                    for (var j = 1; j < result.length; j++)
                      captures.push(maybeToString(result[j]));
                    var namedCaptures = result.groups;
                    if (functionalReplace) {
                      var replacerArgs = [matched].concat(captures, position, S);
                      if (namedCaptures !== void 0)
                        replacerArgs.push(namedCaptures);
                      var replacement = String(replaceValue.apply(void 0, replacerArgs));
                    } else {
                      replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                    }
                    if (position >= nextSourcePosition) {
                      accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                      nextSourcePosition = position + matched.length;
                    }
                  }
                  return accumulatedResult + S.slice(nextSourcePosition);
                }
              ];
              function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
                var tailPos = position + matched.length;
                var m = captures.length;
                var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
                if (namedCaptures !== void 0) {
                  namedCaptures = toObject(namedCaptures);
                  symbols = SUBSTITUTION_SYMBOLS;
                }
                return nativeReplace.call(replacement, symbols, function(match, ch) {
                  var capture;
                  switch (ch.charAt(0)) {
                    case "$":
                      return "$";
                    case "&":
                      return matched;
                    case "`":
                      return str.slice(0, position);
                    case "'":
                      return str.slice(tailPos);
                    case "<":
                      capture = namedCaptures[ch.slice(1, -1)];
                      break;
                    default:
                      var n = +ch;
                      if (n === 0)
                        return match;
                      if (n > m) {
                        var f = floor(n / 10);
                        if (f === 0)
                          return match;
                        if (f <= m)
                          return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                        return match;
                      }
                      capture = captures[n - 1];
                  }
                  return capture === void 0 ? "" : capture;
                });
              }
            });
          },
          "5692": function(module3, exports3, __webpack_require__) {
            var IS_PURE = __webpack_require__("c430");
            var store = __webpack_require__("c6cd");
            (module3.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.6.5",
              mode: IS_PURE ? "pure" : "global",
              copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
            });
          },
          "56ef": function(module3, exports3, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            var getOwnPropertyNamesModule = __webpack_require__("241c");
            var getOwnPropertySymbolsModule = __webpack_require__("7418");
            var anObject = __webpack_require__("825a");
            module3.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
              var keys2 = getOwnPropertyNamesModule.f(anObject(it));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? keys2.concat(getOwnPropertySymbols(it)) : keys2;
            };
          },
          "5a34": function(module3, exports3, __webpack_require__) {
            var isRegExp = __webpack_require__("44e7");
            module3.exports = function(it) {
              if (isRegExp(it)) {
                throw TypeError("The method doesn't accept regular expressions");
              }
              return it;
            };
          },
          "5c6c": function(module3, exports3) {
            module3.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          "5db7": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var flattenIntoArray = __webpack_require__("a2bf");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var aFunction = __webpack_require__("1c0b");
            var arraySpeciesCreate = __webpack_require__("65f0");
            $({ target: "Array", proto: true }, {
              flatMap: function flatMap(callbackfn) {
                var O = toObject(this);
                var sourceLen = toLength(O.length);
                var A2;
                aFunction(callbackfn);
                A2 = arraySpeciesCreate(O, 0);
                A2.length = flattenIntoArray(A2, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                return A2;
              }
            });
          },
          "6547": function(module3, exports3, __webpack_require__) {
            var toInteger2 = __webpack_require__("a691");
            var requireObjectCoercible = __webpack_require__("1d80");
            var createMethod = function(CONVERT_TO_STRING) {
              return function($this, pos) {
                var S = String(requireObjectCoercible($this));
                var position = toInteger2(pos);
                var size2 = S.length;
                var first, second;
                if (position < 0 || position >= size2)
                  return CONVERT_TO_STRING ? "" : void 0;
                first = S.charCodeAt(position);
                return first < 55296 || first > 56319 || position + 1 === size2 || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
              };
            };
            module3.exports = {
              codeAt: createMethod(false),
              charAt: createMethod(true)
            };
          },
          "65f0": function(module3, exports3, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            var isArray2 = __webpack_require__("e8b5");
            var wellKnownSymbol = __webpack_require__("b622");
            var SPECIES = wellKnownSymbol("species");
            module3.exports = function(originalArray, length) {
              var C2;
              if (isArray2(originalArray)) {
                C2 = originalArray.constructor;
                if (typeof C2 == "function" && (C2 === Array || isArray2(C2.prototype)))
                  C2 = void 0;
                else if (isObject2(C2)) {
                  C2 = C2[SPECIES];
                  if (C2 === null)
                    C2 = void 0;
                }
              }
              return new (C2 === void 0 ? Array : C2)(length === 0 ? 0 : length);
            };
          },
          "69f3": function(module3, exports3, __webpack_require__) {
            var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
            var global2 = __webpack_require__("da84");
            var isObject2 = __webpack_require__("861d");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var objectHas = __webpack_require__("5135");
            var sharedKey = __webpack_require__("f772");
            var hiddenKeys = __webpack_require__("d012");
            var WeakMap2 = global2.WeakMap;
            var set2, get2, has2;
            var enforce = function(it) {
              return has2(it) ? get2(it) : set2(it, {});
            };
            var getterFor = function(TYPE2) {
              return function(it) {
                var state;
                if (!isObject2(it) || (state = get2(it)).type !== TYPE2) {
                  throw TypeError("Incompatible receiver, " + TYPE2 + " required");
                }
                return state;
              };
            };
            if (NATIVE_WEAK_MAP) {
              var store = new WeakMap2();
              var wmget = store.get;
              var wmhas = store.has;
              var wmset = store.set;
              set2 = function(it, metadata) {
                wmset.call(store, it, metadata);
                return metadata;
              };
              get2 = function(it) {
                return wmget.call(store, it) || {};
              };
              has2 = function(it) {
                return wmhas.call(store, it);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set2 = function(it, metadata) {
                createNonEnumerableProperty(it, STATE, metadata);
                return metadata;
              };
              get2 = function(it) {
                return objectHas(it, STATE) ? it[STATE] : {};
              };
              has2 = function(it) {
                return objectHas(it, STATE);
              };
            }
            module3.exports = {
              set: set2,
              get: get2,
              has: has2,
              enforce,
              getterFor
            };
          },
          "6eeb": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var has2 = __webpack_require__("5135");
            var setGlobal = __webpack_require__("ce4e");
            var inspectSource = __webpack_require__("8925");
            var InternalStateModule = __webpack_require__("69f3");
            var getInternalState = InternalStateModule.get;
            var enforceInternalState = InternalStateModule.enforce;
            var TEMPLATE = String(String).split("String");
            (module3.exports = function(O, key, value, options) {
              var unsafe = options ? !!options.unsafe : false;
              var simple = options ? !!options.enumerable : false;
              var noTargetGet = options ? !!options.noTargetGet : false;
              if (typeof value == "function") {
                if (typeof key == "string" && !has2(value, "name"))
                  createNonEnumerableProperty(value, "name", key);
                enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
              }
              if (O === global2) {
                if (simple)
                  O[key] = value;
                else
                  setGlobal(key, value);
                return;
              } else if (!unsafe) {
                delete O[key];
              } else if (!noTargetGet && O[key]) {
                simple = true;
              }
              if (simple)
                O[key] = value;
              else
                createNonEnumerableProperty(O, key, value);
            })(Function.prototype, "toString", function toString2() {
              return typeof this == "function" && getInternalState(this).source || inspectSource(this);
            });
          },
          "6f53": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var objectKeys = __webpack_require__("df75");
            var toIndexedObject = __webpack_require__("fc6a");
            var propertyIsEnumerable2 = __webpack_require__("d1e7").f;
            var createMethod = function(TO_ENTRIES) {
              return function(it) {
                var O = toIndexedObject(it);
                var keys2 = objectKeys(O);
                var length = keys2.length;
                var i2 = 0;
                var result = [];
                var key;
                while (length > i2) {
                  key = keys2[i2++];
                  if (!DESCRIPTORS || propertyIsEnumerable2.call(O, key)) {
                    result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
                  }
                }
                return result;
              };
            };
            module3.exports = {
              entries: createMethod(true),
              values: createMethod(false)
            };
          },
          "73d9": function(module3, exports3, __webpack_require__) {
            var addToUnscopables = __webpack_require__("44d2");
            addToUnscopables("flatMap");
          },
          "7418": function(module3, exports3) {
            exports3.f = Object.getOwnPropertySymbols;
          },
          "746f": function(module3, exports3, __webpack_require__) {
            var path = __webpack_require__("428f");
            var has2 = __webpack_require__("5135");
            var wrappedWellKnownSymbolModule = __webpack_require__("e538");
            var defineProperty2 = __webpack_require__("9bf2").f;
            module3.exports = function(NAME) {
              var Symbol2 = path.Symbol || (path.Symbol = {});
              if (!has2(Symbol2, NAME))
                defineProperty2(Symbol2, NAME, {
                  value: wrappedWellKnownSymbolModule.f(NAME)
                });
            };
          },
          "7839": function(module3, exports3) {
            module3.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          },
          "7b0b": function(module3, exports3, __webpack_require__) {
            var requireObjectCoercible = __webpack_require__("1d80");
            module3.exports = function(argument) {
              return Object(requireObjectCoercible(argument));
            };
          },
          "7c73": function(module3, exports3, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            var defineProperties = __webpack_require__("37e8");
            var enumBugKeys = __webpack_require__("7839");
            var hiddenKeys = __webpack_require__("d012");
            var html = __webpack_require__("1be4");
            var documentCreateElement = __webpack_require__("cc12");
            var sharedKey = __webpack_require__("f772");
            var GT = ">";
            var LT = "<";
            var PROTOTYPE = "prototype";
            var SCRIPT = "script";
            var IE_PROTO = sharedKey("IE_PROTO");
            var EmptyConstructor = function() {
            };
            var scriptTag = function(content) {
              return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
            };
            var NullProtoObjectViaActiveX = function(activeXDocument2) {
              activeXDocument2.write(scriptTag(""));
              activeXDocument2.close();
              var temp = activeXDocument2.parentWindow.Object;
              activeXDocument2 = null;
              return temp;
            };
            var NullProtoObjectViaIFrame = function() {
              var iframe = documentCreateElement("iframe");
              var JS = "java" + SCRIPT + ":";
              var iframeDocument;
              iframe.style.display = "none";
              html.appendChild(iframe);
              iframe.src = String(JS);
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(scriptTag("document.F=Object"));
              iframeDocument.close();
              return iframeDocument.F;
            };
            var activeXDocument;
            var NullProtoObject = function() {
              try {
                activeXDocument = document.domain && new ActiveXObject("htmlfile");
              } catch (error) {
              }
              NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
              var length = enumBugKeys.length;
              while (length--)
                delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
              return NullProtoObject();
            };
            hiddenKeys[IE_PROTO] = true;
            module3.exports = Object.create || function create2(O, Properties) {
              var result;
              if (O !== null) {
                EmptyConstructor[PROTOTYPE] = anObject(O);
                result = new EmptyConstructor();
                EmptyConstructor[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else
                result = NullProtoObject();
              return Properties === void 0 ? result : defineProperties(result, Properties);
            };
          },
          "7dd0": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var createIteratorConstructor = __webpack_require__("9ed3");
            var getPrototypeOf = __webpack_require__("e163");
            var setPrototypeOf = __webpack_require__("d2bb");
            var setToStringTag = __webpack_require__("d44e");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var wellKnownSymbol = __webpack_require__("b622");
            var IS_PURE = __webpack_require__("c430");
            var Iterators = __webpack_require__("3f8c");
            var IteratorsCore = __webpack_require__("ae93");
            var IteratorPrototype = IteratorsCore.IteratorPrototype;
            var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
            var ITERATOR = wellKnownSymbol("iterator");
            var KEYS = "keys";
            var VALUES = "values";
            var ENTRIES = "entries";
            var returnThis = function() {
              return this;
            };
            module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
              createIteratorConstructor(IteratorConstructor, NAME, next);
              var getIterationMethod = function(KIND) {
                if (KIND === DEFAULT && defaultIterator)
                  return defaultIterator;
                if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                  return IterablePrototype[KIND];
                switch (KIND) {
                  case KEYS:
                    return function keys2() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case VALUES:
                    return function values() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case ENTRIES:
                    return function entries() {
                      return new IteratorConstructor(this, KIND);
                    };
                }
                return function() {
                  return new IteratorConstructor(this);
                };
              };
              var TO_STRING_TAG = NAME + " Iterator";
              var INCORRECT_VALUES_NAME = false;
              var IterablePrototype = Iterable.prototype;
              var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
              var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
              var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
              var CurrentIteratorPrototype, methods, KEY;
              if (anyNativeIterator) {
                CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                  if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                    if (setPrototypeOf) {
                      setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                    } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                      createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                    }
                  }
                  setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                  if (IS_PURE)
                    Iterators[TO_STRING_TAG] = returnThis;
                }
              }
              if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                INCORRECT_VALUES_NAME = true;
                defaultIterator = function values() {
                  return nativeIterator.call(this);
                };
              }
              if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
              }
              Iterators[NAME] = defaultIterator;
              if (DEFAULT) {
                methods = {
                  values: getIterationMethod(VALUES),
                  keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                  entries: getIterationMethod(ENTRIES)
                };
                if (FORCED)
                  for (KEY in methods) {
                    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                      redefine(IterablePrototype, KEY, methods[KEY]);
                    }
                  }
                else
                  $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
              }
              return methods;
            };
          },
          "7f9a": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var inspectSource = __webpack_require__("8925");
            var WeakMap2 = global2.WeakMap;
            module3.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
          },
          "825a": function(module3, exports3, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            module3.exports = function(it) {
              if (!isObject2(it)) {
                throw TypeError(String(it) + " is not an object");
              }
              return it;
            };
          },
          "83ab": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module3.exports = !fails(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          },
          "8418": function(module3, exports3, __webpack_require__) {
            var toPrimitive = __webpack_require__("c04e");
            var definePropertyModule = __webpack_require__("9bf2");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            module3.exports = function(object, key, value) {
              var propertyKey = toPrimitive(key);
              if (propertyKey in object)
                definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
              else
                object[propertyKey] = value;
            };
          },
          "861d": function(module3, exports3) {
            module3.exports = function(it) {
              return typeof it === "object" ? it !== null : typeof it === "function";
            };
          },
          "8875": function(module3, exports3, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(root2, factory) {
              {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports3, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              }
            })(typeof self !== "undefined" ? self : this, function() {
              function getCurrentScript() {
                var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
                if (!descriptor && "currentScript" in document && document.currentScript) {
                  return document.currentScript;
                }
                if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
                  return document.currentScript;
                }
                try {
                  throw new Error();
                } catch (err) {
                  var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
                  if (scriptLocation === currentLocation) {
                    pageSource = document.documentElement.outerHTML;
                    inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                    inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                  }
                  for (var i2 = 0; i2 < scripts.length; i2++) {
                    if (scripts[i2].readyState === "interactive") {
                      return scripts[i2];
                    }
                    if (scripts[i2].src === scriptLocation) {
                      return scripts[i2];
                    }
                    if (scriptLocation === currentLocation && scripts[i2].innerHTML && scripts[i2].innerHTML.trim() === inlineScriptSource) {
                      return scripts[i2];
                    }
                  }
                  return null;
                }
              }
              return getCurrentScript;
            });
          },
          "8925": function(module3, exports3, __webpack_require__) {
            var store = __webpack_require__("c6cd");
            var functionToString = Function.toString;
            if (typeof store.inspectSource != "function") {
              store.inspectSource = function(it) {
                return functionToString.call(it);
              };
            }
            module3.exports = store.inspectSource;
          },
          "8aa5": function(module3, exports3, __webpack_require__) {
            var charAt = __webpack_require__("6547").charAt;
            module3.exports = function(S, index2, unicode) {
              return index2 + (unicode ? charAt(S, index2).length : 1);
            };
          },
          "8bbf": function(module3, exports3) {
            module3.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
          },
          "90e3": function(module3, exports3) {
            var id = 0;
            var postfix = Math.random();
            module3.exports = function(key) {
              return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
            };
          },
          "9112": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var definePropertyModule = __webpack_require__("9bf2");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            module3.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          "9263": function(module3, exports3, __webpack_require__) {
            var regexpFlags = __webpack_require__("ad6d");
            var stickyHelpers = __webpack_require__("9f7f");
            var nativeExec = RegExp.prototype.exec;
            var nativeReplace = String.prototype.replace;
            var patchedExec = nativeExec;
            var UPDATES_LAST_INDEX_WRONG = function() {
              var re1 = /a/;
              var re2 = /b*/g;
              nativeExec.call(re1, "a");
              nativeExec.call(re2, "a");
              return re1.lastIndex !== 0 || re2.lastIndex !== 0;
            }();
            var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
            var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
            var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
            if (PATCH) {
              patchedExec = function exec(str) {
                var re = this;
                var lastIndex, reCopy, match, i2;
                var sticky = UNSUPPORTED_Y && re.sticky;
                var flags = regexpFlags.call(re);
                var source = re.source;
                var charsAdded = 0;
                var strCopy = str;
                if (sticky) {
                  flags = flags.replace("y", "");
                  if (flags.indexOf("g") === -1) {
                    flags += "g";
                  }
                  strCopy = String(str).slice(re.lastIndex);
                  if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
                    source = "(?: " + source + ")";
                    strCopy = " " + strCopy;
                    charsAdded++;
                  }
                  reCopy = new RegExp("^(?:" + source + ")", flags);
                }
                if (NPCG_INCLUDED) {
                  reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
                }
                if (UPDATES_LAST_INDEX_WRONG)
                  lastIndex = re.lastIndex;
                match = nativeExec.call(sticky ? reCopy : re, strCopy);
                if (sticky) {
                  if (match) {
                    match.input = match.input.slice(charsAdded);
                    match[0] = match[0].slice(charsAdded);
                    match.index = re.lastIndex;
                    re.lastIndex += match[0].length;
                  } else
                    re.lastIndex = 0;
                } else if (UPDATES_LAST_INDEX_WRONG && match) {
                  re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
                }
                if (NPCG_INCLUDED && match && match.length > 1) {
                  nativeReplace.call(match[0], reCopy, function() {
                    for (i2 = 1; i2 < arguments.length - 2; i2++) {
                      if (arguments[i2] === void 0)
                        match[i2] = void 0;
                    }
                  });
                }
                return match;
              };
            }
            module3.exports = patchedExec;
          },
          "94ca": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data2[normalize(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string2) {
              return String(string2).replace(replacement, ".").toLowerCase();
            };
            var data2 = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module3.exports = isForced;
          },
          "99af": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var fails = __webpack_require__("d039");
            var isArray2 = __webpack_require__("e8b5");
            var isObject2 = __webpack_require__("861d");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var createProperty = __webpack_require__("8418");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var wellKnownSymbol = __webpack_require__("b622");
            var V8_VERSION = __webpack_require__("2d00");
            var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
            var MAX_SAFE_INTEGER2 = 9007199254740991;
            var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
            var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
              var array2 = [];
              array2[IS_CONCAT_SPREADABLE] = false;
              return array2.concat()[0] !== array2;
            });
            var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
            var isConcatSpreadable = function(O) {
              if (!isObject2(O))
                return false;
              var spreadable = O[IS_CONCAT_SPREADABLE];
              return spreadable !== void 0 ? !!spreadable : isArray2(O);
            };
            var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
            $({ target: "Array", proto: true, forced: FORCED }, {
              concat: function concat2(arg) {
                var O = toObject(this);
                var A2 = arraySpeciesCreate(O, 0);
                var n = 0;
                var i2, k, length, len, E;
                for (i2 = -1, length = arguments.length; i2 < length; i2++) {
                  E = i2 === -1 ? O : arguments[i2];
                  if (isConcatSpreadable(E)) {
                    len = toLength(E.length);
                    if (n + len > MAX_SAFE_INTEGER2)
                      throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                    for (k = 0; k < len; k++, n++)
                      if (k in E)
                        createProperty(A2, n, E[k]);
                  } else {
                    if (n >= MAX_SAFE_INTEGER2)
                      throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                    createProperty(A2, n++, E);
                  }
                }
                A2.length = n;
                return A2;
              }
            });
          },
          "9bdd": function(module3, exports3, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            module3.exports = function(iterator, fn, value, ENTRIES) {
              try {
                return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
              } catch (error) {
                var returnMethod = iterator["return"];
                if (returnMethod !== void 0)
                  anObject(returnMethod.call(iterator));
                throw error;
              }
            };
          },
          "9bf2": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var IE8_DOM_DEFINE = __webpack_require__("0cfb");
            var anObject = __webpack_require__("825a");
            var toPrimitive = __webpack_require__("c04e");
            var nativeDefineProperty = Object.defineProperty;
            exports3.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty2(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeDefineProperty(O, P, Attributes);
                } catch (error) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported");
              if ("value" in Attributes)
                O[P] = Attributes.value;
              return O;
            };
          },
          "9ed3": function(module3, exports3, __webpack_require__) {
            var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
            var create2 = __webpack_require__("7c73");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var setToStringTag = __webpack_require__("d44e");
            var Iterators = __webpack_require__("3f8c");
            var returnThis = function() {
              return this;
            };
            module3.exports = function(IteratorConstructor, NAME, next) {
              var TO_STRING_TAG = NAME + " Iterator";
              IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
              setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
              Iterators[TO_STRING_TAG] = returnThis;
              return IteratorConstructor;
            };
          },
          "9f7f": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            function RE(s, f) {
              return RegExp(s, f);
            }
            exports3.UNSUPPORTED_Y = fails(function() {
              var re = RE("a", "y");
              re.lastIndex = 2;
              return re.exec("abcd") != null;
            });
            exports3.BROKEN_CARET = fails(function() {
              var re = RE("^r", "gy");
              re.lastIndex = 2;
              return re.exec("str") != null;
            });
          },
          "a2bf": function(module3, exports3, __webpack_require__) {
            var isArray2 = __webpack_require__("e8b5");
            var toLength = __webpack_require__("50c4");
            var bind3 = __webpack_require__("0366");
            var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
              var targetIndex = start;
              var sourceIndex = 0;
              var mapFn = mapper ? bind3(mapper, thisArg, 3) : false;
              var element;
              while (sourceIndex < sourceLen) {
                if (sourceIndex in source) {
                  element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                  if (depth > 0 && isArray2(element)) {
                    targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
                  } else {
                    if (targetIndex >= 9007199254740991)
                      throw TypeError("Exceed the acceptable array length");
                    target[targetIndex] = element;
                  }
                  targetIndex++;
                }
                sourceIndex++;
              }
              return targetIndex;
            };
            module3.exports = flattenIntoArray;
          },
          "a352": function(module3, exports3) {
            module3.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
          },
          "a434": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var toInteger2 = __webpack_require__("a691");
            var toLength = __webpack_require__("50c4");
            var toObject = __webpack_require__("7b0b");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var createProperty = __webpack_require__("8418");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
            var USES_TO_LENGTH = arrayMethodUsesToLength("splice", { ACCESSORS: true, 0: 0, 1: 2 });
            var max2 = Math.max;
            var min2 = Math.min;
            var MAX_SAFE_INTEGER2 = 9007199254740991;
            var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
            $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              splice: function splice2(start, deleteCount) {
                var O = toObject(this);
                var len = toLength(O.length);
                var actualStart = toAbsoluteIndex(start, len);
                var argumentsLength = arguments.length;
                var insertCount, actualDeleteCount, A2, k, from, to;
                if (argumentsLength === 0) {
                  insertCount = actualDeleteCount = 0;
                } else if (argumentsLength === 1) {
                  insertCount = 0;
                  actualDeleteCount = len - actualStart;
                } else {
                  insertCount = argumentsLength - 2;
                  actualDeleteCount = min2(max2(toInteger2(deleteCount), 0), len - actualStart);
                }
                if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER2) {
                  throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                }
                A2 = arraySpeciesCreate(O, actualDeleteCount);
                for (k = 0; k < actualDeleteCount; k++) {
                  from = actualStart + k;
                  if (from in O)
                    createProperty(A2, k, O[from]);
                }
                A2.length = actualDeleteCount;
                if (insertCount < actualDeleteCount) {
                  for (k = actualStart; k < len - actualDeleteCount; k++) {
                    from = k + actualDeleteCount;
                    to = k + insertCount;
                    if (from in O)
                      O[to] = O[from];
                    else
                      delete O[to];
                  }
                  for (k = len; k > len - actualDeleteCount + insertCount; k--)
                    delete O[k - 1];
                } else if (insertCount > actualDeleteCount) {
                  for (k = len - actualDeleteCount; k > actualStart; k--) {
                    from = k + actualDeleteCount - 1;
                    to = k + insertCount - 1;
                    if (from in O)
                      O[to] = O[from];
                    else
                      delete O[to];
                  }
                }
                for (k = 0; k < insertCount; k++) {
                  O[k + actualStart] = arguments[k + 2];
                }
                O.length = len - actualDeleteCount + insertCount;
                return A2;
              }
            });
          },
          "a4d3": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var global2 = __webpack_require__("da84");
            var getBuiltIn = __webpack_require__("d066");
            var IS_PURE = __webpack_require__("c430");
            var DESCRIPTORS = __webpack_require__("83ab");
            var NATIVE_SYMBOL = __webpack_require__("4930");
            var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
            var fails = __webpack_require__("d039");
            var has2 = __webpack_require__("5135");
            var isArray2 = __webpack_require__("e8b5");
            var isObject2 = __webpack_require__("861d");
            var anObject = __webpack_require__("825a");
            var toObject = __webpack_require__("7b0b");
            var toIndexedObject = __webpack_require__("fc6a");
            var toPrimitive = __webpack_require__("c04e");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var nativeObjectCreate = __webpack_require__("7c73");
            var objectKeys = __webpack_require__("df75");
            var getOwnPropertyNamesModule = __webpack_require__("241c");
            var getOwnPropertyNamesExternal = __webpack_require__("057f");
            var getOwnPropertySymbolsModule = __webpack_require__("7418");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var definePropertyModule = __webpack_require__("9bf2");
            var propertyIsEnumerableModule = __webpack_require__("d1e7");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var shared = __webpack_require__("5692");
            var sharedKey = __webpack_require__("f772");
            var hiddenKeys = __webpack_require__("d012");
            var uid2 = __webpack_require__("90e3");
            var wellKnownSymbol = __webpack_require__("b622");
            var wrappedWellKnownSymbolModule = __webpack_require__("e538");
            var defineWellKnownSymbol = __webpack_require__("746f");
            var setToStringTag = __webpack_require__("d44e");
            var InternalStateModule = __webpack_require__("69f3");
            var $forEach = __webpack_require__("b727").forEach;
            var HIDDEN = sharedKey("hidden");
            var SYMBOL = "Symbol";
            var PROTOTYPE = "prototype";
            var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(SYMBOL);
            var ObjectPrototype = Object[PROTOTYPE];
            var $Symbol = global2.Symbol;
            var $stringify = getBuiltIn("JSON", "stringify");
            var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            var nativeDefineProperty = definePropertyModule.f;
            var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
            var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
            var AllSymbols = shared("symbols");
            var ObjectPrototypeSymbols = shared("op-symbols");
            var StringToSymbolRegistry = shared("string-to-symbol-registry");
            var SymbolToStringRegistry = shared("symbol-to-string-registry");
            var WellKnownSymbolsStore = shared("wks");
            var QObject = global2.QObject;
            var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
            var setSymbolDescriptor = DESCRIPTORS && fails(function() {
              return nativeObjectCreate(nativeDefineProperty({}, "a", {
                get: function() {
                  return nativeDefineProperty(this, "a", { value: 7 }).a;
                }
              })).a != 7;
            }) ? function(O, P, Attributes) {
              var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
              if (ObjectPrototypeDescriptor)
                delete ObjectPrototype[P];
              nativeDefineProperty(O, P, Attributes);
              if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
              }
            } : nativeDefineProperty;
            var wrap = function(tag, description) {
              var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
              setInternalState(symbol, {
                type: SYMBOL,
                tag,
                description
              });
              if (!DESCRIPTORS)
                symbol.description = description;
              return symbol;
            };
            var isSymbol2 = USE_SYMBOL_AS_UID ? function(it) {
              return typeof it == "symbol";
            } : function(it) {
              return Object(it) instanceof $Symbol;
            };
            var $defineProperty = function defineProperty2(O, P, Attributes) {
              if (O === ObjectPrototype)
                $defineProperty(ObjectPrototypeSymbols, P, Attributes);
              anObject(O);
              var key = toPrimitive(P, true);
              anObject(Attributes);
              if (has2(AllSymbols, key)) {
                if (!Attributes.enumerable) {
                  if (!has2(O, HIDDEN))
                    nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                  O[HIDDEN][key] = true;
                } else {
                  if (has2(O, HIDDEN) && O[HIDDEN][key])
                    O[HIDDEN][key] = false;
                  Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
                }
                return setSymbolDescriptor(O, key, Attributes);
              }
              return nativeDefineProperty(O, key, Attributes);
            };
            var $defineProperties = function defineProperties(O, Properties) {
              anObject(O);
              var properties = toIndexedObject(Properties);
              var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
              $forEach(keys2, function(key) {
                if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))
                  $defineProperty(O, key, properties[key]);
              });
              return O;
            };
            var $create = function create2(O, Properties) {
              return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
            };
            var $propertyIsEnumerable = function propertyIsEnumerable2(V) {
              var P = toPrimitive(V, true);
              var enumerable = nativePropertyIsEnumerable.call(this, P);
              if (this === ObjectPrototype && has2(AllSymbols, P) && !has2(ObjectPrototypeSymbols, P))
                return false;
              return enumerable || !has2(this, P) || !has2(AllSymbols, P) || has2(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
              var it = toIndexedObject(O);
              var key = toPrimitive(P, true);
              if (it === ObjectPrototype && has2(AllSymbols, key) && !has2(ObjectPrototypeSymbols, key))
                return;
              var descriptor = nativeGetOwnPropertyDescriptor(it, key);
              if (descriptor && has2(AllSymbols, key) && !(has2(it, HIDDEN) && it[HIDDEN][key])) {
                descriptor.enumerable = true;
              }
              return descriptor;
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(O) {
              var names2 = nativeGetOwnPropertyNames(toIndexedObject(O));
              var result = [];
              $forEach(names2, function(key) {
                if (!has2(AllSymbols, key) && !has2(hiddenKeys, key))
                  result.push(key);
              });
              return result;
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
              var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
              var names2 = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
              var result = [];
              $forEach(names2, function(key) {
                if (has2(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has2(ObjectPrototype, key))) {
                  result.push(AllSymbols[key]);
                }
              });
              return result;
            };
            if (!NATIVE_SYMBOL) {
              $Symbol = function Symbol2() {
                if (this instanceof $Symbol)
                  throw TypeError("Symbol is not a constructor");
                var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                var tag = uid2(description);
                var setter = function(value) {
                  if (this === ObjectPrototype)
                    setter.call(ObjectPrototypeSymbols, value);
                  if (has2(this, HIDDEN) && has2(this[HIDDEN], tag))
                    this[HIDDEN][tag] = false;
                  setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                };
                if (DESCRIPTORS && USE_SETTER)
                  setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
                return wrap(tag, description);
              };
              redefine($Symbol[PROTOTYPE], "toString", function toString2() {
                return getInternalState(this).tag;
              });
              redefine($Symbol, "withoutSetter", function(description) {
                return wrap(uid2(description), description);
              });
              propertyIsEnumerableModule.f = $propertyIsEnumerable;
              definePropertyModule.f = $defineProperty;
              getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
              getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
              getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
              wrappedWellKnownSymbolModule.f = function(name) {
                return wrap(wellKnownSymbol(name), name);
              };
              if (DESCRIPTORS) {
                nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                  configurable: true,
                  get: function description() {
                    return getInternalState(this).description;
                  }
                });
                if (!IS_PURE) {
                  redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
                }
              }
            }
            $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
              Symbol: $Symbol
            });
            $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
              defineWellKnownSymbol(name);
            });
            $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
              "for": function(key) {
                var string2 = String(key);
                if (has2(StringToSymbolRegistry, string2))
                  return StringToSymbolRegistry[string2];
                var symbol = $Symbol(string2);
                StringToSymbolRegistry[string2] = symbol;
                SymbolToStringRegistry[symbol] = string2;
                return symbol;
              },
              keyFor: function keyFor(sym) {
                if (!isSymbol2(sym))
                  throw TypeError(sym + " is not a symbol");
                if (has2(SymbolToStringRegistry, sym))
                  return SymbolToStringRegistry[sym];
              },
              useSetter: function() {
                USE_SETTER = true;
              },
              useSimple: function() {
                USE_SETTER = false;
              }
            });
            $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
              create: $create,
              defineProperty: $defineProperty,
              defineProperties: $defineProperties,
              getOwnPropertyDescriptor: $getOwnPropertyDescriptor
            });
            $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
              getOwnPropertyNames: $getOwnPropertyNames,
              getOwnPropertySymbols: $getOwnPropertySymbols
            });
            $({ target: "Object", stat: true, forced: fails(function() {
              getOwnPropertySymbolsModule.f(1);
            }) }, {
              getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                return getOwnPropertySymbolsModule.f(toObject(it));
              }
            });
            if ($stringify) {
              var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                var symbol = $Symbol();
                return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
              });
              $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
                stringify: function stringify2(it, replacer2, space) {
                  var args = [it];
                  var index2 = 1;
                  var $replacer;
                  while (arguments.length > index2)
                    args.push(arguments[index2++]);
                  $replacer = replacer2;
                  if (!isObject2(replacer2) && it === void 0 || isSymbol2(it))
                    return;
                  if (!isArray2(replacer2))
                    replacer2 = function(key, value) {
                      if (typeof $replacer == "function")
                        value = $replacer.call(this, key, value);
                      if (!isSymbol2(value))
                        return value;
                    };
                  args[1] = replacer2;
                  return $stringify.apply(null, args);
                }
              });
            }
            if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
              createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
            }
            setToStringTag($Symbol, SYMBOL);
            hiddenKeys[HIDDEN] = true;
          },
          "a630": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var from = __webpack_require__("4df4");
            var checkCorrectnessOfIteration = __webpack_require__("1c7e");
            var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
              Array.from(iterable);
            });
            $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
              from
            });
          },
          "a640": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module3.exports = function(METHOD_NAME, argument) {
              var method = [][METHOD_NAME];
              return !!method && fails(function() {
                method.call(null, argument || function() {
                  throw 1;
                }, 1);
              });
            };
          },
          "a691": function(module3, exports3) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module3.exports = function(argument) {
              return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
            };
          },
          "ab13": function(module3, exports3, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var MATCH = wellKnownSymbol("match");
            module3.exports = function(METHOD_NAME) {
              var regexp = /./;
              try {
                "/./"[METHOD_NAME](regexp);
              } catch (e) {
                try {
                  regexp[MATCH] = false;
                  return "/./"[METHOD_NAME](regexp);
                } catch (f) {
                }
              }
              return false;
            };
          },
          "ac1f": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var exec = __webpack_require__("9263");
            $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
              exec
            });
          },
          "ad6d": function(module3, exports3, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            module3.exports = function() {
              var that = anObject(this);
              var result = "";
              if (that.global)
                result += "g";
              if (that.ignoreCase)
                result += "i";
              if (that.multiline)
                result += "m";
              if (that.dotAll)
                result += "s";
              if (that.unicode)
                result += "u";
              if (that.sticky)
                result += "y";
              return result;
            };
          },
          "ae40": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var fails = __webpack_require__("d039");
            var has2 = __webpack_require__("5135");
            var defineProperty2 = Object.defineProperty;
            var cache2 = {};
            var thrower = function(it) {
              throw it;
            };
            module3.exports = function(METHOD_NAME, options) {
              if (has2(cache2, METHOD_NAME))
                return cache2[METHOD_NAME];
              if (!options)
                options = {};
              var method = [][METHOD_NAME];
              var ACCESSORS = has2(options, "ACCESSORS") ? options.ACCESSORS : false;
              var argument0 = has2(options, 0) ? options[0] : thrower;
              var argument1 = has2(options, 1) ? options[1] : void 0;
              return cache2[METHOD_NAME] = !!method && !fails(function() {
                if (ACCESSORS && !DESCRIPTORS)
                  return true;
                var O = { length: -1 };
                if (ACCESSORS)
                  defineProperty2(O, 1, { enumerable: true, get: thrower });
                else
                  O[1] = 1;
                method.call(O, argument0, argument1);
              });
            };
          },
          "ae93": function(module3, exports3, __webpack_require__) {
            var getPrototypeOf = __webpack_require__("e163");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var has2 = __webpack_require__("5135");
            var wellKnownSymbol = __webpack_require__("b622");
            var IS_PURE = __webpack_require__("c430");
            var ITERATOR = wellKnownSymbol("iterator");
            var BUGGY_SAFARI_ITERATORS = false;
            var returnThis = function() {
              return this;
            };
            var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
            if ([].keys) {
              arrayIterator = [].keys();
              if (!("next" in arrayIterator))
                BUGGY_SAFARI_ITERATORS = true;
              else {
                PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                  IteratorPrototype = PrototypeOfArrayIteratorPrototype;
              }
            }
            if (IteratorPrototype == void 0)
              IteratorPrototype = {};
            if (!IS_PURE && !has2(IteratorPrototype, ITERATOR)) {
              createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
            }
            module3.exports = {
              IteratorPrototype,
              BUGGY_SAFARI_ITERATORS
            };
          },
          "b041": function(module3, exports3, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var classof = __webpack_require__("f5df");
            module3.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
              return "[object " + classof(this) + "]";
            };
          },
          "b0c0": function(module3, exports3, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var defineProperty2 = __webpack_require__("9bf2").f;
            var FunctionPrototype = Function.prototype;
            var FunctionPrototypeToString = FunctionPrototype.toString;
            var nameRE = /^\s*function ([^ (]*)/;
            var NAME = "name";
            if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
              defineProperty2(FunctionPrototype, NAME, {
                configurable: true,
                get: function() {
                  try {
                    return FunctionPrototypeToString.call(this).match(nameRE)[1];
                  } catch (error) {
                    return "";
                  }
                }
              });
            }
          },
          "b622": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var shared = __webpack_require__("5692");
            var has2 = __webpack_require__("5135");
            var uid2 = __webpack_require__("90e3");
            var NATIVE_SYMBOL = __webpack_require__("4930");
            var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
            var WellKnownSymbolsStore = shared("wks");
            var Symbol2 = global2.Symbol;
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
            module3.exports = function(name) {
              if (!has2(WellKnownSymbolsStore, name)) {
                if (NATIVE_SYMBOL && has2(Symbol2, name))
                  WellKnownSymbolsStore[name] = Symbol2[name];
                else
                  WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
              }
              return WellKnownSymbolsStore[name];
            };
          },
          "b64b": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var toObject = __webpack_require__("7b0b");
            var nativeKeys2 = __webpack_require__("df75");
            var fails = __webpack_require__("d039");
            var FAILS_ON_PRIMITIVES = fails(function() {
              nativeKeys2(1);
            });
            $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
              keys: function keys2(it) {
                return nativeKeys2(toObject(it));
              }
            });
          },
          "b727": function(module3, exports3, __webpack_require__) {
            var bind3 = __webpack_require__("0366");
            var IndexedObject = __webpack_require__("44ad");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var push = [].push;
            var createMethod = function(TYPE2) {
              var IS_MAP = TYPE2 == 1;
              var IS_FILTER = TYPE2 == 2;
              var IS_SOME = TYPE2 == 3;
              var IS_EVERY = TYPE2 == 4;
              var IS_FIND_INDEX = TYPE2 == 6;
              var NO_HOLES = TYPE2 == 5 || IS_FIND_INDEX;
              return function($this, callbackfn, that, specificCreate) {
                var O = toObject($this);
                var self2 = IndexedObject(O);
                var boundFunction = bind3(callbackfn, that, 3);
                var length = toLength(self2.length);
                var index2 = 0;
                var create2 = specificCreate || arraySpeciesCreate;
                var target = IS_MAP ? create2($this, length) : IS_FILTER ? create2($this, 0) : void 0;
                var value, result;
                for (; length > index2; index2++)
                  if (NO_HOLES || index2 in self2) {
                    value = self2[index2];
                    result = boundFunction(value, index2, O);
                    if (TYPE2) {
                      if (IS_MAP)
                        target[index2] = result;
                      else if (result)
                        switch (TYPE2) {
                          case 3:
                            return true;
                          case 5:
                            return value;
                          case 6:
                            return index2;
                          case 2:
                            push.call(target, value);
                        }
                      else if (IS_EVERY)
                        return false;
                    }
                  }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
              };
            };
            module3.exports = {
              forEach: createMethod(0),
              map: createMethod(1),
              filter: createMethod(2),
              some: createMethod(3),
              every: createMethod(4),
              find: createMethod(5),
              findIndex: createMethod(6)
            };
          },
          "c04e": function(module3, exports3, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            module3.exports = function(input, PREFERRED_STRING) {
              if (!isObject2(input))
                return input;
              var fn, val;
              if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input)))
                return val;
              if (typeof (fn = input.valueOf) == "function" && !isObject2(val = fn.call(input)))
                return val;
              if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input)))
                return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          "c430": function(module3, exports3) {
            module3.exports = false;
          },
          "c6b6": function(module3, exports3) {
            var toString2 = {}.toString;
            module3.exports = function(it) {
              return toString2.call(it).slice(8, -1);
            };
          },
          "c6cd": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var setGlobal = __webpack_require__("ce4e");
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || setGlobal(SHARED, {});
            module3.exports = store;
          },
          "c740": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $findIndex = __webpack_require__("b727").findIndex;
            var addToUnscopables = __webpack_require__("44d2");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var FIND_INDEX = "findIndex";
            var SKIPS_HOLES = true;
            var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
            if (FIND_INDEX in [])
              Array(1)[FIND_INDEX](function() {
                SKIPS_HOLES = false;
              });
            $({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
              findIndex: function findIndex(callbackfn) {
                return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            addToUnscopables(FIND_INDEX);
          },
          "c8ba": function(module3, exports3) {
            var g;
            g = function() {
              return this;
            }();
            try {
              g = g || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                g = window;
            }
            module3.exports = g;
          },
          "c975": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $indexOf2 = __webpack_require__("4d64").indexOf;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var nativeIndexOf = [].indexOf;
            var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
            var STRICT_METHOD = arrayMethodIsStrict("indexOf");
            var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
            $({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
              indexOf: function indexOf(searchElement) {
                return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf2(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          "ca84": function(module3, exports3, __webpack_require__) {
            var has2 = __webpack_require__("5135");
            var toIndexedObject = __webpack_require__("fc6a");
            var indexOf = __webpack_require__("4d64").indexOf;
            var hiddenKeys = __webpack_require__("d012");
            module3.exports = function(object, names2) {
              var O = toIndexedObject(object);
              var i2 = 0;
              var result = [];
              var key;
              for (key in O)
                !has2(hiddenKeys, key) && has2(O, key) && result.push(key);
              while (names2.length > i2)
                if (has2(O, key = names2[i2++])) {
                  ~indexOf(result, key) || result.push(key);
                }
              return result;
            };
          },
          "caad": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $includes = __webpack_require__("4d64").includes;
            var addToUnscopables = __webpack_require__("44d2");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
            $({ target: "Array", proto: true, forced: !USES_TO_LENGTH }, {
              includes: function includes(el) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            addToUnscopables("includes");
          },
          "cc12": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var isObject2 = __webpack_require__("861d");
            var document2 = global2.document;
            var EXISTS = isObject2(document2) && isObject2(document2.createElement);
            module3.exports = function(it) {
              return EXISTS ? document2.createElement(it) : {};
            };
          },
          "ce4e": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var createNonEnumerableProperty = __webpack_require__("9112");
            module3.exports = function(key, value) {
              try {
                createNonEnumerableProperty(global2, key, value);
              } catch (error) {
                global2[key] = value;
              }
              return value;
            };
          },
          "d012": function(module3, exports3) {
            module3.exports = {};
          },
          "d039": function(module3, exports3) {
            module3.exports = function(exec) {
              try {
                return !!exec();
              } catch (error) {
                return true;
              }
            };
          },
          "d066": function(module3, exports3, __webpack_require__) {
            var path = __webpack_require__("428f");
            var global2 = __webpack_require__("da84");
            var aFunction = function(variable) {
              return typeof variable == "function" ? variable : void 0;
            };
            module3.exports = function(namespace, method) {
              return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
            };
          },
          "d1e7": function(module3, exports3, __webpack_require__) {
            var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
            exports3.f = NASHORN_BUG ? function propertyIsEnumerable2(V) {
              var descriptor = getOwnPropertyDescriptor(this, V);
              return !!descriptor && descriptor.enumerable;
            } : nativePropertyIsEnumerable;
          },
          "d28b": function(module3, exports3, __webpack_require__) {
            var defineWellKnownSymbol = __webpack_require__("746f");
            defineWellKnownSymbol("iterator");
          },
          "d2bb": function(module3, exports3, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            var aPossiblePrototype = __webpack_require__("3bbe");
            module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var CORRECT_SETTER = false;
              var test = {};
              var setter;
              try {
                setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                setter.call(test, []);
                CORRECT_SETTER = test instanceof Array;
              } catch (error) {
              }
              return function setPrototypeOf(O, proto) {
                anObject(O);
                aPossiblePrototype(proto);
                if (CORRECT_SETTER)
                  setter.call(O, proto);
                else
                  O.__proto__ = proto;
                return O;
              };
            }() : void 0);
          },
          "d3b7": function(module3, exports3, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var redefine = __webpack_require__("6eeb");
            var toString2 = __webpack_require__("b041");
            if (!TO_STRING_TAG_SUPPORT) {
              redefine(Object.prototype, "toString", toString2, { unsafe: true });
            }
          },
          "d44e": function(module3, exports3, __webpack_require__) {
            var defineProperty2 = __webpack_require__("9bf2").f;
            var has2 = __webpack_require__("5135");
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            module3.exports = function(it, TAG, STATIC) {
              if (it && !has2(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                defineProperty2(it, TO_STRING_TAG, { configurable: true, value: TAG });
              }
            };
          },
          "d58f": function(module3, exports3, __webpack_require__) {
            var aFunction = __webpack_require__("1c0b");
            var toObject = __webpack_require__("7b0b");
            var IndexedObject = __webpack_require__("44ad");
            var toLength = __webpack_require__("50c4");
            var createMethod = function(IS_RIGHT) {
              return function(that, callbackfn, argumentsLength, memo) {
                aFunction(callbackfn);
                var O = toObject(that);
                var self2 = IndexedObject(O);
                var length = toLength(O.length);
                var index2 = IS_RIGHT ? length - 1 : 0;
                var i2 = IS_RIGHT ? -1 : 1;
                if (argumentsLength < 2)
                  while (true) {
                    if (index2 in self2) {
                      memo = self2[index2];
                      index2 += i2;
                      break;
                    }
                    index2 += i2;
                    if (IS_RIGHT ? index2 < 0 : length <= index2) {
                      throw TypeError("Reduce of empty array with no initial value");
                    }
                  }
                for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2)
                  if (index2 in self2) {
                    memo = callbackfn(memo, self2[index2], index2, O);
                  }
                return memo;
              };
            };
            module3.exports = {
              left: createMethod(false),
              right: createMethod(true)
            };
          },
          "d784": function(module3, exports3, __webpack_require__) {
            __webpack_require__("ac1f");
            var redefine = __webpack_require__("6eeb");
            var fails = __webpack_require__("d039");
            var wellKnownSymbol = __webpack_require__("b622");
            var regexpExec = __webpack_require__("9263");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var SPECIES = wellKnownSymbol("species");
            var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
              var re = /./;
              re.exec = function() {
                var result = [];
                result.groups = { a: "7" };
                return result;
              };
              return "".replace(re, "$<a>") !== "7";
            });
            var REPLACE_KEEPS_$0 = function() {
              return "a".replace(/./, "$0") === "$0";
            }();
            var REPLACE = wellKnownSymbol("replace");
            var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
              if (/./[REPLACE]) {
                return /./[REPLACE]("a", "$0") === "";
              }
              return false;
            }();
            var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
              var re = /(?:)/;
              var originalExec = re.exec;
              re.exec = function() {
                return originalExec.apply(this, arguments);
              };
              var result = "ab".split(re);
              return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
            });
            module3.exports = function(KEY, length, exec, sham) {
              var SYMBOL = wellKnownSymbol(KEY);
              var DELEGATES_TO_SYMBOL = !fails(function() {
                var O = {};
                O[SYMBOL] = function() {
                  return 7;
                };
                return ""[KEY](O) != 7;
              });
              var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                var execCalled = false;
                var re = /a/;
                if (KEY === "split") {
                  re = {};
                  re.constructor = {};
                  re.constructor[SPECIES] = function() {
                    return re;
                  };
                  re.flags = "";
                  re[SYMBOL] = /./[SYMBOL];
                }
                re.exec = function() {
                  execCalled = true;
                  return null;
                };
                re[SYMBOL]("");
                return !execCalled;
              });
              if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                var nativeRegExpMethod = /./[SYMBOL];
                var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                  if (regexp.exec === regexpExec) {
                    if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                      return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                    }
                    return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                  }
                  return { done: false };
                }, {
                  REPLACE_KEEPS_$0,
                  REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                });
                var stringMethod = methods[0];
                var regexMethod = methods[1];
                redefine(String.prototype, KEY, stringMethod);
                redefine(RegExp.prototype, SYMBOL, length == 2 ? function(string2, arg) {
                  return regexMethod.call(string2, this, arg);
                } : function(string2) {
                  return regexMethod.call(string2, this);
                });
              }
              if (sham)
                createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
            };
          },
          "d81d": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $map = __webpack_require__("b727").map;
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
            var USES_TO_LENGTH = arrayMethodUsesToLength("map");
            $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              map: function map(callbackfn) {
                return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          "da84": function(module3, exports3, __webpack_require__) {
            (function(global2) {
              var check = function(it) {
                return it && it.Math == Math && it;
              };
              module3.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global2 == "object" && global2) || Function("return this")();
            }).call(this, __webpack_require__("c8ba"));
          },
          "dbb4": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var DESCRIPTORS = __webpack_require__("83ab");
            var ownKeys2 = __webpack_require__("56ef");
            var toIndexedObject = __webpack_require__("fc6a");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var createProperty = __webpack_require__("8418");
            $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
              getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                var O = toIndexedObject(object);
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var keys2 = ownKeys2(O);
                var result = {};
                var index2 = 0;
                var key, descriptor;
                while (keys2.length > index2) {
                  descriptor = getOwnPropertyDescriptor(O, key = keys2[index2++]);
                  if (descriptor !== void 0)
                    createProperty(result, key, descriptor);
                }
                return result;
              }
            });
          },
          "dbf1": function(module3, __webpack_exports__, __webpack_require__) {
            (function(global2) {
              __webpack_require__.d(__webpack_exports__, "a", function() {
                return console2;
              });
              function getConsole() {
                if (typeof window !== "undefined") {
                  return window.console;
                }
                return global2.console;
              }
              var console2 = getConsole();
            }).call(this, __webpack_require__("c8ba"));
          },
          "ddb0": function(module3, exports3, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var DOMIterables = __webpack_require__("fdbc");
            var ArrayIteratorMethods = __webpack_require__("e260");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var ArrayValues = ArrayIteratorMethods.values;
            for (var COLLECTION_NAME in DOMIterables) {
              var Collection = global2[COLLECTION_NAME];
              var CollectionPrototype = Collection && Collection.prototype;
              if (CollectionPrototype) {
                if (CollectionPrototype[ITERATOR] !== ArrayValues)
                  try {
                    createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                  } catch (error) {
                    CollectionPrototype[ITERATOR] = ArrayValues;
                  }
                if (!CollectionPrototype[TO_STRING_TAG]) {
                  createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                }
                if (DOMIterables[COLLECTION_NAME])
                  for (var METHOD_NAME in ArrayIteratorMethods) {
                    if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                      try {
                        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                      } catch (error) {
                        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                      }
                  }
              }
            }
          },
          "df75": function(module3, exports3, __webpack_require__) {
            var internalObjectKeys = __webpack_require__("ca84");
            var enumBugKeys = __webpack_require__("7839");
            module3.exports = Object.keys || function keys2(O) {
              return internalObjectKeys(O, enumBugKeys);
            };
          },
          "e01a": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var DESCRIPTORS = __webpack_require__("83ab");
            var global2 = __webpack_require__("da84");
            var has2 = __webpack_require__("5135");
            var isObject2 = __webpack_require__("861d");
            var defineProperty2 = __webpack_require__("9bf2").f;
            var copyConstructorProperties = __webpack_require__("e893");
            var NativeSymbol = global2.Symbol;
            if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || NativeSymbol().description !== void 0)) {
              var EmptyStringDescriptionStore = {};
              var SymbolWrapper = function Symbol2() {
                var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
                if (description === "")
                  EmptyStringDescriptionStore[result] = true;
                return result;
              };
              copyConstructorProperties(SymbolWrapper, NativeSymbol);
              var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
              symbolPrototype.constructor = SymbolWrapper;
              var symbolToString2 = symbolPrototype.toString;
              var native = String(NativeSymbol("test")) == "Symbol(test)";
              var regexp = /^Symbol\((.*)\)[^)]+$/;
              defineProperty2(symbolPrototype, "description", {
                configurable: true,
                get: function description() {
                  var symbol = isObject2(this) ? this.valueOf() : this;
                  var string2 = symbolToString2.call(symbol);
                  if (has2(EmptyStringDescriptionStore, symbol))
                    return "";
                  var desc = native ? string2.slice(7, -1) : string2.replace(regexp, "$1");
                  return desc === "" ? void 0 : desc;
                }
              });
              $({ global: true, forced: true }, {
                Symbol: SymbolWrapper
              });
            }
          },
          "e163": function(module3, exports3, __webpack_require__) {
            var has2 = __webpack_require__("5135");
            var toObject = __webpack_require__("7b0b");
            var sharedKey = __webpack_require__("f772");
            var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
            var IE_PROTO = sharedKey("IE_PROTO");
            var ObjectPrototype = Object.prototype;
            module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
              O = toObject(O);
              if (has2(O, IE_PROTO))
                return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectPrototype : null;
            };
          },
          "e177": function(module3, exports3, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module3.exports = !fails(function() {
              function F() {
              }
              F.prototype.constructor = null;
              return Object.getPrototypeOf(new F()) !== F.prototype;
            });
          },
          "e260": function(module3, exports3, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var addToUnscopables = __webpack_require__("44d2");
            var Iterators = __webpack_require__("3f8c");
            var InternalStateModule = __webpack_require__("69f3");
            var defineIterator = __webpack_require__("7dd0");
            var ARRAY_ITERATOR = "Array Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
            module3.exports = defineIterator(Array, "Array", function(iterated, kind) {
              setInternalState(this, {
                type: ARRAY_ITERATOR,
                target: toIndexedObject(iterated),
                index: 0,
                kind
              });
            }, function() {
              var state = getInternalState(this);
              var target = state.target;
              var kind = state.kind;
              var index2 = state.index++;
              if (!target || index2 >= target.length) {
                state.target = void 0;
                return { value: void 0, done: true };
              }
              if (kind == "keys")
                return { value: index2, done: false };
              if (kind == "values")
                return { value: target[index2], done: false };
              return { value: [index2, target[index2]], done: false };
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          "e439": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var fails = __webpack_require__("d039");
            var toIndexedObject = __webpack_require__("fc6a");
            var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var DESCRIPTORS = __webpack_require__("83ab");
            var FAILS_ON_PRIMITIVES = fails(function() {
              nativeGetOwnPropertyDescriptor(1);
            });
            var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
            $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
              getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
                return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
              }
            });
          },
          "e538": function(module3, exports3, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            exports3.f = wellKnownSymbol;
          },
          "e893": function(module3, exports3, __webpack_require__) {
            var has2 = __webpack_require__("5135");
            var ownKeys2 = __webpack_require__("56ef");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var definePropertyModule = __webpack_require__("9bf2");
            module3.exports = function(target, source) {
              var keys2 = ownKeys2(source);
              var defineProperty2 = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i2 = 0; i2 < keys2.length; i2++) {
                var key = keys2[i2];
                if (!has2(target, key))
                  defineProperty2(target, key, getOwnPropertyDescriptor(source, key));
              }
            };
          },
          "e8b5": function(module3, exports3, __webpack_require__) {
            var classof = __webpack_require__("c6b6");
            module3.exports = Array.isArray || function isArray2(arg) {
              return classof(arg) == "Array";
            };
          },
          "e95a": function(module3, exports3, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var Iterators = __webpack_require__("3f8c");
            var ITERATOR = wellKnownSymbol("iterator");
            var ArrayPrototype = Array.prototype;
            module3.exports = function(it) {
              return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
            };
          },
          "f5df": function(module3, exports3, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var classofRaw = __webpack_require__("c6b6");
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var CORRECT_ARGUMENTS = classofRaw(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it, key) {
              try {
                return it[key];
              } catch (error) {
              }
            };
            module3.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
              var O, tag, result;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
            };
          },
          "f772": function(module3, exports3, __webpack_require__) {
            var shared = __webpack_require__("5692");
            var uid2 = __webpack_require__("90e3");
            var keys2 = shared("keys");
            module3.exports = function(key) {
              return keys2[key] || (keys2[key] = uid2(key));
            };
          },
          "fb15": function(module3, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);
            if (typeof window !== "undefined") {
              var currentScript = window.document.currentScript;
              {
                var getCurrentScript = __webpack_require__("8875");
                currentScript = getCurrentScript();
                if (!("currentScript" in document)) {
                  Object.defineProperty(document, "currentScript", { get: getCurrentScript });
                }
              }
              var src2 = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
              if (src2) {
                __webpack_require__.p = src2[1];
              }
            }
            __webpack_require__("99af");
            __webpack_require__("4de4");
            __webpack_require__("4160");
            __webpack_require__("c975");
            __webpack_require__("d81d");
            __webpack_require__("a434");
            __webpack_require__("159b");
            __webpack_require__("a4d3");
            __webpack_require__("e439");
            __webpack_require__("dbb4");
            __webpack_require__("b64b");
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function ownKeys2(object, enumerableOnly) {
              var keys2 = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly)
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                keys2.push.apply(keys2, symbols);
              }
              return keys2;
            }
            function _objectSpread22(target) {
              for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = arguments[i2] != null ? arguments[i2] : {};
                if (i2 % 2) {
                  ownKeys2(Object(source), true).forEach(function(key) {
                    _defineProperty2(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ownKeys2(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function _arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            __webpack_require__("e01a");
            __webpack_require__("d28b");
            __webpack_require__("e260");
            __webpack_require__("d3b7");
            __webpack_require__("3ca3");
            __webpack_require__("ddb0");
            function _iterableToArrayLimit(arr, i2) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            __webpack_require__("a630");
            __webpack_require__("fb6a");
            __webpack_require__("b0c0");
            __webpack_require__("25f0");
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _slicedToArray(arr, i2) {
              return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest();
            }
            function _arrayWithoutHoles2(arr) {
              if (Array.isArray(arr))
                return _arrayLikeToArray2(arr);
            }
            function _iterableToArray2(iter) {
              if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                return Array.from(iter);
            }
            function _nonIterableSpread2() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _toConsumableArray2(arr) {
              return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
            }
            var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
            var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);
            function removeNode(node) {
              if (node.parentElement !== null) {
                node.parentElement.removeChild(node);
              }
            }
            function insertNodeAt(fatherNode, node, position) {
              var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
              fatherNode.insertBefore(node, refNode);
            }
            var console2 = __webpack_require__("dbf1");
            __webpack_require__("13d5");
            __webpack_require__("4fad");
            __webpack_require__("ac1f");
            __webpack_require__("5319");
            function cached(fn) {
              var cache2 = /* @__PURE__ */ Object.create(null);
              return function cachedFn(str) {
                var hit = cache2[str];
                return hit || (cache2[str] = fn(str));
              };
            }
            var regex = /-(\w)/g;
            var camelize2 = cached(function(str) {
              return str.replace(regex, function(_, c) {
                return c.toUpperCase();
              });
            });
            __webpack_require__("5db7");
            __webpack_require__("73d9");
            var manageAndEmit = ["Start", "Add", "Remove", "Update", "End"];
            var emit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
            var manage = ["Move"];
            var eventHandlerNames = [manage, manageAndEmit, emit].flatMap(function(events2) {
              return events2;
            }).map(function(evt) {
              return "on".concat(evt);
            });
            var events = {
              manage,
              manageAndEmit,
              emit
            };
            function isReadOnly(eventName) {
              return eventHandlerNames.indexOf(eventName) !== -1;
            }
            __webpack_require__("caad");
            __webpack_require__("2ca0");
            var tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
            function isHtmlTag(name) {
              return tags.includes(name);
            }
            function isTransition(name) {
              return ["transition-group", "TransitionGroup"].includes(name);
            }
            function isHtmlAttribute(value) {
              return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
            }
            function project(entries) {
              return entries.reduce(function(res, _ref) {
                var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                res[key] = value;
                return res;
              }, {});
            }
            function getComponentAttributes(_ref3) {
              var $attrs = _ref3.$attrs, _ref3$componentData = _ref3.componentData, componentData = _ref3$componentData === void 0 ? {} : _ref3$componentData;
              var attributes = project(Object.entries($attrs).filter(function(_ref4) {
                var _ref5 = _slicedToArray(_ref4, 2), key = _ref5[0];
                _ref5[1];
                return isHtmlAttribute(key);
              }));
              return _objectSpread22(_objectSpread22({}, attributes), componentData);
            }
            function createSortableOption(_ref6) {
              var $attrs = _ref6.$attrs, callBackBuilder = _ref6.callBackBuilder;
              var options = project(getValidSortableEntries($attrs));
              Object.entries(callBackBuilder).forEach(function(_ref7) {
                var _ref8 = _slicedToArray(_ref7, 2), eventType = _ref8[0], eventBuilder = _ref8[1];
                events[eventType].forEach(function(event) {
                  options["on".concat(event)] = eventBuilder(event);
                });
              });
              var draggable2 = "[data-draggable]".concat(options.draggable || "");
              return _objectSpread22(_objectSpread22({}, options), {}, {
                draggable: draggable2
              });
            }
            function getValidSortableEntries(value) {
              return Object.entries(value).filter(function(_ref9) {
                var _ref10 = _slicedToArray(_ref9, 2), key = _ref10[0];
                _ref10[1];
                return !isHtmlAttribute(key);
              }).map(function(_ref11) {
                var _ref12 = _slicedToArray(_ref11, 2), key = _ref12[0], value2 = _ref12[1];
                return [camelize2(key), value2];
              }).filter(function(_ref13) {
                var _ref14 = _slicedToArray(_ref13, 2), key = _ref14[0];
                _ref14[1];
                return !isReadOnly(key);
              });
            }
            __webpack_require__("c740");
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties(target, props2) {
              for (var i2 = 0; i2 < props2.length; i2++) {
                var descriptor = props2[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              return Constructor;
            }
            var getHtmlElementFromNode = function getHtmlElementFromNode2(_ref) {
              var el = _ref.el;
              return el;
            };
            var addContext = function addContext2(domElement, context) {
              return domElement.__draggable_context = context;
            };
            var getContext2 = function getContext3(domElement) {
              return domElement.__draggable_context;
            };
            var componentStructure_ComponentStructure = /* @__PURE__ */ function() {
              function ComponentStructure(_ref2) {
                var _ref2$nodes = _ref2.nodes, header = _ref2$nodes.header, defaultNodes = _ref2$nodes.default, footer = _ref2$nodes.footer, root2 = _ref2.root, realList = _ref2.realList;
                _classCallCheck(this, ComponentStructure);
                this.defaultNodes = defaultNodes;
                this.children = [].concat(_toConsumableArray2(header), _toConsumableArray2(defaultNodes), _toConsumableArray2(footer));
                this.externalComponent = root2.externalComponent;
                this.rootTransition = root2.transition;
                this.tag = root2.tag;
                this.realList = realList;
              }
              _createClass(ComponentStructure, [{
                key: "render",
                value: function render11(h2, attributes) {
                  var tag = this.tag, children = this.children, _isRootComponent = this._isRootComponent;
                  var option = !_isRootComponent ? children : {
                    default: function _default() {
                      return children;
                    }
                  };
                  return h2(tag, attributes, option);
                }
              }, {
                key: "updated",
                value: function updated() {
                  var defaultNodes = this.defaultNodes, realList = this.realList;
                  defaultNodes.forEach(function(node, index2) {
                    addContext(getHtmlElementFromNode(node), {
                      element: realList[index2],
                      index: index2
                    });
                  });
                }
              }, {
                key: "getUnderlyingVm",
                value: function getUnderlyingVm(domElement) {
                  return getContext2(domElement);
                }
              }, {
                key: "getVmIndexFromDomIndex",
                value: function getVmIndexFromDomIndex(domIndex, element) {
                  var defaultNodes = this.defaultNodes;
                  var length = defaultNodes.length;
                  var domChildren = element.children;
                  var domElement = domChildren.item(domIndex);
                  if (domElement === null) {
                    return length;
                  }
                  var context = getContext2(domElement);
                  if (context) {
                    return context.index;
                  }
                  if (length === 0) {
                    return 0;
                  }
                  var firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
                  var indexFirstDomListElement = _toConsumableArray2(domChildren).findIndex(function(element2) {
                    return element2 === firstDomListElement;
                  });
                  return domIndex < indexFirstDomListElement ? 0 : length;
                }
              }, {
                key: "_isRootComponent",
                get: function get2() {
                  return this.externalComponent || this.rootTransition;
                }
              }]);
              return ComponentStructure;
            }();
            var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
            function getSlot(slots, key) {
              var slotValue = slots[key];
              return slotValue ? slotValue() : [];
            }
            function computeNodes(_ref) {
              var $slots = _ref.$slots, realList = _ref.realList, getKey = _ref.getKey;
              var normalizedList = realList || [];
              var _map = ["header", "footer"].map(function(name) {
                return getSlot($slots, name);
              }), _map2 = _slicedToArray(_map, 2), header = _map2[0], footer = _map2[1];
              var item = $slots.item;
              if (!item) {
                throw new Error("draggable element must have an item slot");
              }
              var defaultNodes = normalizedList.flatMap(function(element, index2) {
                return item({
                  element,
                  index: index2
                }).map(function(node) {
                  node.key = getKey(element);
                  node.props = _objectSpread22(_objectSpread22({}, node.props || {}), {}, {
                    "data-draggable": true
                  });
                  return node;
                });
              });
              if (defaultNodes.length !== normalizedList.length) {
                throw new Error("Item slot must have only one child");
              }
              return {
                header,
                footer,
                default: defaultNodes
              };
            }
            function getRootInformation(tag) {
              var transition = isTransition(tag);
              var externalComponent = !isHtmlTag(tag) && !transition;
              return {
                transition,
                externalComponent,
                tag: externalComponent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])(tag) : transition ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : tag
              };
            }
            function computeComponentStructure(_ref2) {
              var $slots = _ref2.$slots, tag = _ref2.tag, realList = _ref2.realList, getKey = _ref2.getKey;
              var nodes = computeNodes({
                $slots,
                realList,
                getKey
              });
              var root2 = getRootInformation(tag);
              return new componentStructure_ComponentStructure({
                nodes,
                root: root2,
                realList
              });
            }
            function _emit(evtName, evtData) {
              var _this = this;
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                return _this.$emit(evtName.toLowerCase(), evtData);
              });
            }
            function _manage(evtName) {
              var _this2 = this;
              return function(evtData, originalElement) {
                if (_this2.realList !== null) {
                  return _this2["onDrag".concat(evtName)](evtData, originalElement);
                }
              };
            }
            function _manageAndEmit(evtName) {
              var _this3 = this;
              var delegateCallBack = _manage.call(this, evtName);
              return function(evtData, originalElement) {
                delegateCallBack.call(_this3, evtData, originalElement);
                _emit.call(_this3, evtName, evtData);
              };
            }
            var draggingElement = null;
            var props = {
              list: {
                type: Array,
                required: false,
                default: null
              },
              modelValue: {
                type: Array,
                required: false,
                default: null
              },
              itemKey: {
                type: [String, Function],
                required: true
              },
              clone: {
                type: Function,
                default: function _default(original) {
                  return original;
                }
              },
              tag: {
                type: String,
                default: "div"
              },
              move: {
                type: Function,
                default: null
              },
              componentData: {
                type: Object,
                required: false,
                default: null
              }
            };
            var emits = ["update:modelValue", "change"].concat(_toConsumableArray2([].concat(_toConsumableArray2(events.manageAndEmit), _toConsumableArray2(events.emit)).map(function(evt) {
              return evt.toLowerCase();
            })));
            var draggableComponent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
              name: "draggable",
              inheritAttrs: false,
              props,
              emits,
              data: function data2() {
                return {
                  error: false
                };
              },
              render: function render11() {
                try {
                  this.error = false;
                  var $slots = this.$slots, $attrs = this.$attrs, tag = this.tag, componentData = this.componentData, realList = this.realList, getKey = this.getKey;
                  var componentStructure = computeComponentStructure({
                    $slots,
                    tag,
                    realList,
                    getKey
                  });
                  this.componentStructure = componentStructure;
                  var attributes = getComponentAttributes({
                    $attrs,
                    componentData
                  });
                  return componentStructure.render(external_commonjs_vue_commonjs2_vue_root_Vue_["h"], attributes);
                } catch (err) {
                  this.error = true;
                  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("pre", {
                    style: {
                      color: "red"
                    }
                  }, err.stack);
                }
              },
              created: function created() {
                if (this.list !== null && this.modelValue !== null) {
                  console2["a"].error("modelValue and list props are mutually exclusive! Please set one or another.");
                }
              },
              mounted: function mounted() {
                var _this4 = this;
                if (this.error) {
                  return;
                }
                var $attrs = this.$attrs, $el = this.$el, componentStructure = this.componentStructure;
                componentStructure.updated();
                var sortableOptions = createSortableOption({
                  $attrs,
                  callBackBuilder: {
                    manageAndEmit: function manageAndEmit2(event) {
                      return _manageAndEmit.call(_this4, event);
                    },
                    emit: function emit2(event) {
                      return _emit.bind(_this4, event);
                    },
                    manage: function manage2(event) {
                      return _manage.call(_this4, event);
                    }
                  }
                });
                var targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
                this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(targetDomElement, sortableOptions);
                this.targetDomElement = targetDomElement;
                targetDomElement.__draggable_component__ = this;
              },
              updated: function updated() {
                this.componentStructure.updated();
              },
              beforeUnmount: function beforeUnmount() {
                if (this._sortable !== void 0)
                  this._sortable.destroy();
              },
              computed: {
                realList: function realList() {
                  var list = this.list;
                  return list ? list : this.modelValue;
                },
                getKey: function getKey() {
                  var itemKey = this.itemKey;
                  if (typeof itemKey === "function") {
                    return itemKey;
                  }
                  return function(element) {
                    return element[itemKey];
                  };
                }
              },
              watch: {
                $attrs: {
                  handler: function handler(newOptionValue) {
                    var _sortable = this._sortable;
                    if (!_sortable)
                      return;
                    getValidSortableEntries(newOptionValue).forEach(function(_ref) {
                      var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                      _sortable.option(key, value);
                    });
                  },
                  deep: true
                }
              },
              methods: {
                getUnderlyingVm: function getUnderlyingVm(domElement) {
                  return this.componentStructure.getUnderlyingVm(domElement) || null;
                },
                getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(htmElement) {
                  return htmElement.__draggable_component__;
                },
                emitChanges: function emitChanges(evt) {
                  var _this5 = this;
                  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                    return _this5.$emit("change", evt);
                  });
                },
                alterList: function alterList(onList) {
                  if (this.list) {
                    onList(this.list);
                    return;
                  }
                  var newList = _toConsumableArray2(this.modelValue);
                  onList(newList);
                  this.$emit("update:modelValue", newList);
                },
                spliceList: function spliceList() {
                  var _arguments = arguments;
                  var spliceList2 = function spliceList3(list) {
                    return list.splice.apply(list, _toConsumableArray2(_arguments));
                  };
                  this.alterList(spliceList2);
                },
                updatePosition: function updatePosition(oldIndex2, newIndex2) {
                  var updatePosition2 = function updatePosition3(list) {
                    return list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
                  };
                  this.alterList(updatePosition2);
                },
                getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
                  var to = _ref3.to, related = _ref3.related;
                  var component = this.getUnderlyingPotencialDraggableComponent(to);
                  if (!component) {
                    return {
                      component
                    };
                  }
                  var list = component.realList;
                  var context = {
                    list,
                    component
                  };
                  if (to !== related && list) {
                    var destination = component.getUnderlyingVm(related) || {};
                    return _objectSpread22(_objectSpread22({}, destination), context);
                  }
                  return context;
                },
                getVmIndexFromDomIndex: function getVmIndexFromDomIndex(domIndex) {
                  return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
                },
                onDragStart: function onDragStart(evt) {
                  this.context = this.getUnderlyingVm(evt.item);
                  evt.item._underlying_vm_ = this.clone(this.context.element);
                  draggingElement = evt.item;
                },
                onDragAdd: function onDragAdd(evt) {
                  var element = evt.item._underlying_vm_;
                  if (element === void 0) {
                    return;
                  }
                  removeNode(evt.item);
                  var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
                  this.spliceList(newIndex2, 0, element);
                  var added = {
                    element,
                    newIndex: newIndex2
                  };
                  this.emitChanges({
                    added
                  });
                },
                onDragRemove: function onDragRemove(evt) {
                  insertNodeAt(this.$el, evt.item, evt.oldIndex);
                  if (evt.pullMode === "clone") {
                    removeNode(evt.clone);
                    return;
                  }
                  var _this$context = this.context, oldIndex2 = _this$context.index, element = _this$context.element;
                  this.spliceList(oldIndex2, 1);
                  var removed = {
                    element,
                    oldIndex: oldIndex2
                  };
                  this.emitChanges({
                    removed
                  });
                },
                onDragUpdate: function onDragUpdate(evt) {
                  removeNode(evt.item);
                  insertNodeAt(evt.from, evt.item, evt.oldIndex);
                  var oldIndex2 = this.context.index;
                  var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
                  this.updatePosition(oldIndex2, newIndex2);
                  var moved2 = {
                    element: this.context.element,
                    oldIndex: oldIndex2,
                    newIndex: newIndex2
                  };
                  this.emitChanges({
                    moved: moved2
                  });
                },
                computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
                  if (!relatedContext.element) {
                    return 0;
                  }
                  var domChildren = _toConsumableArray2(evt.to.children).filter(function(el) {
                    return el.style["display"] !== "none";
                  });
                  var currentDomIndex = domChildren.indexOf(evt.related);
                  var currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
                  var draggedInList = domChildren.indexOf(draggingElement) !== -1;
                  return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
                },
                onDragMove: function onDragMove(evt, originalEvent) {
                  var move = this.move, realList = this.realList;
                  if (!move || !realList) {
                    return true;
                  }
                  var relatedContext = this.getRelatedContextFromMoveEvent(evt);
                  var futureIndex = this.computeFutureIndex(relatedContext, evt);
                  var draggedContext = _objectSpread22(_objectSpread22({}, this.context), {}, {
                    futureIndex
                  });
                  var sendEvent = _objectSpread22(_objectSpread22({}, evt), {}, {
                    relatedContext,
                    draggedContext
                  });
                  return move(sendEvent, originalEvent);
                },
                onDragEnd: function onDragEnd() {
                  draggingElement = null;
                }
              }
            });
            var vuedraggable = draggableComponent;
            __webpack_exports__["default"] = vuedraggable;
          },
          "fb6a": function(module3, exports3, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var isObject2 = __webpack_require__("861d");
            var isArray2 = __webpack_require__("e8b5");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var toLength = __webpack_require__("50c4");
            var toIndexedObject = __webpack_require__("fc6a");
            var createProperty = __webpack_require__("8418");
            var wellKnownSymbol = __webpack_require__("b622");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
            var USES_TO_LENGTH = arrayMethodUsesToLength("slice", { ACCESSORS: true, 0: 0, 1: 2 });
            var SPECIES = wellKnownSymbol("species");
            var nativeSlice = [].slice;
            var max2 = Math.max;
            $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              slice: function slice2(start, end) {
                var O = toIndexedObject(this);
                var length = toLength(O.length);
                var k = toAbsoluteIndex(start, length);
                var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                var Constructor, result, n;
                if (isArray2(O)) {
                  Constructor = O.constructor;
                  if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                    Constructor = void 0;
                  } else if (isObject2(Constructor)) {
                    Constructor = Constructor[SPECIES];
                    if (Constructor === null)
                      Constructor = void 0;
                  }
                  if (Constructor === Array || Constructor === void 0) {
                    return nativeSlice.call(O, k, fin);
                  }
                }
                result = new (Constructor === void 0 ? Array : Constructor)(max2(fin - k, 0));
                for (n = 0; k < fin; k++, n++)
                  if (k in O)
                    createProperty(result, n, O[k]);
                result.length = n;
                return result;
              }
            });
          },
          "fc6a": function(module3, exports3, __webpack_require__) {
            var IndexedObject = __webpack_require__("44ad");
            var requireObjectCoercible = __webpack_require__("1d80");
            module3.exports = function(it) {
              return IndexedObject(requireObjectCoercible(it));
            };
          },
          "fdbc": function(module3, exports3) {
            module3.exports = {
              CSSRuleList: 0,
              CSSStyleDeclaration: 0,
              CSSValueList: 0,
              ClientRectList: 0,
              DOMRectList: 0,
              DOMStringList: 0,
              DOMTokenList: 1,
              DataTransferItemList: 0,
              FileList: 0,
              HTMLAllCollection: 0,
              HTMLCollection: 0,
              HTMLFormElement: 0,
              HTMLSelectElement: 0,
              MediaList: 0,
              MimeTypeArray: 0,
              NamedNodeMap: 0,
              NodeList: 1,
              PaintRequestList: 0,
              Plugin: 0,
              PluginArray: 0,
              SVGLengthList: 0,
              SVGNumberList: 0,
              SVGPathSegList: 0,
              SVGPointList: 0,
              SVGStringList: 0,
              SVGTransformList: 0,
              SourceBufferList: 0,
              StyleSheetList: 0,
              TextTrackCueList: 0,
              TextTrackList: 0,
              TouchList: 0
            };
          },
          "fdbf": function(module3, exports3, __webpack_require__) {
            var NATIVE_SYMBOL = __webpack_require__("4930");
            module3.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
          }
        })["default"];
      });
    })(vuedraggable_umd);
    const draggable = /* @__PURE__ */ getDefaultExportFromCjs(vuedraggable_umd.exports);
    const _hoisted_1$j = ["onClick"];
    const _sfc_main$l = /* @__PURE__ */ defineComponent({
      __name: "SectionList",
      setup(__props) {
        const pageStore = usePageStore();
        const { addSection, setActiveSection, setActiveNode, swapSection } = pageStore;
        const { activeSection, isActiveAllSection, allPageData } = storeToRefs(pageStore);
        const dragStore = useDragStore();
        const { dragNode, dragType, dragNodeType, isCancelDrag } = storeToRefs(dragStore);
        const handleSectionItemClick = (item) => {
          setActiveSection(item);
          setActiveNode(item);
          nextTick$1(() => emitter.emit("location"));
        };
        const allKey = Symbol("all");
        const showAllItem = computed(() => allPageData.value.length > 0);
        let inDraggable = ref(false);
        const dragEvents = computed(() => ({
          dragover: (event) => {
            event.dataTransfer.setDragImage(new Image(), 0, 0);
          },
          add: (event) => {
            if (!dragNode.value)
              return;
            if (event.pullMode === "clone" && event.newIndex !== void 0) {
              if (isCancelDrag.value)
                return;
              addSection(dragNode.value, event.newIndex - (showAllItem.value ? 1 : 0));
            }
          },
          start: () => inDraggable.value = true,
          end: (event) => {
            if (event.pullMode !== "clone" && event.oldIndex !== void 0 && event.newIndex !== void 0) {
              swapSection(event.oldIndex - (showAllItem.value ? 1 : 0), event.newIndex - (showAllItem.value ? 1 : 0));
            }
            inDraggable.value = false;
          }
        }));
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createBlock(unref$1(draggable), mergeProps({
            class: [
              "section-list",
              { "section-list-drag": inDraggable.value || unref$1(dragType) === "clone" && unref$1(dragNodeType) === "section" }
            ],
            "item-key": "name",
            group: { name: "section", put: true, pull: true },
            disabled: unref$1(dragNode) && unref$1(dragNodeType) !== "section",
            "ghost-class": "section-item-ghost",
            "model-value": unref$1(allPageData) || [],
            "component-data": {
              tag: "transition-group",
              name: "fade"
            }
          }, toHandlers(dragEvents.value)), {
            header: withCtx(() => [
              showAllItem.value ? (openBlock(), createElementBlock("div", {
                key: unref$1(allKey),
                class: normalizeClass(["section-item", { active: unref$1(isActiveAllSection) }]),
                onClick: _cache[0] || (_cache[0] = ($event) => handleSectionItemClick(null))
              }, " A ", 2)) : createCommentVNode("", true)
            ]),
            item: withCtx(({ element: item, index: index2 }) => [
              withDirectives((openBlock(), createElementBlock("div", {
                class: normalizeClass(["section-item", { active: item === unref$1(activeSection) }]),
                key: item.name,
                onClick: ($event) => handleSectionItemClick(item)
              }, [
                createTextVNode(toDisplayString(index2 + 1), 1)
              ], 10, _hoisted_1$j)), [
                [_directive_tooltip, { content: item.name, placement: "right", distance: 10 }]
              ])
            ]),
            _: 1
          }, 16, ["class", "disabled", "model-value"]);
        };
      }
    });
    const SectionList_vue_vue_type_style_index_0_scoped_0c06f0e4_lang = "";
    const SectionList = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-0c06f0e4"]]);
    const _hoisted_1$i = {
      class: /* @__PURE__ */ normalizeClass(["global-setting-panel"])
    };
    const _sfc_main$k = /* @__PURE__ */ defineComponent({
      __name: "GlobalSettingPanel",
      setup(__props) {
        const pageStore = usePageStore();
        const { setting } = storeToRefs(pageStore);
        const displayStore = useDisplayStore();
        const { deviceType } = storeToRefs(displayStore);
        const { setDevice } = displayStore;
        const handleClientChange = (client) => {
          setting.value.client = client;
          if (client === "desktop" && deviceType.value === "mobile") {
            deviceType.value = "desktop";
            setDevice(0);
            nextTick$1(() => emitter.emit("location", true));
          }
          if (client === "mobile" && deviceType.value === "desktop") {
            deviceType.value = "mobile";
            setDevice(0);
            nextTick$1(() => emitter.emit("location", true));
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$i, [
            createVNode(SelectItem, {
              label: _ctx.$t("supportDevice"),
              container: ".sidebar-dropdown",
              "wrapper-class": "select-item",
              options: { desktop: _ctx.$t("desktop"), mobile: _ctx.$t("mobile"), both: _ctx.$t("bothClient") },
              "model-value": unref$1(setting).client,
              "onUpdate:modelValue": handleClientChange
            }, null, 8, ["label", "options", "model-value"]),
            createVNode(InputItem, {
              label: _ctx.$t("pageTitle"),
              placeholder: _ctx.$t("pageTitlePlaceholder"),
              "wrapper-class": "title-item",
              modelValue: unref$1(setting).title,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref$1(setting).title = $event)
            }, null, 8, ["label", "placeholder", "modelValue"]),
            createVNode(InputItem, {
              label: _ctx.$t("pageDescription"),
              placeholder: _ctx.$t("pageDescriptionPlaceholder"),
              "wrapper-class": "title-item",
              modelValue: unref$1(setting).description,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref$1(setting).description = $event)
            }, null, 8, ["label", "placeholder", "modelValue"]),
            createVNode(ImageItem, {
              label: _ctx.$t("pageFavicon"),
              "wrapper-class": "image-item",
              accept: "image/x-icon,image/png",
              modelValue: unref$1(setting).favicon,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref$1(setting).favicon = $event)
            }, null, 8, ["label", "modelValue"])
          ]);
        };
      }
    });
    const GlobalSettingPanel_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$h = { class: "group-item" };
    const _hoisted_2$c = { class: "group-item-content" };
    const _hoisted_3$a = {
      key: 0,
      class: "group-item-delete"
    };
    const _sfc_main$j = /* @__PURE__ */ defineComponent({
      __name: "GroupItem",
      props: {
        canDelete: { type: Boolean, default: true }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$h, [
            createBaseVNode("div", _hoisted_2$c, [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ]),
            __props.canDelete ? (openBlock(), createElementBlock("div", _hoisted_3$a, [
              createVNode(Icon$1, {
                class: normalizeClass(["delete-btn"]),
                type: "circle",
                name: "line",
                size: 10,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("delete"))
              })
            ])) : createCommentVNode("", true)
          ]);
        };
      }
    });
    const GroupItem_vue_vue_type_style_index_0_scoped_577f7611_lang = "";
    const GroupItem = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-577f7611"]]);
    const _hoisted_1$g = {
      class: /* @__PURE__ */ normalizeClass(["font-family-panel"])
    };
    const _sfc_main$i = /* @__PURE__ */ defineComponent({
      __name: "FontFamilyPanel",
      setup(__props) {
        const pageStore = usePageStore();
        const { font } = storeToRefs(pageStore);
        const handleAddFontFace = () => {
          font.value.customFontFace.push("");
        };
        const deleteFontFace = (index2) => {
          font.value.customFontFace.splice(index2, 1);
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", _hoisted_1$g, [
            createVNode(SliderItem, {
              "wrapper-class": "font-size-item",
              label: _ctx.$t("rootFontSize"),
              modelValue: unref$1(font).fontSize,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref$1(font).fontSize = $event),
              min: 10,
              max: 100
            }, {
              default: withCtx(() => [
                withDirectives(createVNode(Icon$1, {
                  name: "question",
                  class: "question-icon",
                  size: 13
                }, null, 512), [
                  [_directive_tooltip, {
                    content: _ctx.$t("mediaFontSizeTip")
                  }]
                ])
              ]),
              _: 1
            }, 8, ["label", "modelValue"]),
            createVNode(InputItem, {
              "wrapper-class": "font-family-item",
              label: _ctx.$t("fontFamily"),
              type: "textarea",
              modelValue: unref$1(font).fontFamily,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref$1(font).fontFamily = $event)
            }, null, 8, ["label", "modelValue"]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(font).customFontFace, (item, index2) => {
              return openBlock(), createBlock(GroupItem, {
                key: index2,
                class: normalizeClass(["font-face-group"]),
                onDelete: ($event) => deleteFontFace(index2)
              }, {
                default: withCtx(() => [
                  typeof item === "object" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createVNode(InputItem, {
                      label: _ctx.$t("fontFaceName"),
                      modelValue: item.fontFamily,
                      "onUpdate:modelValue": ($event) => item.fontFamily = $event
                    }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                    createVNode(InputItem, {
                      label: _ctx.$t("fontFaceSrc"),
                      modelValue: item.url,
                      "onUpdate:modelValue": ($event) => item.url = $event
                    }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                    createVNode(InputItem, {
                      label: _ctx.$t("fontFaceStyle"),
                      modelValue: item.fontStyle,
                      "onUpdate:modelValue": ($event) => item.fontStyle = $event
                    }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                    createVNode(InputItem, {
                      label: _ctx.$t("fontFaceWeight"),
                      modelValue: item.fontWeight,
                      "onUpdate:modelValue": ($event) => item.fontWeight = $event
                    }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])
                  ], 64)) : (openBlock(), createBlock(InputItem, {
                    key: 1,
                    label: _ctx.$t("fontFaceLink"),
                    type: "textarea",
                    rows: 3,
                    placeholder: "https://",
                    "auto-focus": true,
                    "model-value": item,
                    "onUpdate:modelValue": (val) => unref$1(font).customFontFace[index2] = val
                  }, null, 8, ["label", "model-value", "onUpdate:modelValue"]))
                ]),
                _: 2
              }, 1032, ["onDelete"]);
            }), 128)),
            createVNode(Btn, {
              "is-block": "",
              type: "inner",
              class: "full-btn add-color-btn",
              onClick: handleAddFontFace
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$t("addFontFace")), 1)
              ]),
              _: 1
            })
          ]);
        };
      }
    });
    const FontFamilyPanel_vue_vue_type_style_index_0_lang = "";
    const LogoImage = "/site/assets/logo.8700b607.png";
    const _hoisted_1$f = ["src"];
    const _sfc_main$h = /* @__PURE__ */ defineComponent({
      __name: "Logo",
      props: {
        size: null
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("img", {
            src: unref$1(LogoImage),
            class: normalizeClass(["logo"]),
            style: normalizeStyle({ width: `${__props.size}px`, height: `${__props.size}px` })
          }, null, 12, _hoisted_1$f);
        };
      }
    });
    const Logo_vue_vue_type_style_index_0_scoped_636e0391_lang = "";
    const Logo = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-636e0391"]]);
    const _hoisted_1$e = {
      class: /* @__PURE__ */ normalizeClass(["question-panel"])
    };
    const _hoisted_2$b = { class: "question-panel-title" };
    const _hoisted_3$9 = { class: "question-item" };
    const _hoisted_4$5 = ["innerHTML"];
    const _hoisted_5$5 = ["innerHTML"];
    const _hoisted_6$4 = { class: "question-item" };
    const _hoisted_7$2 = ["innerHTML"];
    const _hoisted_8$2 = ["innerHTML"];
    const _hoisted_9$2 = { class: "question-item" };
    const _hoisted_10$1 = ["innerHTML"];
    const _hoisted_11$1 = ["innerHTML"];
    const _hoisted_12$1 = { class: "question-item" };
    const _hoisted_13$1 = ["innerHTML"];
    const _hoisted_14$1 = ["innerHTML"];
    const _sfc_main$g = /* @__PURE__ */ defineComponent({
      __name: "QuestionPanel",
      setup(__props) {
        const covertText = (str) => {
          str = str.replace(/.*?/g, (str2) => `\u300C<strong>${str2.slice(1, -1)}</strong>\u300D`);
          str = str.replace(/\[.*?\]/g, (str2) => `[<strong>${str2.slice(1, -1)}</strong>]`);
          return str;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$e, [
            createBaseVNode("div", _hoisted_2$b, [
              createVNode(Icon$1, {
                name: "question-circle",
                size: 16
              }),
              createBaseVNode("span", null, toDisplayString(_ctx.$t("question")), 1)
            ]),
            createBaseVNode("div", _hoisted_3$9, [
              createBaseVNode("div", {
                class: "question-item-question",
                innerHTML: covertText(_ctx.$t("question1"))
              }, null, 8, _hoisted_4$5),
              createBaseVNode("div", {
                class: "question-item-answer",
                innerHTML: covertText(_ctx.$t("answer1"))
              }, null, 8, _hoisted_5$5)
            ]),
            createBaseVNode("div", _hoisted_6$4, [
              createBaseVNode("div", {
                class: "question-item-question",
                innerHTML: covertText(_ctx.$t("question2"))
              }, null, 8, _hoisted_7$2),
              createBaseVNode("div", {
                class: "question-item-answer",
                innerHTML: covertText(_ctx.$t("answer2"))
              }, null, 8, _hoisted_8$2)
            ]),
            createBaseVNode("div", _hoisted_9$2, [
              createBaseVNode("div", {
                class: "question-item-question",
                innerHTML: covertText(_ctx.$t("question3"))
              }, null, 8, _hoisted_10$1),
              createBaseVNode("div", {
                class: "question-item-answer",
                innerHTML: covertText(_ctx.$t("answer3"))
              }, null, 8, _hoisted_11$1)
            ]),
            createBaseVNode("div", _hoisted_12$1, [
              createBaseVNode("div", {
                class: "question-item-question",
                innerHTML: covertText(_ctx.$t("question4"))
              }, null, 8, _hoisted_13$1),
              createBaseVNode("div", {
                class: "question-item-answer",
                innerHTML: covertText(_ctx.$t("answer4"))
              }, null, 8, _hoisted_14$1)
            ])
          ]);
        };
      }
    });
    const QuestionPanel_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$d = { class: "sidebar" };
    const _hoisted_2$a = { class: "logo-wrapper" };
    const _hoisted_3$8 = { class: "operator-panel" };
    const _hoisted_4$4 = { class: "top" };
    const _hoisted_5$4 = { class: "operator-item add-item" };
    const _hoisted_6$3 = { class: "bottom" };
    const _hoisted_7$1 = { class: "operator-item first" };
    const _hoisted_8$1 = { class: "operator-item" };
    const _hoisted_9$1 = { class: "operator-item last" };
    const _sfc_main$f = /* @__PURE__ */ defineComponent({
      __name: "Sidebar",
      props: {
        keyboard: { type: Boolean },
        activeMaterialsPanel: { type: Boolean }
      },
      setup(__props) {
        const router2 = useRouter();
        const gotoHome = () => {
          router2.push({
            name: "home"
          });
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", _hoisted_1$d, [
            createBaseVNode("div", _hoisted_2$a, [
              createVNode(Logo, {
                size: 32,
                onClick: gotoHome
              })
            ]),
            createBaseVNode("div", _hoisted_3$8, [
              createBaseVNode("div", _hoisted_4$4, [
                createBaseVNode("div", _hoisted_5$4, [
                  createVNode(Icon$1, {
                    size: 26,
                    name: "add",
                    active: __props.activeMaterialsPanel,
                    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("change-materials-panel", !__props.activeMaterialsPanel))
                  }, null, 8, ["active"])
                ]),
                createVNode(SectionList)
              ]),
              createBaseVNode("div", _hoisted_6$3, [
                createVNode(_sfc_main$X, {
                  placement: "right-end",
                  "popper-class": "sidebar-dropdown",
                  skidding: 40,
                  distance: 16,
                  type: "pure"
                }, {
                  default: withCtx(({ shown }) => [
                    withDirectives((openBlock(), createElementBlock("div", _hoisted_7$1, [
                      createVNode(Icon$1, {
                        size: 22,
                        name: "question-circle",
                        active: shown
                      }, null, 8, ["active"])
                    ])), [
                      [_directive_tooltip, { content: _ctx.$t("question"), placement: "right", distance: 10, disabled: shown }]
                    ])
                  ]),
                  content: withCtx(() => [
                    createVNode(_sfc_main$g)
                  ]),
                  _: 1
                }),
                withDirectives((openBlock(), createElementBlock("div", {
                  class: "operator-item",
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:keyboard", !__props.keyboard))
                }, [
                  createVNode(Icon$1, {
                    size: 26,
                    name: "keyboard",
                    active: __props.keyboard
                  }, null, 8, ["active"])
                ])), [
                  [_directive_tooltip, { content: _ctx.$t("shortcut"), placement: "right", distance: 10 }]
                ]),
                createVNode(_sfc_main$X, {
                  placement: "right-end",
                  "popper-class": "sidebar-dropdown",
                  skidding: 40,
                  distance: 16,
                  type: "pure"
                }, {
                  default: withCtx(({ shown }) => [
                    withDirectives((openBlock(), createElementBlock("div", _hoisted_8$1, [
                      createVNode(Icon$1, {
                        size: 26,
                        name: "font",
                        active: shown
                      }, null, 8, ["active"])
                    ])), [
                      [_directive_tooltip, { content: _ctx.$t("fontSetting"), placement: "right", distance: 10, disabled: shown }]
                    ])
                  ]),
                  content: withCtx(() => [
                    createVNode(_sfc_main$i)
                  ]),
                  _: 1
                }),
                createVNode(_sfc_main$X, {
                  placement: "right-end",
                  "popper-class": "sidebar-dropdown",
                  skidding: 10,
                  distance: 16,
                  type: "pure"
                }, {
                  default: withCtx(({ shown }) => [
                    withDirectives((openBlock(), createElementBlock("div", _hoisted_9$1, [
                      createVNode(Icon$1, {
                        size: 26,
                        name: "advanced",
                        active: shown
                      }, null, 8, ["active"])
                    ])), [
                      [_directive_tooltip, { content: _ctx.$t("pageGlobalSetting"), placement: "right", distance: 10, disabled: shown }]
                    ])
                  ]),
                  content: withCtx(() => [
                    createVNode(_sfc_main$k)
                  ]),
                  _: 1
                })
              ])
            ])
          ]);
        };
      }
    });
    const Sidebar_vue_vue_type_style_index_0_scoped_bc6413b9_lang = "";
    const Sidebar_vue_vue_type_style_index_1_lang = "";
    const Sidebar = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-bc6413b9"]]);
    const _sfc_main$e = /* @__PURE__ */ defineComponent({
      __name: "Avatar",
      props: {
        image: { default: "" },
        size: { default: 24 },
        canOperator: { type: Boolean },
        canUpload: { type: Boolean },
        onUpload: null
      },
      setup(__props) {
        const src2 = computed(() => __props.image || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAABupJREFUeF7tnWuW0zAMhcvKICsDVhZYGRyVeDAhaSVbj2vL8wfmTNJWup+uZCeT+fRYX6kz8Cl19Cv4xwIgOQQLgAVA8gwkD385wAIgeQaSh78cYAGQPAPJw0/hAPu+fzl0Lv8W2T8/Ho+fNwz82Lbtx+x8TAVAJfTXG8Fb9SQQCihTgTE0ACfBz9XdKjb3vO904LZt37gnIB43JACH8FTl3qLfaTgsDMMAACj6FDDAAzCQ8GcghnAFWAAGFn4oEOAAmEj4KxDgVhBQAOz7ThN1WcIhDs0an+k70soBAoCJq/4VMBAghAOQpOpvVwzRbhAGQNKqvwKBdhnJDUK2nUMASF71UG7gDsAS/+Uc6T4XuAKwxGctIlwhcANgic8SvxzkBoELAEt8kfiuEJgDsMRvEt8NAlMAlvhd4rtAYAbAEl9FfHMITAAAF79suNAtXvT/+qYSukcQ5SaT/y4mWewaqgNw7PDtqvz3v5hot+0AmN4V7cLUpr1jaAEAiY9SRSLhz5wBOhldTt766+HvK6gCAJYwtbX0rHERBmoAzJwkShRYfGqtQBOAX5rW1PFaapV/0RKotSHMN2qtQAUAoOowE7/AMFus3QAATf3m4lcQoAy63a1AAwCI+/i2beuOhdt2gKDvbgVdSZvNDrkAHEPhFC4wBQCe1V+1gSkGwmYAgKq/2wYllV8fu+/78C4wAwBuw9/FshAFgOYiaAIAqPpJk+5JuMMBUNpAcx4WAK3q/9kdRAKgyQVaAUDZ9aPyb4qhQ/d/Tt33fehciJMHZv8LgH9JFrfD4QGInAGO/QAYB6AbXKSXi1sAQAq4efjRaAFgM0AJSeQCIgDQ7P+IWBSwhvCAF4bqsET5mAEAse1pQQBaEKJ8SAFAs/+nllErAaQVwMkC2LqyDwTtd019T8MBQKtfnA8JABCXfW/EE9neAuBvBmYBwHU1AF79lAt2QUgAQLnwcVfA7KB7HQC191dxsXMhAQByADyJyQ68FYIBql80GM8GAAVvdnl4FPElKyMWAOArgKtiVocA6OYPrnmxNoS4ACCvAG5nAo2nbw38NLP0ABQwmtxgYOFFcc/sAGdnYD29ewLhFwDMJnl+MCPKbzQzP/7bw1jOl8kB3mZssgMWAJMJKg2HtSfCdQD0XUBpcjIcvxzgvEtYff/xJ+AunmZCzwmir9FngvQAlCGv+Unc1bOCkB8ededmaQHoei7Qq94w0lYwd0ucOwOg7wSaiX4FxCAgqDoA0m/A/LfBY/H8PM6UCA7C9ACwljkcIXuPAQVB71oAJQjsJghWcL3CSs5Hg4B7oyxrBgACwLXXSwAox6JcNrYAIHozCMby34EBAAE7VxIHiASAHdA7cbx+HtwSWAMg5UICQNRKgB2Ml7jc9wl0AnbO0AEYrvLPcARBwB6S2QAEDYLsQLhV6X1cxP2U3AFQ1AIOADznALaNeYsqfT9nCER5kzqA1xwgCkIqSMTxjkOhKHeQAEgsLELM1vf02EyT5k4EgFMbEBHcKkbEeQ4uIM5dCwCmbUBKcISQPe9pvCqwB8B4NSAOoEeMiHMtB8KW4hE7gGUbaAkgQsTe9zRygabiaQXAog00BdArRsT5wwNg4QJZqv/InXYBNRdPkwMYBDH8lq/USZRdwB8AZRdoDkCaeJTjFYfBrtw1O4CyCwy/5y8FawoAFF0gIwAad1p3Vb/4YtAV5UokZ5wBNADoLpyuFlCAUNri7A5GasNRxyvlq7v6VRyggkDjUnEKCDQuCmktm1UcQHEgnL4VKC3/VKpf1QEOCDT6Gr3UdE6gNCtRbtTEVwdAcVWgHmhUv1d0R3opdYdUawHVLKC5zalKewQESgNf+ejqzqgOgHIrKIEPB4LB08ZMcmACQGYIDIQ3bYdmABhBYJqMnhZxCE/t72vP61yca1L55X1MATCEAAYEo4p3a33mABhD8AThWDfSEtTty1h4N8BdAHCA4KNiLGFwEN2t8t1aQF2SyksiTrU/3eFYP58fDfvy/Kqnez82zrTnn4N2c4DyxgEQXAl9B0P0swFdxafEuAPg2A44DoF0jLv4YQAcEJQlU3TVRUMQ+tibEAcInguiBa/fP6Tq6w8QDkDSlhBa9XAAgA2I1g4RXvWwAFSzgcWWqrWw714fpuqhATi5AX2rvbf+Tijtn0MKX4KEmAFeZbx6ZPtoIEALPwwAAzrCEMIPB8DF0hGpPQwl+hAzALcRB7aIp+j0ObdtE11n4MbmcRz8DCBJQnUBh07T/DMvH39+ZnTBz/mcCoA7WE5gnA8jUMofkSo/ewo+cmVzCycFANxkZDxuAZBR9SrmBcACIHkGkoe/HGABkDwDycNfDrAASJ6B5OEvB0gOwG/boZCuv5MtfAAAAABJRU5ErkJggg==");
        const handleImageUpload = (e) => {
          if (!__props.onUpload)
            return;
          uploadByEvent(e, __props.onUpload);
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["avatar", { "can-operator": __props.canOperator }]),
            style: normalizeStyle({ backgroundImage: `url(${src2.value})`, width: `${__props.size}px`, height: `${__props.size}px` })
          }, [
            __props.canUpload && __props.onUpload ? (openBlock(), createElementBlock("input", {
              key: 0,
              class: "upload-wrapper",
              type: "file",
              accept: "image/*",
              onChange: handleImageUpload
            }, null, 32)) : createCommentVNode("", true)
          ], 6);
        };
      }
    });
    const Avatar_vue_vue_type_style_index_0_scoped_3b2093a6_lang = "";
    const Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-3b2093a6"]]);
    const _hoisted_1$c = { class: "color-var-list" };
    const _sfc_main$d = /* @__PURE__ */ defineComponent({
      __name: "ColorVarList",
      setup(__props) {
        const pageStore = usePageStore();
        const { colorVars } = storeToRefs(pageStore);
        const deleteColor = (index2) => {
          colorVars.value.splice(index2, 1);
        };
        const handleAddColor = () => {
          colorVars.value.push({
            name: "",
            color: DefaultColor
          });
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$c, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(colorVars), (item, index2) => {
              return openBlock(), createBlock(GroupItem, {
                key: item.name + index2,
                class: "color-var-item",
                onDelete: ($event) => deleteColor(index2)
              }, {
                default: withCtx(() => [
                  createVNode(InputItem, {
                    label: _ctx.$t("colorVariableName"),
                    prefix: "$",
                    modelValue: item.name,
                    "onUpdate:modelValue": ($event) => item.name = $event
                  }, null, 8, ["label", "modelValue", "onUpdate:modelValue"]),
                  createVNode(ColorItem, {
                    "model-value": item.color,
                    label: _ctx.$t("colorVariableColor"),
                    "hide-variable": "",
                    "onUpdate:modelValue": (color) => item.color = color
                  }, null, 8, ["model-value", "label", "onUpdate:modelValue"])
                ]),
                _: 2
              }, 1032, ["onDelete"]);
            }), 128)),
            createVNode(Btn, {
              "is-block": "",
              type: "inner",
              class: "full-btn add-color-btn",
              onClick: handleAddColor
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$t("addColor")), 1)
              ]),
              _: 1
            })
          ]);
        };
      }
    });
    const ColorVarList_vue_vue_type_style_index_0_scoped_7ef9f986_lang = "";
    const ColorVarList = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-7ef9f986"]]);
    const maxHistoryLen = 10;
    const useHistoryStore = defineStore("history", {
      state: () => ({
        history: [],
        currentIndex: 0,
        lastTime: 0,
        isSave: true
      }),
      getters: {
        canUndoHistory: (state) => {
          return state.history.length > 0 && !!state.history[state.currentIndex + 1];
        },
        canRedoHistory: (state) => {
          return !!state.history[state.currentIndex - 1];
        }
      },
      actions: {
        saveHistory(data2, init) {
          const cloneNode = cloneDeep(data2);
          if (this.currentIndex > 0) {
            this.history.splice(0, this.currentIndex);
            this.currentIndex = 0;
          }
          this.history.unshift(cloneNode);
          this.history.length = Math.min(this.history.length, maxHistoryLen);
          if (!init)
            this.isSave = false;
        },
        undoHistory() {
          this.currentIndex++;
          this.isSave = false;
          return cloneDeep(this.history[this.currentIndex]);
        },
        redoHistory() {
          this.currentIndex--;
          this.isSave = false;
          return cloneDeep(this.history[this.currentIndex]);
        },
        setIsSave(isSave) {
          this.isSave = isSave;
          clearStoragePageState();
        }
      }
    });
    const _withScopeId$1 = (n) => (pushScopeId("data-v-5e68e709"), n = n(), popScopeId(), n);
    const _hoisted_1$b = { class: "header" };
    const _hoisted_2$9 = { class: "left" };
    const _hoisted_3$7 = { class: "name" };
    const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "ext" }, ".html", -1));
    const _hoisted_5$3 = { class: "center" };
    const _hoisted_6$2 = { class: "size" };
    const _hoisted_7 = { class: "zoom" };
    const _hoisted_8 = { class: "device-wrapper" };
    const _hoisted_9 = { class: "title" };
    const _hoisted_10 = {
      key: 0,
      class: "title-extra"
    };
    const _hoisted_11 = { class: "device-list" };
    const _hoisted_12 = ["onClick"];
    const _hoisted_13 = { class: "title" };
    const _hoisted_14 = { class: "title-extra" };
    const _hoisted_15 = { class: "title media-title" };
    const _hoisted_16 = { class: "title-extra" };
    const _hoisted_17 = { class: "right" };
    const _hoisted_18 = { class: "user-content" };
    const _hoisted_19 = { class: "user-name" };
    const _hoisted_20 = ["onClick"];
    const _hoisted_21 = ["onClick"];
    const _hoisted_22 = ["onClick"];
    const _hoisted_23 = ["onClick"];
    const _sfc_main$c = /* @__PURE__ */ defineComponent({
      __name: "ConfigHeader",
      emits: ["save", "download", "project-setting"],
      setup(__props, { emit }) {
        const userStore = useUserStore();
        const { userName, avatar } = storeToRefs(userStore);
        const pageStore = usePageStore();
        const { setting, colorVars, allPageData } = storeToRefs(pageStore);
        const { updateAllPageNode, setMediaFontSize } = pageStore;
        const displayStore = useDisplayStore();
        const {
          device,
          displayMode,
          deviceType,
          curWidthFootSize,
          curFootSize,
          curPresetDeviceList: deviceList
        } = storeToRefs(displayStore);
        const { setDevice, setDisplayMode } = displayStore;
        const historyStore = useHistoryStore();
        const { canUndoHistory, canRedoHistory, isSave } = storeToRefs(historyStore);
        const { saveHistory, undoHistory, redoHistory } = historyStore;
        const { signIn, signOut, isAuthenticated } = $a52d863b14a9eb8e$export$44fc9df4d2a1789a();
        const handleSignIn = () => {
          sessionStorage.setItem("redirect", location.href);
          signIn("https://p-easy.net/site/redirect");
        };
        const handleSignOut = async () => {
          if (await Modal.confirm($t("signOutTip"), { title: $t("signOutTipTitle") })) {
            signOut("https://p-easy.net/site/");
          }
        };
        const router2 = useRouter();
        const route = useRoute();
        const gotoMePage = async () => {
          if (isSave.value || await Modal.confirm($t("routerDataTip"), route.name === "create" ? {} : {
            extraLink: $t("save"),
            onExtraLinkClick: () => emitter.emit("saveProject")
          })) {
            router2.push("/me");
          }
        };
        const switchLang = async (lang2) => {
          if (await Modal.confirm($t("switchLangTip"))) {
            router2.replace({
              name: route.name,
              params: { ...route.params },
              query: {
                lang: lang2
              }
            });
            setTimeout(() => location.reload(), 0);
          }
        };
        const name = ref("index");
        let showColorVarDropdown = ref(false);
        const text = computed(() => `${device.value.width || $t("headerWidth")} x ${device.value.height || $t("headerHeight")}`);
        const zoomText = computed(() => `${Math.round(device.value.zoom * 100)}%`);
        const hoverIndex = ref(-1);
        const activeIndex = computed(() => deviceList.value.findIndex((d) => device.value.width === d[0] && device.value.height === d[1]));
        const setDeviceBySize = (index2) => {
          setDevice(index2);
          nextTick$1(() => emitter.emit("location", true));
        };
        const handleDeviceChange = () => {
          deviceType.value = deviceType.value === "mobile" ? "desktop" : "mobile";
          setDevice(0);
          nextTick$1(() => emitter.emit("location", true));
        };
        const modeMap = {
          edit: {
            title: $t("editMode"),
            icon: "edit"
          },
          drag: {
            title: $t("dragMode"),
            icon: "drag"
          },
          preview: {
            title: $t("previewMode"),
            icon: "preview"
          }
        };
        const handleModeClick = (value) => {
          setDisplayMode(value);
        };
        const handleFontSizeSwitch = (value) => {
          if (value) {
            setMediaFontSize(device.value.width, curFootSize.value);
          } else {
            setMediaFontSize(device.value.width, 0);
          }
        };
        const handleFontSizeChange = (value) => setMediaFontSize(device.value.width, value);
        useKeyPress(ShortcutKey.switchDevice, () => {
          if (setting.value.client !== "both")
            return;
          handleDeviceChange();
        });
        useKeyPress(ShortcutKey.SwitchDisplayMode, (e) => {
          e.preventDefault();
          const displayModeList = ["edit", "drag", "preview"];
          setDisplayMode(displayModeList[(displayModeList.indexOf(displayMode.value) + 1) % 3]);
        });
        useKeyPress(ShortcutKey.SwitchMaterialPanel, (e) => {
          e.preventDefault();
          emitter.emit("switchMaterialsPanel");
        });
        useKeyPress(ShortcutKey.saveProject, (e) => {
          if (e.shiftKey)
            return;
          e.preventDefault();
          emit("save");
        });
        emitter.on("saveColorVars", (color) => {
          showColorVarDropdown.value = true;
          colorVars.value.push({
            name: "",
            color
          });
        });
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          const _directive_hover = resolveDirective("hover");
          return openBlock(), createElementBlock("div", _hoisted_1$b, [
            createBaseVNode("div", _hoisted_2$9, [
              createBaseVNode("div", _hoisted_3$7, toDisplayString(name.value), 1),
              _hoisted_4$3,
              withDirectives((openBlock(), createBlock(Btn, {
                class: "project-setting-btn",
                type: "text",
                color: "default",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("project-setting"))
              }, {
                default: withCtx(() => [
                  createVNode(Icon$1, {
                    name: "project-setting",
                    size: 16
                  })
                ]),
                _: 1
              })), [
                [_directive_tooltip, unref$1($t)("projectSetting")]
              ])
            ]),
            createBaseVNode("div", _hoisted_5$3, [
              createVNode(_sfc_main$X, {
                shown: showColorVarDropdown.value,
                placement: "bottom",
                type: "pure-dropdown",
                distance: 10,
                onApplyHide: _cache[1] || (_cache[1] = ($event) => showColorVarDropdown.value = false)
              }, {
                default: withCtx(({ shown }) => [
                  createBaseVNode("div", {
                    class: normalizeClass(["color-plate", { active: shown }])
                  }, [
                    createVNode(Icon$1, {
                      name: "color",
                      size: 18
                    })
                  ], 2)
                ]),
                content: withCtx(() => [
                  createVNode(ColorVarList)
                ]),
                _: 1
              }, 8, ["shown"]),
              createVNode(_sfc_main$X, {
                placement: "bottom",
                distance: 10
              }, {
                content: withCtx(() => [
                  createBaseVNode("div", _hoisted_8, [
                    createBaseVNode("div", _hoisted_9, [
                      createBaseVNode("span", null, [
                        createTextVNode(toDisplayString(unref$1($t)("simulator")) + " ", 1),
                        hoverIndex.value > -1 ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString(unref$1(deviceList)[hoverIndex.value][0] + " \xD7 " + unref$1(deviceList)[hoverIndex.value][1]), 1)) : createCommentVNode("", true)
                      ]),
                      unref$1(setting).client === "both" ? (openBlock(), createBlock(Btn, {
                        key: 0,
                        type: "text",
                        icon: "switch",
                        size: "sm",
                        class: "switch-device-btn",
                        onClick: handleDeviceChange
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref$1(deviceType) === "desktop" ? unref$1($t)("mobile") : unref$1($t)("desktop")), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("div", _hoisted_11, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(deviceList), (item, index2) => {
                        return withDirectives((openBlock(), createElementBlock("div", {
                          class: normalizeClass(["device-item", { active: activeIndex.value === index2 }]),
                          key: index2,
                          onClick: ($event) => setDeviceBySize(index2)
                        }, [
                          unref$1(deviceType) === "mobile" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            index2 === 0 ? (openBlock(), createBlock(Icon$1, {
                              key: 0,
                              name: "mobile",
                              type: "pure",
                              size: 20
                            })) : index2 === 1 ? (openBlock(), createBlock(Icon$1, {
                              key: 1,
                              name: "mobile",
                              type: "pure",
                              size: 24
                            })) : (openBlock(), createBlock(Icon$1, {
                              key: 2,
                              name: "tablet",
                              type: "pure",
                              size: 26
                            }))
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            index2 === 0 ? (openBlock(), createBlock(Icon$1, {
                              key: 0,
                              name: "device-sm",
                              type: "pure",
                              size: 28
                            })) : index2 === 1 ? (openBlock(), createBlock(Icon$1, {
                              key: 1,
                              name: "device-md",
                              type: "pure",
                              size: 28
                            })) : (openBlock(), createBlock(Icon$1, {
                              key: 2,
                              name: "device-lg",
                              type: "pure",
                              size: 28
                            }))
                          ], 64))
                        ], 10, _hoisted_12)), [
                          [_directive_hover, (isHover) => hoverIndex.value = isHover ? index2 : -1]
                        ]);
                      }), 128))
                    ]),
                    createBaseVNode("div", _hoisted_13, [
                      createBaseVNode("span", null, [
                        createTextVNode(toDisplayString(unref$1($t)("zoom")) + " ", 1),
                        createBaseVNode("span", _hoisted_14, toDisplayString(zoomText.value), 1)
                      ])
                    ]),
                    createVNode(_sfc_main$E, {
                      width: "200px",
                      modelValue: unref$1(device).zoom,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref$1(device).zoom = $event),
                      min: 0.2,
                      max: 2,
                      interval: 0.01,
                      contained: true
                    }, null, 8, ["modelValue", "min", "interval"]),
                    createBaseVNode("div", _hoisted_15, [
                      createBaseVNode("span", null, [
                        createTextVNode(toDisplayString(unref$1($t)("mediaFontSize")) + " ", 1),
                        withDirectives(createVNode(Icon$1, {
                          name: "question",
                          class: "question-icon",
                          size: 13
                        }, null, 512), [
                          [_directive_tooltip, {
                            content: unref$1($t)("mediaFontSizeTip")
                          }]
                        ]),
                        createBaseVNode("span", _hoisted_16, toDisplayString(unref$1(curFootSize)) + "px", 1)
                      ]),
                      createVNode(Switch, {
                        "model-value": !!unref$1(curWidthFootSize),
                        "onUpdate:modelValue": handleFontSizeSwitch
                      }, null, 8, ["model-value"])
                    ]),
                    !!unref$1(curWidthFootSize) ? (openBlock(), createBlock(_sfc_main$E, {
                      key: 0,
                      width: "200px",
                      "model-value": unref$1(curWidthFootSize),
                      min: 10,
                      max: 100,
                      interval: 1,
                      contained: true,
                      "onUpdate:modelValue": handleFontSizeChange
                    }, null, 8, ["model-value"])) : createCommentVNode("", true)
                  ])
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_6$2, [
                    createTextVNode(toDisplayString(text.value), 1),
                    createBaseVNode("span", _hoisted_7, toDisplayString(zoomText.value), 1)
                  ])
                ]),
                _: 1
              }),
              createVNode(Select, {
                class: normalizeClass(["mode-wrapper", unref$1(displayMode)]),
                options: modeMap,
                display: "inline",
                placement: "bottom-start",
                "model-value": unref$1(displayMode),
                "onUpdate:modelValue": handleModeClick
              }, {
                value: withCtx(() => [
                  createVNode(Icon$1, {
                    class: "icon",
                    name: modeMap[unref$1(displayMode)].icon,
                    size: unref$1(displayMode) === "preview" ? 13 : 11
                  }, null, 8, ["name", "size"]),
                  createBaseVNode("span", null, toDisplayString(modeMap[unref$1(displayMode)].title), 1)
                ]),
                _: 1
              }, 8, ["class", "model-value"])
            ]),
            createBaseVNode("div", _hoisted_17, [
              withDirectives(createVNode(Icon$1, {
                class: normalizeClass(["undo-icon", { disabled: !unref$1(canUndoHistory) }]),
                name: "redo",
                size: 16,
                type: "btn",
                onClick: _cache[3] || (_cache[3] = () => unref$1(canUndoHistory) && unref$1(updateAllPageNode)(unref$1(undoHistory)()))
              }, null, 8, ["class"]), [
                [_directive_tooltip, unref$1($t)("redo")]
              ]),
              withDirectives(createVNode(Icon$1, {
                class: normalizeClass(["redo-icon", { disabled: !unref$1(canRedoHistory) }]),
                name: "redo",
                size: 16,
                type: "btn",
                onClick: _cache[4] || (_cache[4] = () => unref$1(canRedoHistory) && unref$1(updateAllPageNode)(unref$1(redoHistory)()))
              }, null, 8, ["class"]), [
                [_directive_tooltip, unref$1($t)("redo")]
              ]),
              withDirectives(createVNode(Btn, {
                class: "save-btn",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("save")),
                disabled: unref$1(allPageData).length === 0,
                icon: "save",
                type: "icon",
                color: "second"
              }, null, 8, ["disabled"]), [
                [_directive_tooltip, unref$1($t)("save")]
              ]),
              createVNode(Btn, {
                class: "download-btn",
                onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("download")),
                disabled: unref$1(allPageData).length === 0,
                text: unref$1($t)("download")
              }, null, 8, ["disabled", "text"]),
              createVNode(_sfc_main$X, {
                type: "pure-dropdown",
                "popper-class": "user-dropdown"
              }, {
                content: withCtx(({ hide }) => [
                  createBaseVNode("div", _hoisted_18, [
                    unref$1(isAuthenticated) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createBaseVNode("div", _hoisted_19, toDisplayString(unref$1(userName)), 1),
                      createBaseVNode("div", {
                        class: "item",
                        onClick: () => {
                          gotoMePage();
                          hide();
                        }
                      }, toDisplayString(unref$1($t)("profile")), 9, _hoisted_20),
                      createBaseVNode("div", {
                        class: "item",
                        onClick: () => {
                          switchLang(unref$1(lang) === "en" ? "zh" : "en");
                          hide();
                        }
                      }, toDisplayString(unref$1(lang) === "zh" ? unref$1($t)("switchToEN") : unref$1($t)("switchToZH")), 9, _hoisted_21),
                      createBaseVNode("div", {
                        class: "item danger",
                        onClick: () => {
                          handleSignOut();
                          hide();
                        }
                      }, toDisplayString(unref$1($t)("signOut")), 9, _hoisted_22)
                    ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createBaseVNode("div", {
                        class: "item",
                        onClick: () => {
                          switchLang(unref$1(lang) === "en" ? "zh" : "en");
                          hide();
                        }
                      }, toDisplayString(unref$1(lang) === "zh" ? unref$1($t)("switchToEN") : unref$1($t)("switchToZH")), 9, _hoisted_23),
                      createBaseVNode("div", {
                        class: "item primary",
                        onClick: handleSignIn
                      }, toDisplayString(unref$1($t)("signIn")), 1)
                    ], 64))
                  ])
                ]),
                default: withCtx(() => [
                  createVNode(Avatar, {
                    image: unref$1(avatar),
                    size: 36,
                    "can-operator": ""
                  }, null, 8, ["image"])
                ]),
                _: 1
              })
            ])
          ]);
        };
      }
    });
    const ConfigHeader_vue_vue_type_style_index_0_scoped_5e68e709_lang = "";
    const ConfigHeader_vue_vue_type_style_index_1_lang = "";
    const ConfigHeader = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-5e68e709"]]);
    const _hoisted_1$a = { class: "element" };
    const _hoisted_2$8 = { class: "name" };
    const _hoisted_3$6 = { class: "text" };
    const _hoisted_4$2 = { class: "image" };
    const _hoisted_5$2 = ["src", "srcset"];
    const _hoisted_6$1 = {
      key: 1,
      class: "image-placeholder"
    };
    const _sfc_main$b = /* @__PURE__ */ defineComponent({
      __name: "Element",
      props: {
        cover: { default: "" },
        name: null,
        canOperate: { type: Boolean }
      },
      setup(__props) {
        let coverUrl = ref(__props.cover);
        let srcset = computed(() => {
          if (coverUrl.value && window.devicePixelRatio >= 2) {
            return `${coverUrl.value} 2x`;
          }
          return "";
        });
        watch(() => __props.cover, () => {
          coverUrl.value = __props.cover;
        });
        const handleCoverError = () => {
          coverUrl.value = imgErrorFallback;
        };
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", _hoisted_1$a, [
            createBaseVNode("div", _hoisted_2$8, [
              createBaseVNode("span", _hoisted_3$6, toDisplayString(__props.name), 1),
              __props.canOperate ? withDirectives((openBlock(), createBlock(Icon$1, {
                key: 0,
                type: "cube",
                class: "element-btn",
                name: "advanced",
                size: 11,
                onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("edit"), ["stop"]))
              }, null, 512)), [
                [_directive_tooltip, _ctx.$t("setting")]
              ]) : createCommentVNode("", true),
              __props.canOperate ? withDirectives((openBlock(), createBlock(Icon$1, {
                key: 1,
                type: "cube",
                class: "element-btn danger",
                name: "delete",
                size: 10,
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("delete"), ["stop"]))
              }, null, 512)), [
                [_directive_tooltip, _ctx.$t("delete")]
              ]) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_4$2, [
              coverUrl.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: coverUrl.value,
                srcset: srcset.value,
                onError: handleCoverError
              }, null, 40, _hoisted_5$2)) : (openBlock(), createElementBlock("div", _hoisted_6$1, [
                createVNode(Icon$1, {
                  name: "empty",
                  size: 24
                }),
                createBaseVNode("span", null, toDisplayString(_ctx.$t("notCover")), 1)
              ]))
            ])
          ]);
        };
      }
    });
    const Element_vue_vue_type_style_index_0_scoped_aa29ceec_lang = "";
    const Element$1 = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-aa29ceec"]]);
    const getMockBlock = (initType, name) => {
      const type2 = initType || "component";
      return {
        type: type2,
        name: name || (type2 === "component" ? "Block" : "Section"),
        component: "Block",
        tags: [],
        config: {
          props: {
            common: getDefaultCommon(),
            size: getDefaultSize(type2),
            layout: getDefaultLayout(),
            spacing: getDefaultSpacing(),
            border: getDefaultBorder(),
            container: getDefaultContainer(),
            background: getDefaultBackground({}),
            position: getDefaultPosition(),
            event: getDefaultEvent(),
            effect: getDefaultEffect(),
            animation: getDefaultAnimation()
          }
        },
        children: []
      };
    };
    const getMockText = () => {
      return {
        type: "component",
        name: "Text",
        component: "Text",
        tags: ["Text"],
        config: {
          props: {
            common: getDefaultCommon(),
            basic: getDefaultBasic("Text"),
            font: getDefaultFont(),
            spacing: getDefaultSpacing(),
            border: getDefaultBorder(),
            background: getDefaultBackground(),
            container: getDefaultContainer(),
            position: getDefaultPosition(),
            event: getDefaultEvent(),
            effect: getDefaultEffect(),
            animation: getDefaultAnimation()
          }
        }
      };
    };
    const getMockImage = (src2) => {
      return {
        type: "component",
        name: "Image",
        component: "Image",
        tags: ["Image"],
        config: {
          props: {
            common: getDefaultCommon(),
            basic: getDefaultBasic("Image"),
            size: getDefaultSize("component"),
            spacing: getDefaultSpacing(),
            border: getDefaultBorder(),
            container: getDefaultContainer(),
            position: getDefaultPosition(),
            event: getDefaultEvent(),
            effect: getDefaultEffect(),
            animation: getDefaultAnimation()
          }
        }
      };
    };
    const getMockIcon = (name) => {
      return {
        type: "component",
        name: "Icon",
        component: "Icon",
        tags: ["Icon"],
        config: {
          props: {
            common: getDefaultCommon(),
            basic: getDefaultBasic("Icon"),
            spacing: getDefaultSpacing(),
            border: getDefaultBorder(),
            event: getDefaultEvent(),
            effect: getDefaultEffect()
          }
        }
      };
    };
    const EmptySection = {
      name: "\u7A7A\u767D\u7AE0\u8282",
      enName: "Empty Section",
      category: "\u57FA\u7840",
      categoryEn: "Basic",
      type: "section",
      cover: "",
      dataType: DataType.Page,
      node: getMockBlock("section")
    };
    const EmptyBlock = {
      name: "\u5BB9\u5668",
      enName: "Block",
      category: "\u57FA\u7840",
      categoryEn: "Basic",
      type: "component",
      cover: "",
      dataType: DataType.Page,
      node: getMockBlock("component")
    };
    const EmptyText = {
      name: "\u6587\u672C",
      enName: "Text",
      category: "\u57FA\u7840",
      categoryEn: "Basic",
      type: "component",
      cover: "",
      dataType: DataType.Page,
      node: getMockText()
    };
    const EmptyImage = {
      name: "\u56FE\u7247",
      enName: "Image",
      category: "\u57FA\u7840",
      categoryEn: "Basic",
      type: "component",
      cover: "",
      dataType: DataType.Page,
      node: getMockImage()
    };
    const EmptyIcon = {
      name: "\u56FE\u6807",
      enName: "Icon",
      category: "\u57FA\u7840",
      categoryEn: "Basic",
      type: "component",
      cover: "",
      dataType: DataType.Page,
      node: getMockIcon()
    };
    const _hoisted_1$9 = { class: "materials-panel" };
    const _hoisted_2$7 = { class: "title" };
    const _hoisted_3$5 = ["onDragstart"];
    const _sfc_main$a = /* @__PURE__ */ defineComponent({
      __name: "MaterialsPanel",
      setup(__props) {
        const pageStore = usePageStore();
        const { pageData, materialData } = storeToRefs(pageStore);
        const { addSection, deleteMaterial } = pageStore;
        const dragStore = useDragStore();
        const { setDragNode, setIsCancelDrag } = dragStore;
        const displayStore = useDisplayStore();
        const { displayMode } = storeToRefs(displayStore);
        const { setDisplayMode } = displayStore;
        const userStore = useUserStore();
        const { isAdmin, uid: uid2 } = storeToRefs(userStore);
        let preDisplayMode = ref("edit");
        let currentType = ref("section");
        let draggableRef = ref(null);
        let showSaveMaterialModal = ref(false);
        let curMaterial = ref(null);
        const handleAddSection = (material) => {
          const node = material.node;
          if ((node == null ? void 0 : node.type) === "section") {
            if (material.uid === uid2.value) {
              node.materialId = material.id;
            }
            addSection(node);
          }
        };
        const handleDragend = () => {
          setDragNode(null);
          setDisplayMode(preDisplayMode.value);
          setIsCancelDrag(false);
        };
        const handleDragStart = (event, material) => {
          const imgElem = event.target.querySelector(".image");
          const node = material.node;
          if (!node)
            return;
          event.dataTransfer.setDragImage(imgElem, 0, 0);
          if (node.type === "component" && pageData.value.length === 0) {
            Alert($t("noSectionTip"));
          }
          if (material.uid === uid2.value) {
            node.materialId = material.id;
          }
          setDragNode(node);
          preDisplayMode.value = displayMode.value;
          setDisplayMode("drag");
          setTimeout(() => emitter.emit("switchMaterialsPanel", false), 100);
        };
        const handleDelete = async (item) => {
          if (await Modal.confirm($t("deleteConfirm", getMaterialName(item)))) {
            await deleteMaterial(item.id);
            Alert($t("deleteSuccess"));
          }
        };
        const currentNodeList = computed(() => {
          const list = materialData.value[currentType.value];
          if (isAdmin.value) {
            if (currentType.value === "section") {
              return [...list, EmptySection];
            }
            if (currentType.value === "component") {
              return [...list, EmptyBlock, EmptyText, EmptyImage, EmptyIcon];
            }
          }
          return list;
        });
        const currentCategory = computed(() => {
          let map = {};
          currentNodeList.value.forEach((item) => {
            const category = getMaterialCategory(item) || $t("notGroup");
            if (!map[category])
              map[category] = [];
            map[category].push(item);
          });
          return map;
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$9, [
            createVNode(Tabs, {
              class: "materials-panel-tabs",
              data: { section: unref$1($t)("section"), component: unref$1($t)("component") },
              modelValue: currentType.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => currentType.value = $event),
              type: "float"
            }, null, 8, ["data", "modelValue"]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(currentCategory.value, (list, category) => {
              return withDirectives((openBlock(), createElementBlock("section", null, [
                createBaseVNode("div", _hoisted_2$7, toDisplayString(category), 1),
                createVNode(unref$1(draggable), {
                  ref_for: true,
                  ref_key: "draggableRef",
                  ref: draggableRef,
                  class: "element-list",
                  tag: "div",
                  "model-value": list,
                  sort: false,
                  "item-key": "id",
                  group: { name: currentType.value, pull: "clone", put: false },
                  onEnd: handleDragend
                }, {
                  item: withCtx(({ element: item }) => [
                    (openBlock(), createElementBlock("div", {
                      class: normalizeClass(["element-item", { "status-hidden": item.status === unref$1(DataStatus).Hidden }]),
                      key: item.name,
                      onDragstart: (event) => handleDragStart(event, item)
                    }, [
                      createVNode(Element$1, {
                        cover: item.cover,
                        name: unref$1(getMaterialName)(item),
                        "can-operate": unref$1(isAdmin) || item.uid === unref$1(uid2),
                        onClick: ($event) => handleAddSection(item),
                        onDelete: ($event) => handleDelete(item),
                        onEdit: () => {
                          curMaterial.value = item;
                          showSaveMaterialModal.value = true;
                        }
                      }, null, 8, ["cover", "name", "can-operate", "onClick", "onDelete", "onEdit"])
                    ], 42, _hoisted_3$5))
                  ]),
                  _: 2
                }, 1032, ["model-value", "group"])
              ], 512)), [
                [vShow, Array.isArray(list) && list.length > 0]
              ]);
            }), 256)),
            curMaterial.value ? (openBlock(), createBlock(_sfc_main$o, {
              key: 0,
              "action-text": unref$1($t)("edit"),
              material: curMaterial.value,
              "hide-create-cover": "",
              modelValue: showSaveMaterialModal.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => showSaveMaterialModal.value = $event)
            }, null, 8, ["action-text", "material", "modelValue"])) : createCommentVNode("", true)
          ]);
        };
      }
    });
    const MaterialsPanel_vue_vue_type_style_index_0_scoped_58000399_lang = "";
    const MaterialsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-58000399"]]);
    const _hoisted_1$8 = { class: "keyboard-list" };
    const _hoisted_2$6 = { class: "keyboard-item-value" };
    const _sfc_main$9 = /* @__PURE__ */ defineComponent({
      __name: "Keyboard",
      props: {
        show: { type: Boolean }
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$8, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(ShortcutMap), (map, key) => {
              return openBlock(), createElementBlock("div", {
                class: "keyboard-item",
                key
              }, [
                createBaseVNode("div", null, toDisplayString(map.title) + "\uFF1A", 1),
                createBaseVNode("div", _hoisted_2$6, toDisplayString(map.value), 1)
              ]);
            }), 128))
          ], 512)), [
            [vShow, __props.show]
          ]);
        };
      }
    });
    const Keyboard_vue_vue_type_style_index_0_scoped_c80fbb59_lang = "";
    const Keyboard = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-c80fbb59"]]);
    var wheel$1 = { exports: {} };
    wheel$1.exports = addWheelListener;
    wheel$1.exports.addWheelListener = addWheelListener;
    wheel$1.exports.removeWheelListener = removeWheelListener;
    function addWheelListener(element, listener, useCapture) {
      element.addEventListener("wheel", listener, useCapture);
    }
    function removeWheelListener(element, listener, useCapture) {
      element.removeEventListener("wheel", listener, useCapture);
    }
    var amator = { exports: {} };
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 1e-3;
    var SUBDIVISION_PRECISION = 1e-7;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1 / (kSplineTableSize - 1);
    var float32ArraySupported = typeof Float32Array === "function";
    function A(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
    }
    function B(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
    }
    function C(aA1) {
      return 3 * aA1;
    }
    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function getSlope(aT, aA1, aA2) {
      return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i2 = 0;
      do {
        currentT = aA + (aB - aA) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0) {
          return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    }
    function LinearEasing(x) {
      return x;
    }
    var src = function bezier(mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
      }
      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
        sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
      }
      function getTForX(aX) {
        var intervalStart = 0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
      return function BezierEasing2(x) {
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };
    var BezierEasing = src;
    var animations = {
      ease: BezierEasing(0.25, 0.1, 0.25, 1),
      easeIn: BezierEasing(0.42, 0, 1, 1),
      easeOut: BezierEasing(0, 0, 0.58, 1),
      easeInOut: BezierEasing(0.42, 0, 0.58, 1),
      linear: BezierEasing(0, 0, 1, 1)
    };
    amator.exports = animate$1;
    amator.exports.makeAggregateRaf = makeAggregateRaf;
    amator.exports.sharedScheduler = makeAggregateRaf();
    function animate$1(source, target, options) {
      var start = /* @__PURE__ */ Object.create(null);
      var diff = /* @__PURE__ */ Object.create(null);
      options = options || {};
      var easing = typeof options.easing === "function" ? options.easing : animations[options.easing];
      if (!easing) {
        if (options.easing) {
          console.warn("Unknown easing function in amator: " + options.easing);
        }
        easing = animations.ease;
      }
      var step = typeof options.step === "function" ? options.step : noop$2;
      var done = typeof options.done === "function" ? options.done : noop$2;
      var scheduler = getScheduler(options.scheduler);
      var keys2 = Object.keys(target);
      keys2.forEach(function(key) {
        start[key] = source[key];
        diff[key] = target[key] - source[key];
      });
      var durationInMs = typeof options.duration === "number" ? options.duration : 400;
      var durationInFrames = Math.max(1, durationInMs * 0.06);
      var previousAnimationId;
      var frame = 0;
      previousAnimationId = scheduler.next(loop);
      return {
        cancel
      };
      function cancel() {
        scheduler.cancel(previousAnimationId);
        previousAnimationId = 0;
      }
      function loop() {
        var t = easing(frame / durationInFrames);
        frame += 1;
        setValues(t);
        if (frame <= durationInFrames) {
          previousAnimationId = scheduler.next(loop);
          step(source);
        } else {
          previousAnimationId = 0;
          setTimeout(function() {
            done(source);
          }, 0);
        }
      }
      function setValues(t) {
        keys2.forEach(function(key) {
          source[key] = diff[key] * t + start[key];
        });
      }
    }
    function noop$2() {
    }
    function getScheduler(scheduler) {
      if (!scheduler) {
        var canRaf = typeof window !== "undefined" && window.requestAnimationFrame;
        return canRaf ? rafScheduler() : timeoutScheduler();
      }
      if (typeof scheduler.next !== "function")
        throw new Error("Scheduler is supposed to have next(cb) function");
      if (typeof scheduler.cancel !== "function")
        throw new Error("Scheduler is supposed to have cancel(handle) function");
      return scheduler;
    }
    function rafScheduler() {
      return {
        next: window.requestAnimationFrame.bind(window),
        cancel: window.cancelAnimationFrame.bind(window)
      };
    }
    function timeoutScheduler() {
      return {
        next: function(cb) {
          return setTimeout(cb, 1e3 / 60);
        },
        cancel: function(id) {
          return clearTimeout(id);
        }
      };
    }
    function makeAggregateRaf() {
      var frontBuffer = /* @__PURE__ */ new Set();
      var backBuffer = /* @__PURE__ */ new Set();
      var frameToken = 0;
      return {
        next,
        cancel: next,
        clearAll
      };
      function clearAll() {
        frontBuffer.clear();
        backBuffer.clear();
        cancelAnimationFrame(frameToken);
        frameToken = 0;
      }
      function next(callback) {
        backBuffer.add(callback);
        renderNextFrame();
      }
      function renderNextFrame() {
        if (!frameToken)
          frameToken = requestAnimationFrame(renderFrame);
      }
      function renderFrame() {
        frameToken = 0;
        var t = backBuffer;
        backBuffer = frontBuffer;
        frontBuffer = t;
        frontBuffer.forEach(function(callback) {
          callback();
        });
        frontBuffer.clear();
      }
    }
    var ngraph_events = function eventify2(subject) {
      validateSubject(subject);
      var eventsStorage = createEventsStorage(subject);
      subject.on = eventsStorage.on;
      subject.off = eventsStorage.off;
      subject.fire = eventsStorage.fire;
      return subject;
    };
    function createEventsStorage(subject) {
      var registeredEvents = /* @__PURE__ */ Object.create(null);
      return {
        on: function(eventName, callback, ctx) {
          if (typeof callback !== "function") {
            throw new Error("callback is expected to be a function");
          }
          var handlers = registeredEvents[eventName];
          if (!handlers) {
            handlers = registeredEvents[eventName] = [];
          }
          handlers.push({ callback, ctx });
          return subject;
        },
        off: function(eventName, callback) {
          var wantToRemoveAll = typeof eventName === "undefined";
          if (wantToRemoveAll) {
            registeredEvents = /* @__PURE__ */ Object.create(null);
            return subject;
          }
          if (registeredEvents[eventName]) {
            var deleteAllCallbacksForEvent = typeof callback !== "function";
            if (deleteAllCallbacksForEvent) {
              delete registeredEvents[eventName];
            } else {
              var callbacks = registeredEvents[eventName];
              for (var i2 = 0; i2 < callbacks.length; ++i2) {
                if (callbacks[i2].callback === callback) {
                  callbacks.splice(i2, 1);
                }
              }
            }
          }
          return subject;
        },
        fire: function(eventName) {
          var callbacks = registeredEvents[eventName];
          if (!callbacks) {
            return subject;
          }
          var fireArguments;
          if (arguments.length > 1) {
            fireArguments = Array.prototype.splice.call(arguments, 1);
          }
          for (var i2 = 0; i2 < callbacks.length; ++i2) {
            var callbackInfo = callbacks[i2];
            callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
          }
          return subject;
        }
      };
    }
    function validateSubject(subject) {
      if (!subject) {
        throw new Error("Eventify cannot use falsy object as events subject");
      }
      var reservedWords = ["on", "fire", "off"];
      for (var i2 = 0; i2 < reservedWords.length; ++i2) {
        if (subject.hasOwnProperty(reservedWords[i2])) {
          throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i2] + "'");
        }
      }
    }
    var kinetic_1 = kinetic$1;
    function kinetic$1(getPoint, scroll, settings) {
      if (typeof settings !== "object") {
        settings = {};
      }
      var minVelocity = typeof settings.minVelocity === "number" ? settings.minVelocity : 5;
      var amplitude = typeof settings.amplitude === "number" ? settings.amplitude : 0.25;
      var cancelAnimationFrame2 = typeof settings.cancelAnimationFrame === "function" ? settings.cancelAnimationFrame : getCancelAnimationFrame();
      var requestAnimationFrame2 = typeof settings.requestAnimationFrame === "function" ? settings.requestAnimationFrame : getRequestAnimationFrame();
      var lastPoint;
      var timestamp;
      var timeConstant = 342;
      var ticker;
      var vx, targetX, ax;
      var vy, targetY, ay;
      var raf;
      return {
        start,
        stop: stop2,
        cancel: dispose
      };
      function dispose() {
        cancelAnimationFrame2(ticker);
        cancelAnimationFrame2(raf);
      }
      function start() {
        lastPoint = getPoint();
        ax = ay = vx = vy = 0;
        timestamp = new Date();
        cancelAnimationFrame2(ticker);
        cancelAnimationFrame2(raf);
        ticker = requestAnimationFrame2(track2);
      }
      function track2() {
        var now2 = Date.now();
        var elapsed = now2 - timestamp;
        timestamp = now2;
        var currentPoint = getPoint();
        var dx = currentPoint.x - lastPoint.x;
        var dy = currentPoint.y - lastPoint.y;
        lastPoint = currentPoint;
        var dt = 1e3 / (1 + elapsed);
        vx = 0.8 * dx * dt + 0.2 * vx;
        vy = 0.8 * dy * dt + 0.2 * vy;
        ticker = requestAnimationFrame2(track2);
      }
      function stop2() {
        cancelAnimationFrame2(ticker);
        cancelAnimationFrame2(raf);
        var currentPoint = getPoint();
        targetX = currentPoint.x;
        targetY = currentPoint.y;
        timestamp = Date.now();
        if (vx < -minVelocity || vx > minVelocity) {
          ax = amplitude * vx;
          targetX += ax;
        }
        if (vy < -minVelocity || vy > minVelocity) {
          ay = amplitude * vy;
          targetY += ay;
        }
        raf = requestAnimationFrame2(autoScroll2);
      }
      function autoScroll2() {
        var elapsed = Date.now() - timestamp;
        var moving = false;
        var dx = 0;
        var dy = 0;
        if (ax) {
          dx = -ax * Math.exp(-elapsed / timeConstant);
          if (dx > 0.5 || dx < -0.5)
            moving = true;
          else
            dx = ax = 0;
        }
        if (ay) {
          dy = -ay * Math.exp(-elapsed / timeConstant);
          if (dy > 0.5 || dy < -0.5)
            moving = true;
          else
            dy = ay = 0;
        }
        if (moving) {
          scroll(targetX + dx, targetY + dy);
          raf = requestAnimationFrame2(autoScroll2);
        }
      }
    }
    function getCancelAnimationFrame() {
      if (typeof cancelAnimationFrame === "function")
        return cancelAnimationFrame;
      return clearTimeout;
    }
    function getRequestAnimationFrame() {
      if (typeof requestAnimationFrame === "function")
        return requestAnimationFrame;
      return function(handler) {
        return setTimeout(handler, 16);
      };
    }
    var createTextSelectionInterceptor_1 = createTextSelectionInterceptor$1;
    function createTextSelectionInterceptor$1(useFake) {
      if (useFake) {
        return {
          capture: noop$1,
          release: noop$1
        };
      }
      var dragObject;
      var prevSelectStart;
      var prevDragStart;
      var wasCaptured = false;
      return {
        capture,
        release
      };
      function capture(domObject) {
        wasCaptured = true;
        prevSelectStart = window.document.onselectstart;
        prevDragStart = window.document.ondragstart;
        window.document.onselectstart = disabled;
        dragObject = domObject;
        dragObject.ondragstart = disabled;
      }
      function release() {
        if (!wasCaptured)
          return;
        wasCaptured = false;
        window.document.onselectstart = prevSelectStart;
        if (dragObject)
          dragObject.ondragstart = prevDragStart;
      }
    }
    function disabled(e) {
      e.stopPropagation();
      return false;
    }
    function noop$1() {
    }
    var transform;
    var hasRequiredTransform;
    function requireTransform() {
      if (hasRequiredTransform)
        return transform;
      hasRequiredTransform = 1;
      transform = Transform2;
      function Transform2() {
        this.x = 0;
        this.y = 0;
        this.scale = 1;
      }
      return transform;
    }
    var svgController = { exports: {} };
    var hasRequiredSvgController;
    function requireSvgController() {
      if (hasRequiredSvgController)
        return svgController.exports;
      hasRequiredSvgController = 1;
      svgController.exports = makeSvgController2;
      svgController.exports.canAttach = isSVGElement;
      function makeSvgController2(svgElement, options) {
        if (!isSVGElement(svgElement)) {
          throw new Error("svg element is required for svg.panzoom to work");
        }
        var owner = svgElement.ownerSVGElement;
        if (!owner) {
          throw new Error("Do not apply panzoom to the root <svg> element. Use its child instead (e.g. <g></g>). As of March 2016 only FireFox supported transform on the root element");
        }
        if (!options.disableKeyboardInteraction) {
          owner.setAttribute("tabindex", 0);
        }
        var api = {
          getBBox,
          getScreenCTM,
          getOwner,
          applyTransform,
          initTransform
        };
        return api;
        function getOwner() {
          return owner;
        }
        function getBBox() {
          var bbox = svgElement.getBBox();
          return {
            left: bbox.x,
            top: bbox.y,
            width: bbox.width,
            height: bbox.height
          };
        }
        function getScreenCTM() {
          var ctm = owner.getCTM();
          if (!ctm) {
            return owner.getScreenCTM();
          }
          return ctm;
        }
        function initTransform(transform2) {
          var screenCTM = svgElement.getCTM();
          if (screenCTM === null) {
            screenCTM = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
          }
          transform2.x = screenCTM.e;
          transform2.y = screenCTM.f;
          transform2.scale = screenCTM.a;
          owner.removeAttributeNS(null, "viewBox");
        }
        function applyTransform(transform2) {
          svgElement.setAttribute("transform", "matrix(" + transform2.scale + " 0 0 " + transform2.scale + " " + transform2.x + " " + transform2.y + ")");
        }
      }
      function isSVGElement(element) {
        return element && element.ownerSVGElement && element.getCTM;
      }
      return svgController.exports;
    }
    var domController = { exports: {} };
    var hasRequiredDomController;
    function requireDomController() {
      if (hasRequiredDomController)
        return domController.exports;
      hasRequiredDomController = 1;
      domController.exports = makeDomController2;
      domController.exports.canAttach = isDomElement;
      function makeDomController2(domElement, options) {
        var elementValid = isDomElement(domElement);
        if (!elementValid) {
          throw new Error("panzoom requires DOM element to be attached to the DOM tree");
        }
        var owner = domElement.parentElement;
        domElement.scrollTop = 0;
        if (!options.disableKeyboardInteraction) {
          owner.setAttribute("tabindex", 0);
        }
        var api = {
          getBBox,
          getOwner,
          applyTransform
        };
        return api;
        function getOwner() {
          return owner;
        }
        function getBBox() {
          return {
            left: 0,
            top: 0,
            width: domElement.clientWidth,
            height: domElement.clientHeight
          };
        }
        function applyTransform(transform2) {
          domElement.style.transformOrigin = "0 0 0";
          domElement.style.transform = "matrix(" + transform2.scale + ", 0, 0, " + transform2.scale + ", " + transform2.x + ", " + transform2.y + ")";
        }
      }
      function isDomElement(element) {
        return element && element.parentElement && element.style;
      }
      return domController.exports;
    }
    var wheel = wheel$1.exports;
    var animate = amator.exports;
    var eventify = ngraph_events;
    var kinetic = kinetic_1;
    var createTextSelectionInterceptor = createTextSelectionInterceptor_1;
    var domTextSelectionInterceptor = createTextSelectionInterceptor();
    var fakeTextSelectorInterceptor = createTextSelectionInterceptor(true);
    var Transform = requireTransform();
    var makeSvgController = requireSvgController();
    var makeDomController = requireDomController();
    var defaultZoomSpeed = 1;
    var defaultDoubleTapZoomSpeed = 1.75;
    var doubleTapSpeedInMS = 300;
    var clickEventTimeInMS = 200;
    var panzoom = createPanZoom;
    function createPanZoom(domElement, options) {
      options = options || {};
      var panController = options.controller;
      if (!panController) {
        if (makeSvgController.canAttach(domElement)) {
          panController = makeSvgController(domElement, options);
        } else if (makeDomController.canAttach(domElement)) {
          panController = makeDomController(domElement, options);
        }
      }
      if (!panController) {
        throw new Error("Cannot create panzoom for the current type of dom element");
      }
      var owner = panController.getOwner();
      var storedCTMResult = { x: 0, y: 0 };
      var isDirty = false;
      var transform2 = new Transform();
      if (panController.initTransform) {
        panController.initTransform(transform2);
      }
      var filterKey = typeof options.filterKey === "function" ? options.filterKey : noop;
      var pinchSpeed = typeof options.pinchSpeed === "number" ? options.pinchSpeed : 1;
      var bounds = options.bounds;
      var maxZoom = typeof options.maxZoom === "number" ? options.maxZoom : Number.POSITIVE_INFINITY;
      var minZoom = typeof options.minZoom === "number" ? options.minZoom : 0;
      var boundsPadding = typeof options.boundsPadding === "number" ? options.boundsPadding : 0.05;
      var zoomDoubleClickSpeed = typeof options.zoomDoubleClickSpeed === "number" ? options.zoomDoubleClickSpeed : defaultDoubleTapZoomSpeed;
      var beforeWheel = options.beforeWheel || noop;
      var beforeMouseDown = options.beforeMouseDown || noop;
      var speed = typeof options.zoomSpeed === "number" ? options.zoomSpeed : defaultZoomSpeed;
      var transformOrigin = parseTransformOrigin(options.transformOrigin);
      var textSelection = options.enableTextSelection ? fakeTextSelectorInterceptor : domTextSelectionInterceptor;
      validateBounds(bounds);
      if (options.autocenter) {
        autocenter();
      }
      var frameAnimation;
      var lastTouchEndTime = 0;
      var lastTouchStartTime = 0;
      var pendingClickEventTimeout = 0;
      var lastMouseDownedEvent = null;
      var lastMouseDownTime = new Date();
      var lastSingleFingerOffset;
      var touchInProgress = false;
      var panstartFired = false;
      var mouseX2;
      var mouseY2;
      var clickX;
      var clickY;
      var pinchZoomLength;
      var smoothScroll;
      if ("smoothScroll" in options && !options.smoothScroll) {
        smoothScroll = rigidScroll();
      } else {
        smoothScroll = kinetic(getPoint, scroll, options.smoothScroll);
      }
      var moveByAnimation;
      var zoomToAnimation;
      var multiTouch;
      var paused = false;
      listenForEvents();
      var api = {
        dispose,
        moveBy: internalMoveBy,
        moveTo,
        smoothMoveTo,
        centerOn,
        zoomTo: publicZoomTo,
        zoomAbs,
        smoothZoom,
        smoothZoomAbs,
        showRectangle,
        pause,
        resume,
        isPaused,
        getTransform: getTransformModel,
        getMinZoom,
        setMinZoom,
        getMaxZoom,
        setMaxZoom,
        getTransformOrigin,
        setTransformOrigin,
        getZoomSpeed,
        setZoomSpeed
      };
      eventify(api);
      var initialX = typeof options.initialX === "number" ? options.initialX : transform2.x;
      var initialY = typeof options.initialY === "number" ? options.initialY : transform2.y;
      var initialZoom = typeof options.initialZoom === "number" ? options.initialZoom : transform2.scale;
      if (initialX != transform2.x || initialY != transform2.y || initialZoom != transform2.scale) {
        zoomAbs(initialX, initialY, initialZoom);
      }
      return api;
      function pause() {
        releaseEvents();
        paused = true;
      }
      function resume() {
        if (paused) {
          listenForEvents();
          paused = false;
        }
      }
      function isPaused() {
        return paused;
      }
      function showRectangle(rect) {
        var clientRect = owner.getBoundingClientRect();
        var size2 = transformToScreen(clientRect.width, clientRect.height);
        var rectWidth = rect.right - rect.left;
        var rectHeight = rect.bottom - rect.top;
        if (!Number.isFinite(rectWidth) || !Number.isFinite(rectHeight)) {
          throw new Error("Invalid rectangle");
        }
        var dw = size2.x / rectWidth;
        var dh = size2.y / rectHeight;
        var scale = Math.min(dw, dh);
        transform2.x = -(rect.left + rectWidth / 2) * scale + size2.x / 2;
        transform2.y = -(rect.top + rectHeight / 2) * scale + size2.y / 2;
        transform2.scale = scale;
      }
      function transformToScreen(x, y) {
        if (panController.getScreenCTM) {
          var parentCTM = panController.getScreenCTM();
          var parentScaleX = parentCTM.a;
          var parentScaleY = parentCTM.d;
          var parentOffsetX = parentCTM.e;
          var parentOffsetY = parentCTM.f;
          storedCTMResult.x = x * parentScaleX - parentOffsetX;
          storedCTMResult.y = y * parentScaleY - parentOffsetY;
        } else {
          storedCTMResult.x = x;
          storedCTMResult.y = y;
        }
        return storedCTMResult;
      }
      function autocenter() {
        var w;
        var h2;
        var left = 0;
        var top = 0;
        var sceneBoundingBox = getBoundingBox();
        if (sceneBoundingBox) {
          left = sceneBoundingBox.left;
          top = sceneBoundingBox.top;
          w = sceneBoundingBox.right - sceneBoundingBox.left;
          h2 = sceneBoundingBox.bottom - sceneBoundingBox.top;
        } else {
          var ownerRect = owner.getBoundingClientRect();
          w = ownerRect.width;
          h2 = ownerRect.height;
        }
        var bbox = panController.getBBox();
        if (bbox.width === 0 || bbox.height === 0) {
          return;
        }
        var dh = h2 / bbox.height;
        var dw = w / bbox.width;
        var scale = Math.min(dw, dh);
        transform2.x = -(bbox.left + bbox.width / 2) * scale + w / 2 + left;
        transform2.y = -(bbox.top + bbox.height / 2) * scale + h2 / 2 + top;
        transform2.scale = scale;
      }
      function getTransformModel() {
        return transform2;
      }
      function getMinZoom() {
        return minZoom;
      }
      function setMinZoom(newMinZoom) {
        minZoom = newMinZoom;
      }
      function getMaxZoom() {
        return maxZoom;
      }
      function setMaxZoom(newMaxZoom) {
        maxZoom = newMaxZoom;
      }
      function getTransformOrigin() {
        return transformOrigin;
      }
      function setTransformOrigin(newTransformOrigin) {
        transformOrigin = parseTransformOrigin(newTransformOrigin);
      }
      function getZoomSpeed() {
        return speed;
      }
      function setZoomSpeed(newSpeed) {
        if (!Number.isFinite(newSpeed)) {
          throw new Error("Zoom speed should be a number");
        }
        speed = newSpeed;
      }
      function getPoint() {
        return {
          x: transform2.x,
          y: transform2.y
        };
      }
      function moveTo(x, y) {
        transform2.x = x;
        transform2.y = y;
        keepTransformInsideBounds();
        triggerEvent2("pan");
        makeDirty();
      }
      function moveBy(dx, dy) {
        moveTo(transform2.x + dx, transform2.y + dy);
      }
      function keepTransformInsideBounds() {
        var boundingBox = getBoundingBox();
        if (!boundingBox)
          return;
        var adjusted = false;
        var clientRect = getClientRect();
        var diff = boundingBox.left - clientRect.right;
        if (diff > 0) {
          transform2.x += diff;
          adjusted = true;
        }
        diff = boundingBox.right - clientRect.left;
        if (diff < 0) {
          transform2.x += diff;
          adjusted = true;
        }
        diff = boundingBox.top - clientRect.bottom;
        if (diff > 0) {
          transform2.y += diff;
          adjusted = true;
        }
        diff = boundingBox.bottom - clientRect.top;
        if (diff < 0) {
          transform2.y += diff;
          adjusted = true;
        }
        return adjusted;
      }
      function getBoundingBox() {
        if (!bounds)
          return;
        if (typeof bounds === "boolean") {
          var ownerRect = owner.getBoundingClientRect();
          var sceneWidth = ownerRect.width;
          var sceneHeight = ownerRect.height;
          return {
            left: sceneWidth * boundsPadding,
            top: sceneHeight * boundsPadding,
            right: sceneWidth * (1 - boundsPadding),
            bottom: sceneHeight * (1 - boundsPadding)
          };
        }
        return bounds;
      }
      function getClientRect() {
        var bbox = panController.getBBox();
        var leftTop = client(bbox.left, bbox.top);
        return {
          left: leftTop.x,
          top: leftTop.y,
          right: bbox.width * transform2.scale + leftTop.x,
          bottom: bbox.height * transform2.scale + leftTop.y
        };
      }
      function client(x, y) {
        return {
          x: x * transform2.scale + transform2.x,
          y: y * transform2.scale + transform2.y
        };
      }
      function makeDirty() {
        isDirty = true;
        frameAnimation = window.requestAnimationFrame(frame);
      }
      function zoomByRatio(clientX, clientY, ratio) {
        if (isNaN$1(clientX) || isNaN$1(clientY) || isNaN$1(ratio)) {
          throw new Error("zoom requires valid numbers");
        }
        var newScale = transform2.scale * ratio;
        if (newScale < minZoom) {
          if (transform2.scale === minZoom)
            return;
          ratio = minZoom / transform2.scale;
        }
        if (newScale > maxZoom) {
          if (transform2.scale === maxZoom)
            return;
          ratio = maxZoom / transform2.scale;
        }
        var size2 = transformToScreen(clientX, clientY);
        transform2.x = size2.x - ratio * (size2.x - transform2.x);
        transform2.y = size2.y - ratio * (size2.y - transform2.y);
        if (bounds && boundsPadding === 1 && minZoom === 1) {
          transform2.scale *= ratio;
          keepTransformInsideBounds();
        } else {
          var transformAdjusted = keepTransformInsideBounds();
          if (!transformAdjusted)
            transform2.scale *= ratio;
        }
        triggerEvent2("zoom");
        makeDirty();
      }
      function zoomAbs(clientX, clientY, zoomLevel) {
        var ratio = zoomLevel / transform2.scale;
        zoomByRatio(clientX, clientY, ratio);
      }
      function centerOn(ui) {
        var parent2 = ui.ownerSVGElement;
        if (!parent2)
          throw new Error("ui element is required to be within the scene");
        var clientRect = ui.getBoundingClientRect();
        var cx = clientRect.left + clientRect.width / 2;
        var cy = clientRect.top + clientRect.height / 2;
        var container = parent2.getBoundingClientRect();
        var dx = container.width / 2 - cx;
        var dy = container.height / 2 - cy;
        internalMoveBy(dx, dy, true);
      }
      function smoothMoveTo(x, y) {
        internalMoveBy(x - transform2.x, y - transform2.y, true);
      }
      function internalMoveBy(dx, dy, smooth) {
        if (!smooth) {
          return moveBy(dx, dy);
        }
        if (moveByAnimation)
          moveByAnimation.cancel();
        var from = { x: 0, y: 0 };
        var to = { x: dx, y: dy };
        var lastX = 0;
        var lastY = 0;
        moveByAnimation = animate(from, to, {
          step: function(v) {
            moveBy(v.x - lastX, v.y - lastY);
            lastX = v.x;
            lastY = v.y;
          }
        });
      }
      function scroll(x, y) {
        cancelZoomAnimation();
        moveTo(x, y);
      }
      function dispose() {
        releaseEvents();
      }
      function listenForEvents() {
        owner.addEventListener("mousedown", onMouseDown, { passive: false });
        owner.addEventListener("dblclick", onDoubleClick, { passive: false });
        owner.addEventListener("touchstart", onTouch, { passive: false });
        owner.addEventListener("keydown", onKeyDown, { passive: false });
        wheel.addWheelListener(owner, onMouseWheel, { passive: false });
        makeDirty();
      }
      function releaseEvents() {
        wheel.removeWheelListener(owner, onMouseWheel);
        owner.removeEventListener("mousedown", onMouseDown);
        owner.removeEventListener("keydown", onKeyDown);
        owner.removeEventListener("dblclick", onDoubleClick);
        owner.removeEventListener("touchstart", onTouch);
        if (frameAnimation) {
          window.cancelAnimationFrame(frameAnimation);
          frameAnimation = 0;
        }
        smoothScroll.cancel();
        releaseDocumentMouse();
        releaseTouches();
        textSelection.release();
        triggerPanEnd();
      }
      function frame() {
        if (isDirty)
          applyTransform();
      }
      function applyTransform() {
        isDirty = false;
        panController.applyTransform(transform2);
        triggerEvent2("transform");
        frameAnimation = 0;
      }
      function onKeyDown(e) {
        var x = 0, y = 0, z = 0;
        if (e.keyCode === 38) {
          y = 1;
        } else if (e.keyCode === 40) {
          y = -1;
        } else if (e.keyCode === 37) {
          x = 1;
        } else if (e.keyCode === 39) {
          x = -1;
        } else if (e.keyCode === 189 || e.keyCode === 109) {
          z = 1;
        } else if (e.keyCode === 187 || e.keyCode === 107) {
          z = -1;
        }
        if (filterKey(e, x, y, z)) {
          return;
        }
        if (x || y) {
          e.preventDefault();
          e.stopPropagation();
          var clientRect = owner.getBoundingClientRect();
          var offset2 = Math.min(clientRect.width, clientRect.height);
          var moveSpeedRatio = 0.05;
          var dx = offset2 * moveSpeedRatio * x;
          var dy = offset2 * moveSpeedRatio * y;
          internalMoveBy(dx, dy);
        }
        if (z) {
          var scaleMultiplier = getScaleMultiplier(z * 100);
          var offset2 = transformOrigin ? getTransformOriginOffset() : midPoint();
          publicZoomTo(offset2.x, offset2.y, scaleMultiplier);
        }
      }
      function midPoint() {
        var ownerRect = owner.getBoundingClientRect();
        return {
          x: ownerRect.width / 2,
          y: ownerRect.height / 2
        };
      }
      function onTouch(e) {
        beforeTouch(e);
        clearPendingClickEventTimeout();
        if (e.touches.length === 1) {
          return handleSingleFingerTouch(e, e.touches[0]);
        } else if (e.touches.length === 2) {
          pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);
          multiTouch = true;
          startTouchListenerIfNeeded();
        }
      }
      function beforeTouch(e) {
        if (options.onTouch && !options.onTouch(e)) {
          return;
        }
        e.stopPropagation();
        e.preventDefault();
      }
      function beforeDoubleClick(e) {
        clearPendingClickEventTimeout();
        if (options.onDoubleClick && !options.onDoubleClick(e)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
      }
      function handleSingleFingerTouch(e) {
        lastTouchStartTime = new Date();
        var touch = e.touches[0];
        var offset2 = getOffsetXY(touch);
        lastSingleFingerOffset = offset2;
        var point = transformToScreen(offset2.x, offset2.y);
        mouseX2 = point.x;
        mouseY2 = point.y;
        clickX = mouseX2;
        clickY = mouseY2;
        smoothScroll.cancel();
        startTouchListenerIfNeeded();
      }
      function startTouchListenerIfNeeded() {
        if (touchInProgress) {
          return;
        }
        touchInProgress = true;
        document.addEventListener("touchmove", handleTouchMove);
        document.addEventListener("touchend", handleTouchEnd);
        document.addEventListener("touchcancel", handleTouchEnd);
      }
      function handleTouchMove(e) {
        if (e.touches.length === 1) {
          e.stopPropagation();
          var touch = e.touches[0];
          var offset2 = getOffsetXY(touch);
          var point = transformToScreen(offset2.x, offset2.y);
          var dx = point.x - mouseX2;
          var dy = point.y - mouseY2;
          if (dx !== 0 && dy !== 0) {
            triggerPanStart();
          }
          mouseX2 = point.x;
          mouseY2 = point.y;
          internalMoveBy(dx, dy);
        } else if (e.touches.length === 2) {
          multiTouch = true;
          var t1 = e.touches[0];
          var t2 = e.touches[1];
          var currentPinchLength = getPinchZoomLength(t1, t2);
          var scaleMultiplier = 1 + (currentPinchLength / pinchZoomLength - 1) * pinchSpeed;
          var firstTouchPoint = getOffsetXY(t1);
          var secondTouchPoint = getOffsetXY(t2);
          mouseX2 = (firstTouchPoint.x + secondTouchPoint.x) / 2;
          mouseY2 = (firstTouchPoint.y + secondTouchPoint.y) / 2;
          if (transformOrigin) {
            var offset2 = getTransformOriginOffset();
            mouseX2 = offset2.x;
            mouseY2 = offset2.y;
          }
          publicZoomTo(mouseX2, mouseY2, scaleMultiplier);
          pinchZoomLength = currentPinchLength;
          e.stopPropagation();
          e.preventDefault();
        }
      }
      function clearPendingClickEventTimeout() {
        if (pendingClickEventTimeout) {
          clearTimeout(pendingClickEventTimeout);
          pendingClickEventTimeout = 0;
        }
      }
      function handlePotentialClickEvent(e) {
        if (!options.onClick)
          return;
        clearPendingClickEventTimeout();
        var dx = mouseX2 - clickX;
        var dy = mouseY2 - clickY;
        var l = Math.sqrt(dx * dx + dy * dy);
        if (l > 5)
          return;
        pendingClickEventTimeout = setTimeout(function() {
          pendingClickEventTimeout = 0;
          options.onClick(e);
        }, doubleTapSpeedInMS);
      }
      function handleTouchEnd(e) {
        clearPendingClickEventTimeout();
        if (e.touches.length > 0) {
          var offset2 = getOffsetXY(e.touches[0]);
          var point = transformToScreen(offset2.x, offset2.y);
          mouseX2 = point.x;
          mouseY2 = point.y;
        } else {
          var now2 = new Date();
          if (now2 - lastTouchEndTime < doubleTapSpeedInMS) {
            if (transformOrigin) {
              var offset2 = getTransformOriginOffset();
              smoothZoom(offset2.x, offset2.y, zoomDoubleClickSpeed);
            } else {
              smoothZoom(lastSingleFingerOffset.x, lastSingleFingerOffset.y, zoomDoubleClickSpeed);
            }
          } else if (now2 - lastTouchStartTime < clickEventTimeInMS) {
            handlePotentialClickEvent(e);
          }
          lastTouchEndTime = now2;
          triggerPanEnd();
          releaseTouches();
        }
      }
      function getPinchZoomLength(finger1, finger2) {
        var dx = finger1.clientX - finger2.clientX;
        var dy = finger1.clientY - finger2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      function onDoubleClick(e) {
        beforeDoubleClick(e);
        var offset2 = getOffsetXY(e);
        if (transformOrigin) {
          offset2 = getTransformOriginOffset();
        }
        smoothZoom(offset2.x, offset2.y, zoomDoubleClickSpeed);
      }
      function onMouseDown(e) {
        clearPendingClickEventTimeout();
        if (beforeMouseDown(e))
          return;
        lastMouseDownedEvent = e;
        lastMouseDownTime = new Date();
        if (touchInProgress) {
          e.stopPropagation();
          return false;
        }
        var isLeftButton = e.button === 1 && window.event !== null || e.button === 0;
        if (!isLeftButton)
          return;
        smoothScroll.cancel();
        var offset2 = getOffsetXY(e);
        var point = transformToScreen(offset2.x, offset2.y);
        clickX = mouseX2 = point.x;
        clickY = mouseY2 = point.y;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        textSelection.capture(e.target || e.srcElement);
        return false;
      }
      function onMouseMove(e) {
        if (touchInProgress)
          return;
        triggerPanStart();
        var offset2 = getOffsetXY(e);
        var point = transformToScreen(offset2.x, offset2.y);
        var dx = point.x - mouseX2;
        var dy = point.y - mouseY2;
        mouseX2 = point.x;
        mouseY2 = point.y;
        internalMoveBy(dx, dy);
      }
      function onMouseUp() {
        var now2 = new Date();
        if (now2 - lastMouseDownTime < clickEventTimeInMS)
          handlePotentialClickEvent(lastMouseDownedEvent);
        textSelection.release();
        triggerPanEnd();
        releaseDocumentMouse();
      }
      function releaseDocumentMouse() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        panstartFired = false;
      }
      function releaseTouches() {
        document.removeEventListener("touchmove", handleTouchMove);
        document.removeEventListener("touchend", handleTouchEnd);
        document.removeEventListener("touchcancel", handleTouchEnd);
        panstartFired = false;
        multiTouch = false;
        touchInProgress = false;
      }
      function onMouseWheel(e) {
        if (beforeWheel(e))
          return;
        smoothScroll.cancel();
        var delta = e.deltaY;
        if (e.deltaMode > 0)
          delta *= 100;
        var scaleMultiplier = getScaleMultiplier(delta);
        if (scaleMultiplier !== 1) {
          var offset2 = transformOrigin ? getTransformOriginOffset() : getOffsetXY(e);
          publicZoomTo(offset2.x, offset2.y, scaleMultiplier);
          e.preventDefault();
        }
      }
      function getOffsetXY(e) {
        var offsetX, offsetY;
        var ownerRect = owner.getBoundingClientRect();
        offsetX = e.clientX - ownerRect.left;
        offsetY = e.clientY - ownerRect.top;
        return { x: offsetX, y: offsetY };
      }
      function smoothZoom(clientX, clientY, scaleMultiplier) {
        var fromValue = transform2.scale;
        var from = { scale: fromValue };
        var to = { scale: scaleMultiplier * fromValue };
        smoothScroll.cancel();
        cancelZoomAnimation();
        zoomToAnimation = animate(from, to, {
          step: function(v) {
            zoomAbs(clientX, clientY, v.scale);
          },
          done: triggerZoomEnd
        });
      }
      function smoothZoomAbs(clientX, clientY, toScaleValue) {
        var fromValue = transform2.scale;
        var from = { scale: fromValue };
        var to = { scale: toScaleValue };
        smoothScroll.cancel();
        cancelZoomAnimation();
        zoomToAnimation = animate(from, to, {
          step: function(v) {
            zoomAbs(clientX, clientY, v.scale);
          }
        });
      }
      function getTransformOriginOffset() {
        var ownerRect = owner.getBoundingClientRect();
        return {
          x: ownerRect.width * transformOrigin.x,
          y: ownerRect.height * transformOrigin.y
        };
      }
      function publicZoomTo(clientX, clientY, scaleMultiplier) {
        smoothScroll.cancel();
        cancelZoomAnimation();
        return zoomByRatio(clientX, clientY, scaleMultiplier);
      }
      function cancelZoomAnimation() {
        if (zoomToAnimation) {
          zoomToAnimation.cancel();
          zoomToAnimation = null;
        }
      }
      function getScaleMultiplier(delta) {
        var sign = Math.sign(delta);
        var deltaAdjustedSpeed = Math.min(0.25, Math.abs(speed * delta / 128));
        return 1 - sign * deltaAdjustedSpeed;
      }
      function triggerPanStart() {
        if (!panstartFired) {
          triggerEvent2("panstart");
          panstartFired = true;
          smoothScroll.start();
        }
      }
      function triggerPanEnd() {
        if (panstartFired) {
          if (!multiTouch)
            smoothScroll.stop();
          triggerEvent2("panend");
        }
      }
      function triggerZoomEnd() {
        triggerEvent2("zoomend");
      }
      function triggerEvent2(name) {
        api.fire(name, api);
      }
    }
    function parseTransformOrigin(options) {
      if (!options)
        return;
      if (typeof options === "object") {
        if (!isNumber(options.x) || !isNumber(options.y))
          failTransformOrigin(options);
        return options;
      }
      failTransformOrigin();
    }
    function failTransformOrigin(options) {
      console.error(options);
      throw new Error([
        "Cannot parse transform origin.",
        "Some good examples:",
        '  "center center" can be achieved with {x: 0.5, y: 0.5}',
        '  "top center" can be achieved with {x: 0.5, y: 0}',
        '  "bottom right" can be achieved with {x: 1, y: 1}'
      ].join("\n"));
    }
    function noop() {
    }
    function validateBounds(bounds) {
      var boundsType = typeof bounds;
      if (boundsType === "undefined" || boundsType === "boolean")
        return;
      var validBounds = isNumber(bounds.left) && isNumber(bounds.top) && isNumber(bounds.bottom) && isNumber(bounds.right);
      if (!validBounds)
        throw new Error("Bounds object is not valid. It can be: undefined, boolean (true|false) or an object {left, top, right, bottom}");
    }
    function isNumber(x) {
      return Number.isFinite(x);
    }
    function isNaN$1(value) {
      if (Number.isNaN) {
        return Number.isNaN(value);
      }
      return value !== value;
    }
    function rigidScroll() {
      return {
        start: noop,
        stop: noop,
        cancel: noop
      };
    }
    function autoRun() {
      if (typeof document === "undefined")
        return;
      var scripts = document.getElementsByTagName("script");
      if (!scripts)
        return;
      var panzoomScript;
      for (var i2 = 0; i2 < scripts.length; ++i2) {
        var x = scripts[i2];
        if (x.src && x.src.match(/\bpanzoom(\.min)?\.js/)) {
          panzoomScript = x;
          break;
        }
      }
      if (!panzoomScript)
        return;
      var query = panzoomScript.getAttribute("query");
      if (!query)
        return;
      var globalName = panzoomScript.getAttribute("name") || "pz";
      var started = Date.now();
      tryAttach();
      function tryAttach() {
        var el = document.querySelector(query);
        if (!el) {
          var now2 = Date.now();
          var elapsed = now2 - started;
          if (elapsed < 2e3) {
            setTimeout(tryAttach, 100);
            return;
          }
          console.error("Cannot find the panzoom element", globalName);
          return;
        }
        var options = collectOptions(panzoomScript);
        console.log(options);
        window[globalName] = createPanZoom(el, options);
      }
      function collectOptions(script2) {
        var attrs = script2.attributes;
        var options = {};
        for (var j = 0; j < attrs.length; ++j) {
          var attr = attrs[j];
          var nameValue = getPanzoomAttributeNameValue(attr);
          if (nameValue) {
            options[nameValue.name] = nameValue.value;
          }
        }
        return options;
      }
      function getPanzoomAttributeNameValue(attr) {
        if (!attr.name)
          return;
        var isPanZoomAttribute = attr.name[0] === "p" && attr.name[1] === "z" && attr.name[2] === "-";
        if (!isPanZoomAttribute)
          return;
        var name = attr.name.substr(3);
        var value = JSON.parse(attr.value);
        return { name, value };
      }
    }
    autoRun();
    const _sfc_main$8 = /* @__PURE__ */ defineComponent({
      __name: "LibComponent",
      props: {
        parent: null,
        item: null,
        inModule: { type: Boolean }
      },
      setup(__props) {
        const pageStore = usePageStore();
        const { setActiveNode, insertNode, swapNode, addActiveParentChain } = pageStore;
        const { activeNode } = storeToRefs(pageStore);
        const dragStore = useDragStore();
        const { dragNode, dragType, dropZone, dragNodeType, isCancelDrag } = storeToRefs(dragStore);
        const { setDropZone, setDragNode, getIsInDragNode } = dragStore;
        const displayStore = useDisplayStore();
        const { displayMode, lockDrag } = storeToRefs(displayStore);
        const componentRef = ref(null);
        const $el = computed(() => {
          var _a;
          return (_a = componentRef == null ? void 0 : componentRef.value) == null ? void 0 : _a.$el;
        });
        const isActive = computed(() => activeNode.value === __props.item);
        const isHide = computed(() => {
          var _a, _b;
          return (_b = (_a = useConfigProps(__props.item)) == null ? void 0 : _a.common) == null ? void 0 : _b.hide;
        });
        const setActive = () => {
          if (!$el.value || !$el.value.parentElement)
            return;
          setActiveNode(__props.item, __props.parent);
          emitter.emit("switchMaterialsPanel", false);
        };
        const openMoveable = () => {
          if (isActive.value && !isHide.value) {
            if (["preview", "drag"].includes(displayMode.value)) {
              disabledMoveable();
              return;
            }
            const moveable2 = getMoveable();
            if (!moveable2 || !$el.value)
              return;
            useMoveable($el.value, __props.item, __props.parent);
            setTimeout(() => emitter.emit("updateMoveable"), 300);
          }
        };
        watch(() => [isActive.value, displayMode.value, isHide.value], () => openMoveable(), { flush: "post" });
        watch(() => [isActive.value, isHide.value], () => (!isActive.value || isHide.value) && disabledMoveable(), { flush: "pre" });
        watch(() => isActive.value, () => {
          var _a;
          return isActive.value && ((_a = $el.value) == null ? void 0 : _a.parentElement.dispatchEvent(new Event("active-node", { bubbles: true })));
        }, { flush: "post" });
        onMounted(() => openMoveable());
        onBeforeUnmount(() => isActive.value && disabledMoveable());
        let inDraggable = computed(() => dropZone.value === __props.item);
        const handleAddNode = (event) => {
          if (!dragNode.value || isCancelDrag.value)
            return;
          if (event.pullMode === "clone" && event.newIndex !== void 0) {
            insertNode(dragNode.value, __props.item, event.newIndex);
            setDragNode(null);
          }
        };
        const handleSortNode = (event) => {
          if (event.pullMode !== "clone" && event.oldIndex !== void 0 && event.newIndex !== void 0) {
            swapNode(__props.item, event.oldIndex, event.newIndex);
            setDragNode(null);
          }
        };
        const isBlockComponent = computed(() => __props.item.component === "Block");
        const scrollList = /* @__PURE__ */ new Set();
        const componentEvents = computed(() => isBlockComponent.value ? {
          onDragenter: (e) => {
            var _a, _b;
            if (dragNode.value && !__props.item.isModule && !inDraggable.value && !getIsInDragNode(__props.item.name) && ((_b = (_a = e.target) == null ? void 0 : _a.dataset) == null ? void 0 : _b.name) === __props.item.name) {
              setDropZone(__props.item);
            }
          },
          onAdd: handleAddNode,
          onEnd: handleSortNode,
          onScroll: (e) => {
            const elem = e.target;
            scrollList.add(elem);
          },
          onActiveNode: () => {
            addActiveParentChain(__props.item);
          }
        } : {});
        const handleChildrenDragStart = (event, node) => {
          if (dragNode.value || __props.item.isModule) {
            return;
          }
          setDragNode(node, "move");
        };
        watch([displayMode, activeNode], () => {
          if (scrollList.size > 0) {
            scrollList.forEach((el) => {
              el.scrollLeft = 0;
              el.scrollTop = 0;
            });
            scrollList.clear();
          }
        }, { flush: "pre" });
        const preventChildrenMousedown = (e, subItem) => {
          var _a;
          if (displayMode.value === "drag" || !lockDrag.value && ["absolute", "fixed"].includes(((_a = useConfigProps(subItem).position) == null ? void 0 : _a.position) || "")) {
            e.stopPropagation();
          }
        };
        return (_ctx, _cache) => {
          var _a;
          const _component_LibComponent = resolveComponent("LibComponent", true);
          const _directive_tap = resolveDirective("tap");
          return withDirectives((openBlock(), createBlock(unref$1(draggable), {
            ref_key: "componentRef",
            ref: componentRef,
            "model-value": __props.item.children || [],
            group: {
              name: "component",
              put: isBlockComponent.value ? !__props.item.isModule : false,
              pull: __props.item.isModule ? false : true
            },
            "item-key": "name",
            tag: __props.item.component,
            "component-data": {
              ...unref$1(useConfigProps)(__props.item),
              tags: __props.item.tags,
              componentName: __props.item.name,
              direction: __props.parent ? (_a = unref$1(useConfigProps)(__props.parent).layout) == null ? void 0 : _a.direction : void 0,
              inheritAttrs: {
                class: [
                  "lib-component",
                  {
                    active: isActive.value,
                    grading: inDraggable.value,
                    module: !!__props.item.isModule,
                    inModule: __props.inModule
                  }
                ],
                "data-name": __props.item.name,
                ...componentEvents.value,
                ..._ctx.$attrs
              }
            },
            disabled: unref$1(displayMode) !== "drag" || unref$1(dragNode) && unref$1(dragNodeType) !== "component",
            sort: true,
            "ghost-class": unref$1(dragNode) && unref$1(dragType) === "clone" ? "ghost-clone" : "ghost-move",
            "chosen-class": "chosen-clone"
          }, {
            item: withCtx(({ element: subItem }) => [
              (openBlock(), createBlock(_component_LibComponent, {
                item: subItem,
                parent: __props.item,
                "in-module": __props.item.isModule || __props.inModule,
                key: subItem.name,
                onMousedown: (e) => preventChildrenMousedown(e, subItem),
                onDragstart: (event) => handleChildrenDragStart(event, subItem)
              }, null, 8, ["item", "parent", "in-module", "onMousedown", "onDragstart"]))
            ]),
            _: 1
          }, 8, ["model-value", "group", "tag", "component-data", "disabled", "ghost-class"])), [
            [
              _directive_tap,
              setActive,
              void 0,
              { stop: true }
            ]
          ]);
        };
      }
    });
    const LibComponent_vue_vue_type_style_index_0_scoped_34788490_lang = "";
    const LibComponent = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-34788490"]]);
    const _hoisted_1$7 = {
      key: 1,
      class: "node-operation"
    };
    const _sfc_main$7 = /* @__PURE__ */ defineComponent({
      __name: "EditSection",
      setup(__props) {
        const pageStore = usePageStore();
        const {
          setActiveNode,
          addSection,
          setActiveParentNodeToActive,
          setActiveNodeChildrenToActive,
          setActiveNodeToRound,
          getActiveNodeRound,
          deleteActiveNode
        } = pageStore;
        const { pageData, activeNode, activeParentNode } = storeToRefs(pageStore);
        const displayStore = useDisplayStore();
        const { setDeviceByParent } = displayStore;
        const { device, displayMode, curFootSize } = storeToRefs(displayStore);
        const dragStore = useDragStore();
        const { dragNode, dragType, dragNodeType, isCancelDrag } = storeToRefs(dragStore);
        const { setIsCancelDrag } = dragStore;
        const wrapperRef = ref(null);
        const contentRef = ref(null);
        const contentElem = computed(() => {
          var _a;
          return ((_a = contentRef.value) == null ? void 0 : _a.$el) || null;
        });
        const editContentStyle = computed(() => ({
          width: `${device.value.width}px`,
          fontSize: `${curFootSize}px`
        }));
        const noPageData = computed(() => pageData.value.length === 0);
        const pz = ref(null);
        let isSmoothing = ref(false);
        const wrapperSize = useSize(wrapperRef);
        const setWrapperSize = () => {
          var _a, _b;
          wrapperSize.width = ((_a = wrapperRef.value) == null ? void 0 : _a.clientWidth) || 0;
          wrapperSize.height = ((_b = wrapperRef.value) == null ? void 0 : _b.clientHeight) || 0;
        };
        onMounted(() => {
          setWrapperSize();
          window.addEventListener("resize", setWrapperSize, false);
          setDeviceByParent(wrapperSize.width, wrapperSize.height);
          pz.value = panzoom(contentElem.value, {
            initialZoom: device.value.zoom,
            minZoom: 0.2,
            maxZoom: 2,
            zoomSpeed: 0.2,
            zoomDoubleClickSpeed: 1,
            pinchSpeed: 40,
            smoothScroll: false,
            filterKey: () => true,
            beforeWheel: function(e) {
              var shouldIgnore = !e.ctrlKey && !e.metaKey;
              return shouldIgnore;
            }
          });
          pz.value.on("zoom", (e) => {
            device.value.zoom = e.getTransform().scale;
            setTimeout(() => emitter.emit("updateMoveable"));
          });
          pz.value.on("pan", () => emitter.emit("updateMoveable"));
        });
        onUnmounted(() => window.removeEventListener("resize", setWrapperSize));
        watchEffect(() => {
          var _a, _b, _c;
          const trans = (_a = pz.value) == null ? void 0 : _a.getTransform();
          const rect = (_b = contentElem.value) == null ? void 0 : _b.getBoundingClientRect();
          if (trans && rect && (trans == null ? void 0 : trans.scale) !== device.value.zoom) {
            (_c = pz.value) == null ? void 0 : _c.zoomTo(trans.x + rect.width / 2, trans.y + rect.height / 2, device.value.zoom / trans.scale);
          }
        });
        watch([pageData], () => emitter.emit("updateMoveable"), { flush: "post", deep: true });
        watch(() => noPageData.value, (newValue, oldValue) => {
          if (!newValue && oldValue) {
            setTimeout(() => handleLocationPage(true));
          }
        }, { flush: "post" });
        const handleLocationPage = (immediate = false) => {
          var _a;
          if (!contentElem.value || isSmoothing.value)
            return;
          if (immediate !== true) {
            isSmoothing.value = true;
            setTimeout(() => isSmoothing.value = false, 300);
          }
          let x, y, left = 0, top = 0;
          const activeElem = activeNode && document.querySelector(".lib-component.active");
          const { width, height } = wrapperSize;
          const rect = contentElem.value.getBoundingClientRect();
          const w = rect.width;
          const h2 = rect.height;
          x = (width - w) / 2;
          y = h2 < height ? (height - h2) / 2 : 0;
          immediate === true ? pz.value.moveTo(x, y) : pz.value.smoothMoveTo(x, y);
          if (activeElem) {
            const activeRect = activeElem.getBoundingClientRect();
            left = activeRect.left - rect.left - (wrapperSize.width - activeRect.width) / 2 + Math.min(x, 0);
            top = activeRect.top - rect.top - (wrapperSize.height - activeRect.height) / 2 + Math.min(y, 0);
          }
          (_a = wrapperRef.value) == null ? void 0 : _a.scrollTo({
            top: Math.max(top, 0),
            left: Math.max(left, 0),
            behavior: "smooth"
          });
        };
        emitter.on("location", (immediate) => handleLocationPage(immediate));
        const hideMaterialsPanel = (e) => {
          const target = e.target;
          if (target == null ? void 0 : target.classList.contains("edit-wrapper")) {
            setActiveNode();
          }
          emitter.emit("switchMaterialsPanel", false);
        };
        useKeyPress(ShortcutKey.location, (e) => {
          e.preventDefault();
          handleLocationPage();
        });
        useKeyPress(ShortcutKey.delete, (e) => {
          e.preventDefault();
          deleteActiveNode();
        });
        useKeyPress(ShortcutKey.nextComponent, (e) => {
          e.preventDefault();
          setActiveNodeToRound(1);
        });
        useKeyPress(ShortcutKey.prevComponent, (e) => {
          e.preventDefault();
          setActiveNodeToRound(-1);
        });
        useKeyPress(ShortcutKey.parentComponent, (e) => {
          e.preventDefault();
          setActiveParentNodeToActive();
        });
        useKeyPress(ShortcutKey.childrenComponent, (e) => {
          e.preventDefault();
          setActiveNodeChildrenToActive();
        });
        const dragEvents = computed(() => dragNode && dragNodeType.value === "section" ? {
          add: (event) => {
            if (!dragNode.value || isCancelDrag.value)
              return;
            addSection(dragNode.value, event.newIndex);
          }
        } : {});
        const handleEnterTrash = () => setIsCancelDrag(true);
        const handleLeaveTrash = (e) => {
          if (!e.clientX && !e.clientY)
            return;
          setIsCancelDrag(false);
        };
        return (_ctx, _cache) => {
          var _a;
          const _directive_tap = resolveDirective("tap");
          return withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass(["edit-section", `edit-section-${unref$1(displayMode)}`])
          }, [
            createBaseVNode("div", {
              ref_key: "wrapperRef",
              ref: wrapperRef,
              class: "edit-wrapper"
            }, [
              createVNode(unref$1(draggable), mergeProps({
                ref_key: "contentRef",
                ref: contentRef,
                "model-value": unref$1(pageData) || [],
                "item-key": "name",
                group: { name: "section", put: true, pull: false },
                disabled: unref$1(displayMode) !== "drag" || unref$1(dragNode) && unref$1(dragNodeType) !== "section",
                class: ["edit-content", { placeholder: noPageData.value }],
                "component-data": {
                  "data-placeholder": _ctx.$t("noDataPlaceholder")
                },
                "ghost-class": unref$1(dragNode) && unref$1(dragType) === "clone" ? "ghost-clone-section" : "ghost-move",
                style: editContentStyle.value
              }, toHandlers(dragEvents.value)), {
                item: withCtx(({ element: item }) => [
                  (openBlock(), createBlock(LibComponent, {
                    item,
                    key: item.name,
                    "in-module": item.isModule
                  }, null, 8, ["item", "in-module"]))
                ]),
                _: 1
              }, 16, ["model-value", "disabled", "class", "component-data", "ghost-class", "style"])
            ], 512),
            createVNode(Icon$1, {
              class: normalizeClass(["focus-btn"]),
              name: "focus",
              size: 26,
              onClick: _cache[0] || (_cache[0] = () => handleLocationPage())
            }),
            unref$1(dragNode) && !noPageData.value && unref$1(dragType) === "clone" ? (openBlock(), createBlock(Icon$1, {
              key: 0,
              class: normalizeClass(["cancel-clone-btn", { active: unref$1(isCancelDrag) }]),
              name: "delete",
              size: 24,
              onDragover: handleEnterTrash,
              onDragleave: handleLeaveTrash
            }, null, 8, ["class"])) : createCommentVNode("", true),
            unref$1(activeNode) ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
              createVNode(Btn, {
                class: "prev-btn",
                text: _ctx.$t("prevNode"),
                type: "text",
                color: "default",
                size: "sm",
                icon: "top-circle",
                disabled: !unref$1(getActiveNodeRound)(-1),
                onClick: _cache[1] || (_cache[1] = ($event) => unref$1(setActiveNodeToRound)(-1))
              }, null, 8, ["text", "disabled"]),
              createVNode(Btn, {
                class: "next-btn",
                text: _ctx.$t("nextNode"),
                type: "text",
                color: "default",
                size: "sm",
                icon: "top-circle",
                disabled: !unref$1(getActiveNodeRound)(1),
                onClick: _cache[2] || (_cache[2] = ($event) => unref$1(setActiveNodeToRound)(1))
              }, null, 8, ["text", "disabled"]),
              createVNode(Btn, {
                text: _ctx.$t("parentNode"),
                type: "text",
                color: "default",
                size: "sm",
                icon: "top-circle",
                disabled: unref$1(activeParentNode) === null,
                onClick: unref$1(setActiveParentNodeToActive)
              }, null, 8, ["text", "disabled", "onClick"]),
              createVNode(Btn, {
                class: "children-btn",
                text: _ctx.$t("childrenNode"),
                type: "text",
                color: "default",
                size: "sm",
                icon: "top-circle",
                disabled: !((_a = unref$1(activeNode).children) == null ? void 0 : _a.length),
                onClick: unref$1(setActiveNodeChildrenToActive)
              }, null, 8, ["text", "disabled", "onClick"])
            ])) : createCommentVNode("", true)
          ], 2)), [
            [_directive_tap, hideMaterialsPanel]
          ]);
        };
      }
    });
    const EditSection_vue_vue_type_style_index_0_scoped_60639afe_lang = "";
    const EditSection = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-60639afe"]]);
    let dynamicAnimationStyles = null;
    const useFont = (font, wrapper = "html") => {
      if (!dynamicAnimationStyles) {
        dynamicAnimationStyles = document.createElement("style");
        document.head.appendChild(dynamicAnimationStyles);
      }
      const stylesheet = getFontStylesheet(font, wrapper);
      dynamicAnimationStyles.innerHTML = stylesheet;
    };
    const _hoisted_1$6 = {
      key: 0,
      class: "info-wrapper"
    };
    const _hoisted_2$5 = { class: "btn-wrapper" };
    const _hoisted_3$4 = { class: "btn-wrapper-left" };
    const __default__ = {
      inheritAttrs: true
    };
    const _sfc_main$6 = /* @__PURE__ */ defineComponent({
      ...__default__,
      __name: "ProjectModal",
      props: {
        project: null,
        hideCreateCover: { type: Boolean }
      },
      emits: ["save"],
      setup(__props, { emit }) {
        const propsRef = reactive(useAttrs());
        let editProject = ref({
          name: "",
          cover: ""
        });
        let modal = ref(null);
        watch(() => [__props.project, propsRef.modelValue], () => {
          if (propsRef.modelValue && editProject.value) {
            editProject.value.name = __props.project.name;
            editProject.value.cover = __props.project.cover;
          }
        });
        const handleSave = () => {
          var _a;
          if (!((_a = editProject.value) == null ? void 0 : _a.name)) {
            AlertError($t("projectNameRequired"));
            return;
          }
          emit("save", editProject.value);
        };
        let coverLoading = ref(false);
        const handleCreateCover = async () => {
          if (!editProject.value)
            return;
          try {
            coverLoading.value = true;
            const elem = document.querySelector(`.edit-content`);
            const cover = elem ? await createMaterialSnapshot(elem) : "";
            if (cover.length >= 1e4) {
              const url = await uploadByBase64(cover);
              editProject.value.cover = url;
            } else {
              editProject.value.cover = cover;
            }
          } finally {
            coverLoading.value = false;
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Modal$1, mergeProps({
            ref_key: "modal",
            ref: modal,
            class: "project-modal",
            title: unref$1($t)("projectSetting"),
            width: "360px",
            "close-on-click-mask": ""
          }, _ctx.$attrs), {
            default: withCtx(() => [
              editProject.value ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
                createVNode(InputItem, {
                  label: unref$1($t)("name"),
                  modelValue: editProject.value.name,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => editProject.value.name = $event)
                }, null, 8, ["label", "modelValue"]),
                createVNode(ImageItem, {
                  label: unref$1($t)("cover"),
                  loading: coverLoading.value,
                  modelValue: editProject.value.cover,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => editProject.value.cover = $event),
                  rows: 5
                }, null, 8, ["label", "loading", "modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_2$5, [
                createBaseVNode("div", _hoisted_3$4, [
                  !__props.hideCreateCover ? (openBlock(), createBlock(Btn, {
                    key: 0,
                    class: "create-cover-btn",
                    type: "text",
                    size: "sm",
                    onClick: handleCreateCover
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref$1($t)("autoCreateCover")), 1)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                createVNode(Btn, {
                  class: "save-btn",
                  type: "inner",
                  text: unref$1($t)("save"),
                  onClick: handleSave
                }, null, 8, ["text"])
              ])
            ]),
            _: 1
          }, 16, ["title"]);
        };
      }
    });
    const ProjectModal_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$5 = { class: "page" };
    const _hoisted_2$4 = { class: "container" };
    const _hoisted_3$3 = { class: "content" };
    const _sfc_main$5 = /* @__PURE__ */ defineComponent({
      __name: "Configure",
      setup(__props) {
        const route = useRoute();
        const router2 = useRouter();
        const id = computed(() => {
          var _a;
          return ((_a = route.params) == null ? void 0 : _a.id) || "";
        });
        const userStore = useUserStore();
        const { isAdmin } = storeToRefs(userStore);
        const pageStore = usePageStore();
        const { activeNode, setting, activeSection, allPageData, colorVars, font, project } = storeToRefs(pageStore);
        const {
          setActiveSection,
          setActiveNode,
          updateAllPageNode,
          getAssetsData,
          getProjectData,
          download,
          saveProjectData,
          loadTemplateData,
          pasteClipboardNode,
          copyActiveNodeToClipboard
        } = pageStore;
        const displayStore = useDisplayStore();
        const { setDeviceByParent, setDevice } = displayStore;
        const { deviceType, displayMode, lockScriptTrigger } = storeToRefs(displayStore);
        const historyStore = useHistoryStore();
        const { canUndoHistory, canRedoHistory, isSave } = storeToRefs(historyStore);
        const { saveHistory, undoHistory, redoHistory, setIsSave } = historyStore;
        let showProjectModal = ref(false);
        let showKeyboard = ref(false);
        const setGlobalLoading = getSetLoading();
        const handleDownload = async () => {
          let hide;
          const timer = setTimeout(() => hide = setGlobalLoading($t("downloadLoading")), 300);
          try {
            const res = await download();
            downloadHtml(res.data);
          } finally {
            clearTimeout(timer);
            hide == null ? void 0 : hide();
          }
        };
        const handleSaveProject = async (editProject) => {
          const saveProject = editProject || project.value;
          if (allPageData.value.length === 0) {
            return;
          }
          if (!saveProject.name) {
            showProjectModal.value = true;
            return;
          }
          const data2 = await saveProjectData(id.value, saveProject);
          showProjectModal.value = false;
          Alert($t("saveSuccess"));
          if (!id.value) {
            router2.replace({
              name: "edit",
              params: {
                id: data2.id
              }
            });
          }
          setIsSave(true);
        };
        emitter.on("saveProject", handleSaveProject);
        let showLeftPanel = ref(false);
        onMounted(async () => {
          emitter.on("switchMaterialsPanel", (show) => {
            showLeftPanel.value = show === void 0 ? !showLeftPanel.value : show;
          });
          let inAction = false;
          pageStore.$onAction(({ name, store, args, after, onError }) => {
            if (!inAction && [
              "getProjectData",
              "insertNode",
              "swapNode",
              "addSection",
              "removeSection",
              "swapSection",
              "deleteActiveNode",
              "copyNode",
              "separateActiveNode",
              "setActiveNodeHide",
              "switchActiveNodeConfigMode",
              "unlinkActiveNodeProp",
              "unlinkActiveNodePropGroup",
              "loadTemplateData",
              "syncNodeModuleConfig",
              "changeNodeName"
            ].includes(name)) {
              inAction = true;
              after(() => {
                inAction = false;
                saveHistory(store.allPageData, name === "getProjectData");
              });
            }
          });
          emitter.on("saveHistory", () => {
            saveHistory(allPageData.value);
          });
          window.addEventListener("beforeunload", preventUnload);
          getAssetsData();
          const hide = setGlobalLoading == null ? void 0 : setGlobalLoading($t("loading"));
          if (id.value) {
            try {
              await getProjectData(id.value);
            } catch (e) {
              router2.replace({ name: "create" });
            } finally {
              hide == null ? void 0 : hide();
            }
            if (haveStoragePageState(id.value)) {
              if (await Modal.confirm($t("notSaveDataTip"))) {
                pageStore.$state = getStoragePageState(id.value, pageStore.$state);
                setIsSave(false);
              }
              clearStoragePageState();
            }
            nextTick$1(() => emitter.emit("location", true));
          } else {
            if (route.query.templateId && typeof route.query.templateId === "string") {
              await loadTemplateData(route.query.templateId);
              router2.replace({ name: "create" });
            }
            hide == null ? void 0 : hide();
            setTimeout(() => emitter.emit("location", true));
          }
          if (setting.value.client === "mobile") {
            deviceType.value = "mobile";
            setDevice(0);
          }
        });
        onBeforeUnmount(() => {
          window.removeEventListener("beforeunload", preventUnload);
          destroyMoveable();
        });
        const preventUnload = (event) => {
          if (!isSave.value) {
            event.preventDefault();
            event.returnValue = "";
            saveStoragePageState(id.value);
          }
        };
        useKeyPress(ShortcutKey.undo, (e) => {
          if (e.shiftKey)
            return;
          if (!canUndoHistory.value)
            return;
          e.preventDefault();
          updateAllPageNode(undoHistory());
        });
        useKeyPress(ShortcutKey.redo, (e) => {
          if (!canRedoHistory.value)
            return;
          e.preventDefault();
          updateAllPageNode(redoHistory());
        });
        useKeyPress(ShortcutKey.collapseAll, (e) => {
          e.preventDefault();
          emitter.emit("collapseGroup");
        });
        useKeyPress(ShortcutKey.switchSection, (e) => {
          e.preventDefault();
          if (e.key === "0") {
            switchSectionToIndex.value(-1);
          } else if (+e.key > 0) {
            switchSectionToIndex.value(+e.key - 1);
          }
        });
        useKeyPress(ShortcutKey.nextSection, (e) => {
          if (e.shiftKey)
            return;
          e.preventDefault();
          switchSectionByRound.value(1);
        });
        useKeyPress(ShortcutKey.prevSection, (e) => {
          e.preventDefault();
          switchSectionByRound.value(-1);
        });
        useKeyPress(ShortcutKey.switchShortcut, (e) => {
          e.preventDefault();
          showKeyboard.value = !showKeyboard.value;
        });
        useKeyPress(ShortcutKey.cut, async (e) => {
          e.preventDefault();
          if (!activeNode.value)
            return;
          await copyActiveNodeToClipboard(true);
          Alert($t("cutSuccess"));
        });
        useKeyPress(ShortcutKey.copyToClipboard, async (e) => {
          var _a;
          e.preventDefault();
          const selectText = (_a = document.getSelection()) == null ? void 0 : _a.toString();
          if (!activeNode.value || selectText)
            return;
          await copyActiveNodeToClipboard();
          Alert($t("copySuccess"));
        });
        useKeyPress(ShortcutKey.pasteToInside, async (e) => {
          e.preventDefault();
          handlePasteNode(true);
        });
        useKeyPress(ShortcutKey.paste, async (e) => {
          if (e.shiftKey)
            return;
          e.preventDefault();
          handlePasteNode(false);
        });
        const handlePasteNode = async (pasteToInside) => {
          if (!activeNode.value)
            return;
          if (await pasteClipboardNode(pasteToInside)) {
            Alert($t("pasteSuccess"));
          }
        };
        const switchSectionByRound = computed(() => (change) => {
          const index2 = allPageData.value.findIndex((item) => item === activeSection.value);
          switchSectionToIndex.value(index2 + change);
        });
        const switchSectionToIndex = computed(() => (index2) => {
          if (index2 === -1) {
            setActiveSection(null);
          } else if (allPageData.value[index2]) {
            setActiveSection(allPageData.value[index2]);
            setActiveNode(allPageData.value[index2]);
          }
          nextTick$1(() => emitter.emit("location"));
        });
        let context = reactive({ isEditMode: true, displayMode: displayMode.value, lockScriptTrigger: lockScriptTrigger.value });
        provide("editContext", context);
        watch(() => [displayMode.value, lockScriptTrigger.value], () => {
          context.displayMode = displayMode.value;
          context.lockScriptTrigger = lockScriptTrigger.value;
        }, { immediate: true, flush: "sync" });
        watch(() => colorVars.value, () => useColorVars(colorVars.value), { deep: true, immediate: true, flush: "sync" });
        watch(() => font.value, () => useFont(font.value, ".edit-content"), { deep: true, immediate: true, flush: "sync" });
        watch(() => isAdmin.value, (val) => val && getJSONEditor(), { immediate: true });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$5, [
            createVNode(Sidebar, {
              "active-materials-panel": showLeftPanel.value,
              keyboard: showKeyboard.value,
              "onUpdate:keyboard": _cache[0] || (_cache[0] = ($event) => showKeyboard.value = $event),
              onChangeMaterialsPanel: _cache[1] || (_cache[1] = (val) => showLeftPanel.value = val)
            }, null, 8, ["active-materials-panel", "keyboard"]),
            createBaseVNode("div", _hoisted_2$4, [
              createVNode(ConfigHeader, {
                onDownload: handleDownload,
                onSave: handleSaveProject,
                onProjectSetting: _cache[2] || (_cache[2] = ($event) => showProjectModal.value = true)
              }),
              createBaseVNode("div", _hoisted_3$3, [
                createBaseVNode("div", {
                  class: normalizeClass(["left-panel", { show: showLeftPanel.value }])
                }, [
                  createVNode(MaterialsPanel)
                ], 2),
                createVNode(EditSection),
                createVNode(ConfigSection),
                createVNode(Keyboard, { show: showKeyboard.value }, null, 8, ["show"])
              ])
            ]),
            unref$1(project) ? (openBlock(), createBlock(_sfc_main$6, {
              key: 0,
              modelValue: showProjectModal.value,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => showProjectModal.value = $event),
              project: unref$1(project),
              onSave: handleSaveProject
            }, null, 8, ["modelValue", "project"])) : createCommentVNode("", true)
          ]);
        };
      }
    });
    const Configure_vue_vue_type_style_index_0_scoped_7343bd2b_lang = "";
    const Configure_vue_vue_type_style_index_1_lang = "";
    const Configure = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-7343bd2b"]]);
    const _hoisted_1$4 = { key: 0 };
    const _sfc_main$4 = /* @__PURE__ */ defineComponent({
      __name: "Redirect",
      setup(__props) {
        const { isLoading } = $a52d863b14a9eb8e$export$84e88c4b3c082374(() => {
          const href = sessionStorage.getItem("redirect");
          location.href = href || "/";
        });
        return (_ctx, _cache) => {
          return unref$1(isLoading) ? (openBlock(), createElementBlock("p", _hoisted_1$4, toDisplayString(_ctx.$t("redirectLoading")), 1)) : createCommentVNode("", true);
        };
      }
    });
    const _withScopeId = (n) => (pushScopeId("data-v-a065fc05"), n = n(), popScopeId(), n);
    const _hoisted_1$3 = {
      key: 0,
      class: "material-card-image-placeholder"
    };
    const _hoisted_2$3 = { class: "material-card-info" };
    const _hoisted_3$2 = { class: "material-card-info-name" };
    const _hoisted_4$1 = { class: "material-card-image-placeholder" };
    const _hoisted_5$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "material-card-info" }, null, -1));
    const _sfc_main$3 = /* @__PURE__ */ defineComponent({
      __name: "MaterialCard",
      props: {
        type: null,
        item: null,
        isNew: { type: Boolean },
        newText: { default: () => $t("newProject") },
        selected: { type: Boolean },
        hideOperate: { type: Boolean }
      },
      setup(__props) {
        useRouter();
        return (_ctx, _cache) => {
          const _directive_tooltip = resolveDirective("tooltip");
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["material-card", { [__props.type]: __props.type, selected: __props.selected }])
          }, [
            __props.item ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", {
                class: "material-card-image",
                style: normalizeStyle({ backgroundImage: __props.item.cover ? `url(${__props.item.cover})` : void 0 }),
                onClick: _cache[0] || (_cache[0] = ($event) => __props.type === "project" ? _ctx.$emit("on-project-click", __props.item) : _ctx.$emit("on-material-click", __props.item))
              }, [
                !__props.item.cover ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
                  createVNode(Icon$1, {
                    name: "empty",
                    size: 32
                  }),
                  createBaseVNode("span", null, toDisplayString(unref$1($t)("notCover")), 1)
                ])) : createCommentVNode("", true),
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ], 4),
              createBaseVNode("div", _hoisted_2$3, [
                createBaseVNode("div", _hoisted_3$2, toDisplayString(__props.item.name), 1),
                __props.type === "project" && !__props.hideOperate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  withDirectives(createVNode(Icon$1, {
                    type: "circle",
                    class: "material-card-info-btn",
                    name: "save",
                    size: 9,
                    onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("on-save-template", __props.item))
                  }, null, 512), [
                    [_directive_tooltip, { content: unref$1($t)("saveToTemplate"), placement: "top", distance: 10 }]
                  ]),
                  withDirectives(createVNode(Icon$1, {
                    type: "circle",
                    class: "material-card-info-btn",
                    name: "advanced",
                    size: 11,
                    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("on-setting-project", __props.item))
                  }, null, 512), [
                    [_directive_tooltip, { content: unref$1($t)("setting"), placement: "top", distance: 10 }]
                  ]),
                  withDirectives(createVNode(Icon$1, {
                    type: "circle",
                    class: "material-card-info-btn danger",
                    name: "delete",
                    size: 10,
                    onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("on-delete-project", __props.item))
                  }, null, 512), [
                    [_directive_tooltip, { content: unref$1($t)("delete"), placement: "top", distance: 10 }]
                  ])
                ], 64)) : !__props.hideOperate ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  withDirectives(createVNode(Icon$1, {
                    type: "circle",
                    class: "material-card-info-btn",
                    name: "advanced",
                    size: 11,
                    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("on-setting-material", __props.item))
                  }, null, 512), [
                    [_directive_tooltip, { content: unref$1($t)("setting"), placement: "top", distance: 10 }]
                  ]),
                  withDirectives(createVNode(Icon$1, {
                    type: "circle",
                    class: "material-card-info-btn danger",
                    name: "delete",
                    size: 10,
                    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("on-delete-material", __props.item))
                  }, null, 512), [
                    [_directive_tooltip, { content: unref$1($t)("delete"), placement: "top", distance: 10 }]
                  ])
                ], 64)) : createCommentVNode("", true)
              ])
            ], 64)) : createCommentVNode("", true),
            !__props.item && __props.isNew ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", {
                class: "material-card-image create",
                onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("on-project-click"))
              }, [
                createBaseVNode("div", _hoisted_4$1, [
                  createVNode(Icon$1, {
                    name: "add",
                    size: 24
                  }),
                  createBaseVNode("span", null, toDisplayString(__props.newText), 1)
                ])
              ]),
              _hoisted_5$1
            ], 64)) : createCommentVNode("", true)
          ], 2);
        };
      }
    });
    const MaterialCard_vue_vue_type_style_index_0_scoped_a065fc05_lang = "";
    const MaterialCard = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-a065fc05"]]);
    const _hoisted_1$2 = { class: "me-page" };
    const _hoisted_2$2 = { class: "user-info" };
    const _hoisted_3$1 = { key: 0 };
    const _hoisted_4 = { class: "user-name" };
    const _hoisted_5 = { class: "data-title" };
    const _hoisted_6 = { class: "data-list" };
    const _sfc_main$2 = /* @__PURE__ */ defineComponent({
      __name: "Me",
      setup(__props) {
        const router2 = useRouter();
        const userStore = useUserStore();
        const { userName, avatar } = storeToRefs(userStore);
        const { updateAvatar } = userStore;
        const pageStore = usePageStore();
        const { deleteMaterial } = pageStore;
        const { signOut, signIn, isAuthenticated } = $a52d863b14a9eb8e$export$44fc9df4d2a1789a();
        const handleSignIn = () => {
          sessionStorage.setItem("redirect", location.href);
          signIn("https://p-easy.net/site/redirect");
        };
        const handleSignOut = () => signOut("https://p-easy.net/site/");
        const handleUpdateAvatar = (img) => {
          updateAvatar(img);
        };
        let showProjectModal = ref(false);
        let showSaveMaterialModal = ref(false);
        let curMaterial = ref(null);
        let curEditProject = ref(null);
        let showMap = reactive({});
        let titleMap = {
          project: $t("project"),
          template: $t("template"),
          component: $t("component"),
          section: $t("section")
        };
        onMounted(async () => {
          if (!isAuthenticated.value) {
            showMap["project"] = [];
            return;
          }
          const setGlobalLoading = getSetLoading();
          const hide = setGlobalLoading == null ? void 0 : setGlobalLoading($t("loading"));
          const { data: data2 } = await projectApi.get("");
          showMap["project"] = data2;
          const res = await materialApi.get("", {
            query: { section: true, component: true, template: true, onlySelf: true }
          });
          hide == null ? void 0 : hide();
          ["template", "section", "component"].forEach((key) => {
            var _a;
            if (((_a = res.data[key]) == null ? void 0 : _a.length) > 0) {
              showMap[key] = res.data[key];
            } else {
              showMap[key] = [];
            }
          });
        });
        let projectList = computed(() => showMap["project"] || []);
        const handleGotoProject = (project) => {
          if (!project) {
            router2.push({
              name: "template"
            });
          } else {
            router2.push({
              name: "edit",
              params: {
                id: project.id
              }
            });
          }
        };
        const handleDeleteProject = async (project) => {
          if (await Modal.confirm($t("deleteConfirm", project.name))) {
            await projectApi.delete(project.id);
            showMap["project"] = projectList.value.filter((p2) => p2.id !== project.id);
            Alert($t("deleteSuccess"));
          }
        };
        const handleOpenProjectModal = (project) => {
          showProjectModal.value = true;
          curEditProject.value = project;
        };
        const handleSaveProject = async (project) => {
          if (!curEditProject.value)
            return;
          await projectApi.patch(curEditProject.value.id, {
            name: project.name,
            cover: project.cover
          });
          curEditProject.value.name = project.name;
          curEditProject.value.cover = project.cover;
          showProjectModal.value = false;
          curEditProject.value = null;
          Alert($t("saveSuccess"));
        };
        const handleSaveToTemplate = async (project) => {
          setCurMaterialByProject(project);
          showSaveMaterialModal.value = true;
        };
        const handleMaterialImageClick = async (material) => {
          if (material.type === "template") {
            if (await Modal.confirm($t("createTemplateTip"))) {
              const { data: data2 } = await projectApi.patch("", {
                name: material.name,
                cover: material.cover,
                page: material.page
              });
              handleGotoProject(data2);
            }
          } else {
            curMaterial.value = material;
            showSaveMaterialModal.value = true;
          }
        };
        const handleMaterialSetting = async (material) => {
          curMaterial.value = material;
          showSaveMaterialModal.value = true;
        };
        const setCurMaterialByProject = (project) => {
          curMaterial.value = {
            name: project.name,
            enName: "",
            type: "template",
            category: "",
            categoryEn: "",
            cover: project.cover || "",
            page: project.page
          };
        };
        const updateMaterial = (material) => {
          if (!curMaterial.value)
            return;
          if (curMaterial.value.id) {
            showMap[curMaterial.value.type] = showMap[curMaterial.value.type].map((m) => {
              if (m.id === curMaterial.value.id) {
                return material;
              }
              return m;
            });
          } else {
            showMap[curMaterial.value.type].push(material);
          }
        };
        const handleDeleteMaterial = async (material) => {
          if (await Modal.confirm($t("deleteConfirm", material.name))) {
            await deleteMaterial(material.id);
            showMap[material.type] = showMap[material.type].filter((p2) => p2.id !== material.id);
            Alert($t("deleteSuccess"));
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$2, [
            createBaseVNode("div", _hoisted_2$2, [
              createVNode(Avatar, {
                image: unref$1(avatar),
                size: 120,
                "can-upload": "",
                "on-upload": handleUpdateAvatar
              }, null, 8, ["image"]),
              !unref$1(isAuthenticated) ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
                createVNode(Btn, {
                  class: "sign-btn",
                  type: "btn",
                  color: "primary",
                  onClick: handleSignIn
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref$1($t)("signIn")), 1)
                  ]),
                  _: 1
                })
              ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("div", _hoisted_4, toDisplayString(unref$1(userName)), 1),
                createVNode(Btn, {
                  class: "sign-btn",
                  type: "btn",
                  color: "default",
                  onClick: handleSignOut
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref$1($t)("signOut")), 1)
                  ]),
                  _: 1
                })
              ], 64))
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(showMap), (list, type2) => {
              return withDirectives((openBlock(), createElementBlock("div", {
                class: normalizeClass(["data-wrapper", `data-wrapper-${type2}`]),
                key: type2
              }, [
                createBaseVNode("div", _hoisted_5, toDisplayString(unref$1(titleMap)[type2]), 1),
                createBaseVNode("div", _hoisted_6, [
                  type2 === "project" ? (openBlock(), createBlock(MaterialCard, {
                    key: 0,
                    type: "project",
                    "is-new": "",
                    onOnProjectClick: handleGotoProject
                  })) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(list, (item, index2) => {
                    return openBlock(), createBlock(MaterialCard, {
                      key: item.name + index2,
                      type: type2,
                      item,
                      onOnProjectClick: handleGotoProject,
                      onOnMaterialClick: handleMaterialImageClick,
                      onOnSaveTemplate: handleSaveToTemplate,
                      onOnSettingProject: handleOpenProjectModal,
                      onOnDeleteProject: handleDeleteProject,
                      onOnSettingMaterial: handleMaterialSetting,
                      onOnDeleteMaterial: handleDeleteMaterial
                    }, null, 8, ["type", "item"]);
                  }), 128))
                ])
              ], 2)), [
                [vShow, type2 === "project" || list.length > 0]
              ]);
            }), 128)),
            curEditProject.value ? (openBlock(), createBlock(_sfc_main$6, {
              key: 0,
              modelValue: showProjectModal.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showProjectModal.value = $event),
              project: curEditProject.value,
              "hide-create-cover": "",
              onSave: handleSaveProject
            }, null, 8, ["modelValue", "project"])) : createCommentVNode("", true),
            curMaterial.value ? (openBlock(), createBlock(_sfc_main$o, {
              key: 1,
              "action-text": curMaterial.value.id ? unref$1($t)("edit") : unref$1($t)("saveOf"),
              material: curMaterial.value,
              "hide-create-cover": "",
              modelValue: showSaveMaterialModal.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => showSaveMaterialModal.value = $event),
              "on-save": updateMaterial
            }, null, 8, ["action-text", "material", "modelValue"])) : createCommentVNode("", true)
          ]);
        };
      }
    });
    const Me_vue_vue_type_style_index_0_scoped_799c685d_lang = "";
    const Me = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-799c685d"]]);
    const _hoisted_1$1 = { class: "template-page" };
    const _hoisted_2$1 = { class: "template-list" };
    const _hoisted_3 = ["href"];
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "Template",
      setup(__props) {
        const router2 = useRouter();
        useUserStore();
        let template2 = ref([]);
        let selectedId = ref("");
        onBeforeMount(async () => {
          const res = await materialApi.get("", {
            query: { template: true, section: false, component: false }
          });
          template2.value = res.data.template || [];
        });
        const handleGotoProject = () => {
          if (selectedId.value === "empty") {
            router2.push({
              name: "create"
            });
          } else {
            router2.push({
              name: "create",
              query: {
                templateId: selectedId.value
              }
            });
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$1, [
            createBaseVNode("div", {
              class: normalizeClass(["title", { highlight: selectedId.value }])
            }, [
              createBaseVNode("span", null, toDisplayString(selectedId.value ? _ctx.$t("templateStart") : _ctx.$t("templateTip")), 1),
              selectedId.value ? (openBlock(), createBlock(Icon$1, {
                key: 0,
                name: "start",
                size: 36,
                type: "btn",
                onClick: handleGotoProject
              })) : createCommentVNode("", true)
            ], 2),
            createBaseVNode("div", _hoisted_2$1, [
              createVNode(MaterialCard, {
                type: "project",
                "is-new": "",
                selected: selectedId.value === "empty",
                "new-text": _ctx.$t("emptyProject"),
                onOnProjectClick: _cache[0] || (_cache[0] = ($event) => selectedId.value = "empty")
              }, null, 8, ["selected", "new-text"]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(template2.value, (item) => {
                return openBlock(), createBlock(MaterialCard, {
                  class: "template-item",
                  key: item.id,
                  type: "template",
                  item: template2.value[0],
                  selected: selectedId.value === item.id,
                  "hide-operate": "",
                  onOnMaterialClick: ($event) => selectedId.value = item.id
                }, {
                  default: withCtx(() => [
                    selectedId.value === item.id ? (openBlock(), createElementBlock("a", {
                      key: 0,
                      class: "preview-btn",
                      target: "_blank",
                      href: unref$1(templatePreviewUrl)(item.id)
                    }, toDisplayString(_ctx.$t("preview")), 9, _hoisted_3)) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["item", "selected", "onOnMaterialClick"]);
              }), 128))
            ])
          ]);
        };
      }
    });
    const Template_vue_vue_type_style_index_0_scoped_d43ec02b_lang = "";
    const Template = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-d43ec02b"]]);
    const _hoisted_1 = { class: "not-found-page" };
    const _hoisted_2 = { class: "text" };
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "NotFound",
      setup(__props) {
        const router2 = useRouter();
        const handleGotoHome = () => {
          router2.replace({
            name: "home"
          });
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1, [
            createBaseVNode("div", _hoisted_2, toDisplayString(_ctx.$t("pageNotFound")), 1),
            createVNode(Btn, { onClick: handleGotoHome }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$t("backToHome")), 1)
              ]),
              _: 1
            })
          ]);
        };
      }
    });
    const NotFound_vue_vue_type_style_index_0_scoped_f714802b_lang = "";
    const NotFound = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-f714802b"]]);
    const needReloadPage = (to, from, next) => {
      if (from.name && !(from.name === "create" && to.name === "edit")) {
        location.href = "/site/" + to.fullPath.slice(1);
      } else {
        next();
      }
    };
    const router = createRouter({
      history: createWebHistory("/site/"),
      routes: [
        { path: "", redirect: "/edit", name: "home" },
        { path: "/edit", component: Configure, name: "create", beforeEnter: needReloadPage },
        { path: "/edit/:id", component: Configure, name: "edit", beforeEnter: needReloadPage },
        { path: "/me", component: Me, name: "user" },
        { path: "/template", component: Template, name: "template" },
        { path: "/redirect", component: _sfc_main$4, name: "redirect" },
        { path: "/:pathMatch(.*)", component: NotFound, name: "not-found" }
      ]
    });
    const config = {
      endpoint: "https://p-easy.net",
      appId: "c4319adTcyr9vXJ1XYU3m",
      resources: ["https://api.logto.io"]
    };
    const app = createApp(App);
    app.use(router);
    app.use($a52d863b14a9eb8e$export$d8f887f9089028d2, config);
    app.use(pinia);
    app.use(GlobalDirective);
    app.use(src_default, {
      position: "bottom-right",
      timeout: 2e3,
      closeOnClick: true,
      pauseOnFocusLoss: true,
      pauseOnHover: true,
      draggable: false,
      showCloseButtonOnHover: false,
      hideProgressBar: true,
      closeButton: false,
      icon: true,
      rtl: false
    });
    app.directive("tooltip", VTooltip);
    app.directive("close-popper", VClosePopper);
    app.component("Text", Text);
    app.component("Block", Block);
    app.component("Image", Image$1);
    app.component("Icon", Icon);
    app.config.globalProperties.$t = $t;
    app.mount("#app");
  }
});
export default require_index_e12ed25b();
//# sourceMappingURL=index.e12ed25b.js.map
